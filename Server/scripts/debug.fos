// Debug functions

#include "_macros.fos"
#include "_colors.fos"

import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void ApplyMutation( Critter& cr ) from "morphes";
import void _MobInit( Critter& npc, bool firstTime ) from "mob";
import void FlushScreen( Critter& cr, uint fromColor, uint toColor, uint timeMs ) from "effects";
import void GM_MobInit( Critter& npc ) from "mob";

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Trinitro
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define FIND_DIST    ( 16 )

void CanabisPatrol( Critter& cr, int p0, int p1, int p2 ) {
	Map @map = cr.GetMap();
	if(!valid(map)) {
		cr.Say(SAY_NETMSG, "На глобале нельзя!");
		return;
	}
	
	int[] CanabisPid = { 1630, 1631, 1632, 1633, 1634 };
	
	//Подсчёт количества в мире:
	int[] count = { 0, 0, 0, 0, 0 };
	string[] names = { "Пакетов семян", "Гектаров полей", "Пачек травы"};
	for( int i = 0, iEnd = CanabisPid.length(); i < iEnd; i++ ) 
		count[i] = WorldItemCount(CanabisPid[i]);

	string result = "Наркоконтроль сообщает, что всего в мире:\n" + 
		names[0] + ": " + count[0] + ";\n" +
		names[1] + ": " + count[1] + "/" + count[2] + "/" + count[3] + ";\n" +
		names[2] + ": " + count[4] + ";\n";
	cr.Say( SAY_NETMSG, result );
	
	//Подсчёт количества на удаление:
	int[] count2 = { 0, 0, 0, 0, 0 };

	Critter@[] holder;
	map.GetCritters( 0, FIND_LIFE, holder );
	for( int i = 0, iEnd = holder.length(); i < iEnd; i++ ) {
		Item@[] item;
		holder[i].GetItems( -1, item );
		for( int j = 0, jEnd = item.length(); j < jEnd; j++) {
			if(!valid(item[j])) continue;
			int n = CanabisPid.find( item[j].GetProtoId() );
			if( n != -1 ) {
				count2[n]+= item[j].GetCount();
				DeleteItem( item[j] );
			}
		}
	}
	
	Item@[] drug;
	for( int i = 0, iEnd = CanabisPid.length(); i < iEnd; i++ )
		count2[i] += map.GetItems( CanabisPid[i], drug );

	for( int i = 0, iEnd = drug.length(); i < iEnd; i++ ) {
		switch( drug[i].Accessory ) { 
			case(ACCESSORY_HEX):       
				map.SetText( drug[i].HexX, drug[i].HexY, COLOR_GRAY, "густой дым" );
			break;
			//case(ACCESSORY_NONE):      break;
			//case(ACCESSORY_CRITTER):   break;
			//case(ACCESSORY_CONTAINER): break;
			default: break;
		}
		if(valid(drug[i]))
			DeleteItem(drug[i]);
	}
	
	result = "На этой локации было уничтожено:\n" + 
		names[0] + ": " + count2[0] + ";\n" +
		names[1] + ": " + count2[1] + "/" + count2[2] + "/" + count2[3] + ";\n" +
		names[2] + ": " + count2[4] + ";\n";
	cr.Say( SAY_NETMSG, result );
}

/*
void MakeRush( Critter& player, int player_id, int value, int param2 )
{
	Critter@ target = GetCritter(player_id);
	if(!valid(target)) { player.Say( SAY_NETMSG, "Целевой криттер не найден!" ); return; }
    target.StatBase[ST_EXPERIENCE_MULTIPLIER_TIME] = 0;
	target.StatBase[ST_EXPERIENCE_MULTIPLIER] = CLAMP( value, -10, 10 );
	player.Say( SAY_NETMSG, "Уровен ареналина установлен на '" + target.StatBase[ST_EXPERIENCE_MULTIPLIER] + "'" );
}

void unsafe_SetRush( Critter& cr, int delta, int p1, int p2, string@ message, int[] @ p4 )
{
    cr.StatBase[ST_EXPERIENCE_MULTIPLIER_TIME] = delta;
}
*/
void unsafe_ExpToSp( Critter& cr, int value, int cost, int p2, string@ message, int[] @ p4 )
{
	if ( cr.StatBase[ST_EXPERIENCE] - value * cost < 66000 ) {
		cr.Say( SAY_NETMSG, "Отличная попытка, но.. нет." );
		return;
	}
    cr.StatBase[ST_EXPERIENCE] -= value * cost;
	cr.StatBase[ST_UNSPENT_SKILL_POINTS] += value;
	cr.Say( SAY_NETMSG, "Вы конвертировали " + ( value * cost ) + " опыта в " + value + " скиллпоинтов!" );
}

void unsafe_ExpToPp( Critter& cr, int value, int cost2, int p2, string@ message, int[] @ p4 )
{
	if ( cr.StatBase[ST_EXPERIENCE] - value * cost2 < 66000 ) {
		cr.Say( SAY_NETMSG, "Отличная попытка, но.. нет." );
		return;
	}
    cr.StatBase[ST_EXPERIENCE] -= value * cost2;
	cr.StatBase[ST_UNSPENT_PERKS] += value;
	cr.Say( SAY_NETMSG, "Вы конвертировали опыт в " + value + " перкпоинтов!" );
}

void FastLoot( Critter& player, int param0, int param1, int param2 )
{
	Item@[] loot,empty;
	Item@[] container;
    Map@ map = player.GetMap();
	if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
	map.GetItemsByType( ITEM_TYPE_CONTAINER, container );
	uint len = container.length();

	int locked = 0;
	for( uint i = 0; i < len; i++ )
	{
		if(container[i].LockerCondition != LOCKER_LOCKED)
		{
			container[i].GetItems(uint(-1),loot);
			MoveItems(loot,player);
			loot = empty;
		}
		else locked++;
	}
	player.Say( SAY_NETMSG, "Вы облутали " + len + " контейнеров, из них " + locked + " были приватными." );
	if( param0 != 0 && param1 != 0 && param2 != 0 )
		DifferLoot( player, param0, param1, param2 );
}

void CheckLoot( Critter& player, int param0, int param1, int param2 )
{
	Item@[] loot;
	if( param0 != 0 ) 
	{
		Map@ map = player.GetMap();
		if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
		Item@ LootBox = map.GetItem( param0 );
		if( !valid(LootBox) ) { player.Say( SAY_NETMSG, "Контейнер не найден!" ); return; }
		LootBox.GetItems( uint( -1 ), loot );
	}
	else
		player.GetItems( -1, loot );
	Item@ item = null;
	uint count = 0, allc = 0, allp = 0, price = 0, pid = 0;
	for(uint i = 0, iEnd = loot.length(); i < iEnd; i++ ) 
	{
		@item = @loot[i];
		pid = item.GetProtoId();
		count = item.Proto.Stackable ? item.GetCount() : 1; 
		price = item.GetCost();// * count;
		player.Say( SAY_NETMSG, i + ") " + pid + " x" + count + "(" + item.Proto.Cost + "$) " + price + "$" );
		allc += count;
		allp += price;
	}
	player.Say( SAY_NETMSG, "Всего " + allc + " объектов общей стоимостью " + allp + "$" );
}

void DifferLoot( Critter& player, int param0, int param1, int param2 )
{
	if( param0 == 0 || param0 == 1 || param2 == 0 ) 
	{ 
		player.Say( SAY_NETMSG, "Укажите id для трёх целевых контейнеров сортировки:\n1) Оружие и броня.\n2) Ключи, наркотики и патроны.\n3) Остальное."); 
		return; 
	}
	
	Map@ map = player.GetMap();
	
	if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
	
	Item@ GearBox = map.GetItem(param0);
	Item@ DrugBox = map.GetItem(param1);
	Item@ StuffBox = map.GetItem(param2);
	
	if( !valid(GearBox) || !valid(StuffBox) || !valid(StuffBox) ) { player.Say( SAY_NETMSG, "Отсутствует один из контейнеров!" ); return; }

    Item@ item;
	Item@[] items;
    player.GetItems( -1, items );

	uint16 count, c1, c2, c3, allc, i, pid;
	uint32 price, p1, p2, p3, allp;
	count = c1 = c2 = c3 = allc = i = pid = price = p1 = p2 = p3 = allp = 0; //Очистка от мусора, а то хрень вылезала.
	for( i = 0; i < items.length(); i++ ) 
	{
		@item = @items[i];
		pid = item.GetProtoId();
		count = GetProtoItem(pid).Stackable ? item.GetCount() : 1;
		price = item.GetCost();
		switch( items[i].GetType() )
		{
			case(ITEM_TYPE_ARMOR):
			case(ITEM_TYPE_WEAPON):
					c1 += count;
					p1 += price;
					MoveItem( item, count, GearBox, 0 );//StackId || SpecialId ?
				break;
			case(ITEM_TYPE_DRUG):
			case(ITEM_TYPE_AMMO):
			case(ITEM_TYPE_KEY):
					c2 += count; 
					p2 += price;
					MoveItem( item, count, DrugBox, 0 );//StackId || SpecialId ?
				break;
			case(ITEM_TYPE_MISC):
			//case(ITEM_TYPE_MISC2): //not declared!
					c3 += count;
					p3 += price;
					MoveItem( item, count, StuffBox, 0 );//StackId || SpecialId ?
				break;
			default: continue;
		}
	}
	allc = c1 + c2 + c3;
	allp = p1 + p2 + p3;
	player.Say( SAY_NETMSG, "Вы распределили " + i + " стэков по категориям:" + 
						"\n1) Оружие и броня x" + c1 + " на " + p1 + "$" + 
						"\n2) Ключи, наркотики и патроны x" + c2 + " на " + p2 + "$" +
						"\n3) Остальное x" + c3 + " на " + p3 + "$" +
						"\n Итого x" + allc + " объектов на сумму в " + allp + "$");
}

void Radiate( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = null;
    if( param0 == 0 )
        @target = player;
    else
        @target = GetCritter( param0 );
    AffectRadiation( target, param1 ); //Чувствительность увеличена стократно (1.00 раньше == 100 рад теперь ), но ребаланс не делаю!
}

void Mutate( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = null;
    if( param0 == 0 )
        @target = player;
    else
        @target = GetCritter( param0 );
    ApplyMutation( target );
}

void ViewPlanes( Critter& player, int param0, int param1, int param2 )
{
    if( param0 == 0 )
        param0 = 20;

    Map@ map = player.GetMap();
    if( not valid( map ) )
        return;

    Critter@[] critters;
    uint count = 0;
    if( param1 == 0 )
        count = map.GetCrittersHex( player.HexX, player.HexY, param0, FIND_ALL | FIND_ONLY_NPC, critters );
    else
    {
        Critter@ cr = GetCritter( param1 );
        if( not valid( cr ) )
            return;
        critters.resize( 1 );
        @critters[ 0 ] = cr;
    }

    for( uint i = 0; i < count; i++ )
    {
        NpcPlane@[] p;
        uint pcount = critters[ i ].GetPlanes( p );
        for( uint j = 0; j < pcount; j++ )
        {
            uint[] param = { critters[ i ].Id, p[ j ].Type, p[ j ].Priority };
            switch( p[ j ].Type )
            {
            case AI_PLANE_MISC:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Misc_WaitSecond;
                param[ 4 ] = p[ j ].Misc_ScriptId;
                break;
            case AI_PLANE_ATTACK:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Attack_TargId;
                param[ 4 ] = p[ j ].Attack_MinHp;
                break;
            case AI_PLANE_WALK:
                param.resize( 8 );
                param[ 3 ] = p[ j ].Walk_HexX;
                param[ 4 ] = p[ j ].Walk_HexY;
                param[ 5 ] = p[ j ].Walk_Dir;
                if( p[ j ].Run )
                    param[ 6 ] = 1;
                else
                    param[ 6 ] = 0;
                param[ 7 ] = p[ j ].Walk_Cut;
                break;
            case AI_PLANE_PICK:
                param.resize( 6 );
                param[ 3 ] = p[ j ].Pick_HexX;
                param[ 4 ] = p[ j ].Pick_HexY;
                param[ 5 ] = p[ j ].Pick_Pid;
                break;
            }
            CreateTimeEvent( __FullSecond + 60 + j, "e_ViewPlanes", param, false );
        }
    }
}

uint e_ViewPlanes( uint[] @ values )
{
    Critter@ crit = GetCritter( values[ 0 ] );
    if( not valid( crit ) )
        return 0;

    string msg = "error";
    switch( values[ 1 ] )
    {
    case AI_PLANE_MISC:
        msg = "<<MISC>> Prior=" + values[ 2 ];
        msg += " WaitMinute=" + values[ 3 ] + " ScriptId=" + values[ 4 ];
        break;
    case AI_PLANE_ATTACK:
        msg = "<<ATTACK>> Prior=" + values[ 2 ];
        msg += " TargId=" + values[ 3 ] + " MinHp=" + values[ 4 ];
        break;
    case AI_PLANE_WALK:
        msg = "<<WALK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Dir=" + values[ 5 ];
        msg += " Run=" + values[ 6 ] + " Cut=" + values[ 7 ];
        break;
    case AI_PLANE_PICK:
        msg = "<<PICK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Pid=" + values[ 5 ];
        break;
    }

    crit.Say( SAY_NORM_ON_HEAD, msg );
    return 0;
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// heX
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";

#define def    # ( X, DEF )( X == 0 ? DEF : X )

void lvl( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void team( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_TEAM_ID ] ) );
}

void role( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_NPC_ROLE ] ) );
}

void info( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ param0 ] ) );
}

void hp( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_CURRENT_HP ] ) + "/" + "" + ( critters[ i ].Stat[ ST_MAX_LIFE ] ) );
}

// plan count
void planc( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].GetPlanes( null ) ) );
}

// show plans list
void plans( Critter& player, int param0, int param1, int param2 )
{
    NpcPlane@[] planes;
    string str;
    Critter@[] critters;
    uint   count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
    {
        str = "";
        uint count = critters[ i ].GetPlanes( planes );
        for( uint j = 0; j < count; j++ )
        {
            switch( planes[ j ].Type )
            {
            case AI_PLANE_MISC:
                str = str + "M ";
                break;
            case AI_PLANE_ATTACK:
                str = str + "A ";
                break;
            case AI_PLANE_WALK:
                str = str + "W ";
                break;
            case AI_PLANE_PICK:
                str = str + "P ";
                break;
            case AI_PLANE_PATROL:
                str = str + "P ";
                break;
            case AI_PLANE_COURIER:
                str = str + "C ";
                break;
            }
        }
        critters[ i ].Say( SAY_NORM_ON_HEAD, str );
    }
}

// player level info
void lvli( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST * 2, FIND_LIFE | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, GetPlayerName( critters[ i ].Id ) + ": " + "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void dmg( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    InjureCritter( target, param1, param2, 0, player.Id );
}

void kill( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    target.Say( SAY_NETMSG, "Кара небесная поразила вас!" );
    target.ToDead( def( param1, ANIM2_DEAD_PULSE_DUST ), player );
    // target.SetTimeout(TO_REPLICATION, 3);
}

void body( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.ChangeCrType( param1 );
}

void anim( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.Animate( param1, param2, null, true, true );
}

void testmap( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] groups;
    groups.insertLast( @player );
    uint      locid = CreateLocation(
        def( param1, 400 ), player.WorldX, player.WorldY, groups );
    Location@ loc = GetLocation( locid );
    // if(not valid(loc)) GetMapByPid(mapProtoId, skipCount);
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map@ map;
    if( param0 != 0 )
        @map = loc.GetMap( param0 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
        return;
    player.TransitToMap( map.Id, 0 );
}

// Come To Daddy gm
void _ctd( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    ctd( player, param0, param1, param2 );
}

// Come To Daddy
void ctd( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;

    Critter@ daddy = ( ( param2 != 0 ) ? target : player );
    Critter@ child = ( ( param2 == 0 ) ? target : player );


    Map@ map = daddy.GetMap();
    if( not valid( map ) )
        return;

	if( child.Quest[ QST_GAMEMODE ] == GAME_START && daddy.GetAccess() <= ACCESS_MODER )
	{
    child.Say( SAY_NETMSG, "Игрок в стартовом режиме, его нельзя телепортировать." );
    return;
	}


    uint8 temp_dir = Random( 0, 5 );
    for( uint i = 0; i < 6; i++ )
    {
        uint16 hexX = daddy.HexX, hexY = daddy.HexY;
        map.MoveHexByDir( hexX, hexY, ( temp_dir + i ) % 6, 1 + param1 );
        if( not map.IsHexPassed( hexX, hexY ) )
            continue;
        child.TransitToMap( map.Id, hexX, hexY, 0 );
        break;
    }

}

void CalmDown( Critter& player, int crId, int param1, int param2 )
{
    Critter@ cr = GetCritter( crId );
    if( !valid( cr ) || cr.IsPlayer() )
    {
        player.Say( SAY_NETMSG, "НПЦ не найдет" );
        return;
    }
    else
        cr.ClearEnemyStack();
}

void god( Critter& player, int, int, int )
{
    for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
        player.StatBase[ i ] = 10;
    for( uint i = ST_NORMAL_ABSORB; i <= ST_EXPLODE_ABSORB; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = ST_NORMAL_RESIST; i <= ST_POISON_RESISTANCE; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = SK_SMALL_GUNS; i <= SK_OUTDOORSMAN; i++ )
        player.SkillBase[ i ] = 300;
    player.StatBase[ ST_MELEE_DAMAGE ] = 999;
    player.StatBase[ ST_ARMOR_CLASS ] = 100;
    player.StatBase[ ST_CURRENT_HP ] = 9999;
    player.StatBase[ ST_MAX_LIFE ] = 9999;
}

void GM_god( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
        player.StatBase[ i ] = 10;
    for( uint i = SK_SMALL_GUNS; i <= SK_OUTDOORSMAN; i++ )
        player.SkillBase[ i ] = 300;
    player.PerkBase[ PE_SHARPSHOOTER ] = 100;
    player.PerkBase[ PE_STRONG_BACK ] = 10;
    player.PerkBase[ PE_SILENT_RUNNING ] = 1;
    player.PerkBase[ PE_AWARENESS ] = 2;
    player.PerkBase[ PE_PATHFINDER ] = 3;
    player.StatBase[ ST_MAX_LIFE ] = 120;
    player.StatBase[ ST_CURRENT_HP ] = 9999;
    player.ModeBase[ MODE_HIDE ] = 1;
    player.ModeBase[ MODE_NO_LOOSE_LIMBS ] = 1;
    player.ModeBase[ MODE_INVULNERABLE ] = 1;
    player.ModeBase[ MODE_NO_STEAL ] = 1;
}

void mapid( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    player.Say( SAY_NETMSG, "" + ( map.GetProtoId() ) );
}

void GM_tele( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    tele( player, param0, param1, param2 );
}

void tele( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    Location @ loc = GetLocationByPid( def( param1, player.GetMap().Id ), 0 );
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map @ map = loc.GetMapByIndex( param2 );
    if( not valid( map ) )
    {
        player.Say( SAY_NETMSG, "Map index not found" );
        @map = loc.GetMapByIndex( 0 );
        if( not valid( map ) )
            return;
    }

    target.SetWorldPos(loc.WorldX, loc.WorldY);
    target.TransitToMap( map.Id, 0 );
}

void items( Critter& player, int param0, int param1, int param2 )
{
    Item@[] items;
    uint count = player.GetMap().GetItems( player.HexX, player.HexY, items );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, "" + items[ i ].GetProtoId() );
}

void id( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Id ) );
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ...
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ~run debug ToMapEntire 42 0 0
void ToMapEntire( Critter& player, int mapPid, int entire, int skip )
{
    Map@ map = ::GetMapByPid( mapPid, skip );
    if( valid( map ) )
    {
        player.TransitToMap( map.Id, entire );
    }
    else
    {
        player.Say( SAY_NETMSG, "Карта с pid=" + mapPid + " не найдена" );
    }
}

void ToMap( Critter& player, int mapPid, int X, int Y )
{
    Map@ map = GetMapByPid( mapPid, 0 );
    if( valid( map ) )
    {
        player.TransitToMap( map.Id, X, Y, 0 );
    }
    else
    {
        player.Say( SAY_NETMSG, "Карта с pid=" + mapPid + " не найдена" );
    }
}

// ищет нпц по диалогу на карте указанного прототипа
void NpcByDialog( Critter& player, int mapPid, int dialog, int )
{
    Map@ map = ::GetMapByPid( mapPid, 0 );
    if( valid( map ) )
    {
        Critter @[] npc;

        if( map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, npc ) == 0 )
        {

            player.Say( SAY_NETMSG, "не найдено нпц с таким диалогом" );

        }
        else
        {
            uint idF = 0;
            uint l = 0;
            for( uint i = 0; i < npc.length(); i++ )
            {
                if( npc[ i ].Stat[ ST_DIALOG_ID ] == dialog )
                {
                    l++;
                    idF = ( idF == 0 ? npc[ i ].Id : idF );
                }
            }
            player.Say( SAY_NETMSG, "Найдено нпц, в штуках:" + l + " Id первого:" + idF );
        }
    }

}

void SetReputation( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.ReputationBase[ num ] = val;
}

void Siren( Critter& cr, int, int, int )
{
    Map @ map = cr.GetMap();
    if( !valid( map ) )
    {
        cr.Say( SAY_NETMSG, "Невозможно проиграть звук на глобальной карте" );
        return;
    }
    map.PlaySound( "AIRSIREN.OGG" );
}

void Mirelurk( Critter& cr, int, int, int )
{
    cr.GetMap().AddNpc( 487, cr.HexX - 3, cr.HexY - 3, 0, null, null, null );

}

/*
   ~run debug ToMapEntire 137 0 0
   ~run debug Siren 0 0 0
   ~run debug Mirelurk 0 0 0
   ~loadscript debug
   ~run debug SetMode 1 527 1
   ~run test SetStat

 */
void SetMode( Critter& cr, int id, int mode, int value )
{
    Critter @ crit = GetCritter( id );
    crit.ModeBase[ mode ] = value;
}

void RunMapLoop( Critter& player, int ms, int param1, int param2 )
{
    Map@ map = player.GetMap();
    map.SetLoopTime( 0, ms );
    map.SetLoopTime( 1, ms + 500 );
    map.SetEvent( MAP_EVENT_LOOP_0, "e_Map_Loop_0_Run" );
    map.SetEvent( MAP_EVENT_LOOP_1, "e_Map_Loop_1_Run" );


}

void e_Map_Loop_0_Run( Map& map )
{
    map.SetLoopTime( 0, 3000 );
    Display_Ms_Msg( map );
}

void e_Map_Loop_1_Run( Map& map )
{
    map.SetLoopTime( 1, 3000 );
    Display_Ms_Msg( map );
}

void Display_Ms_Msg( Map& map )
{
    uint16 year = 0, month = 0, week = 0, day = 0, hour = 0, minute = 0, sec = 0, ms = 0;
    Critter @[] critArr( 1 );
    map.GetCritters( 0, FIND_ALL, critArr );

    if( critArr.length() == 0 )
        Log( "Не найдено криттеров" );
    else
    {

        Critter @ crt = critArr[ critArr.length() - 1 ];
        GetTime( year, month, week, day, hour, minute, sec, ms );
        crt.Say( SAY_SHOUT, "Current local second " + sec + "," + ms ); // SAY_SHOUT
    }
}

void Check_Dict_Element( Critter& player, int, int, int )
{
    dictionary dict;
    dict.set( player.Id + "|" + 1, 1 );
    dict.set( player.Id + "|" + 2, 2 );
    dict.set( player.Id + "|" + 3, 3 );
    if( dict.exists( player.Id + "|*" ) )
        player.Say( SAY_NORM, "Словарь обрабатывает звездочку в ключе" );
    else
        player.Say( SAY_NORM, "Хуй вам, словарь не обрабатывает звездочку в ключе" );
}

void SetRain( Critter& player, int capacity, int param1, int param2 )
{
    Map@ map = player.GetMap();
    if( !valid( map ) )
        return;
    map.SetRain( capacity );
}


void GetCapacityRain( Critter& player, int param0, int param1, int param2 )
{
    Map@ map = player.GetMap();
    if( !valid( map ) )
        return;
    player.Say( SAY_NETMSG, "Rain power: " + map.GetRain() );
}

void GetParam( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.Param[ num ] );
}

void GetParamBase( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.ParamBase[ num ] );
}

void SetParam( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ParamBase[ num ] = val;
        player.Say( SAY_NETMSG, "Done." );
    }
}

void GetId( Critter& player, int playerId, int param1, int param2 )
{
    player.ShowScreen( SCREEN_CLOSE, 0, "" );
    player.ShowScreen( SCREEN_SAY, 0, "answer_GetId" );
    player.Say( SAY_SAY_TITLE, "Введите логин персонажа." );
}

void answer_GetId( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() < 3 )
        return;

    Critter@ cr = GetPlayer( answerS );

    if( !valid( cr ) )
    {
        player.Say( SAY_NETMSG, "Нет такого персонажа." );
        return;
    }

    player.Say( SAY_NETMSG, "Login: " + answerS + " Id: " + cr.Id );
}

void NetId( Critter& player, int searchRadius, int, int )
{
    Critter @[] crits;
    player.GetMap().GetCrittersHex( player.HexX, player.HexY, searchRadius, FIND_ALL, crits );
    player.Say( SAY_NETMSG, "my info: HexX=" + player.HexX + "; HexY=" + player.HexY + "; SearchRadius=" + searchRadius );
    for( uint i = 0; i < crits.length(); i++ )
    {
        player.Say( SAY_NETMSG, "Critter Pid:" + crits[ i ].GetProtoId() + "; Dialog:" + crits[ i ].Stat[ ST_DIALOG_ID ] + "; Id:" + crits[ i ].Id );
    }
    player.Say( SAY_NETMSG, "Total: " + crits.length() );
}

void SetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( id );
    if( valid( cr ) )
    {
        cr.ParamBase[ param ] = value;
    }
}

void GetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( id );
    if( valid( cr ) )
    {
        player.Say( SAY_NETMSG, "Param #" + param + " val= " + cr.Param[ param ] );
    }
}

void ShowLocation( Critter& player, int, int, int )
{
    Map @ map = player.GetMap();
    if( valid( map ) )
    {
        Location @ loc = map.GetLocation();
        if( valid( loc ) && !loc.Visible )
            loc.Visible = true;
    }
}

// end of new from SDK

void GetMap( Critter& player, int param0, int param1, int param2 )
{
    Map@   map = player.GetMap();
    string str = map.Id;
    player.Say( SAY_NETMSG, "КАРТА - " + str );
    str = player.HexX + " " + player.HexY;
    player.Say( SAY_NETMSG, "Координаты - " + str );
    str = player.Dir;
    player.Say( SAY_NETMSG, "Направление - " + str );
}

void GetEnemyStack( Critter& player, int crId, int param1, int param2 )
{
    uint[] enemyStack;
    uint     x = 0;
    string   str;
    Critter@ cr = GetCritter( crId );
    if( !valid( cr ) )
        player.Say( SAY_NETMSG, "Криттер не найдет" );
    else if( cr.IsPlayer() )
        player.Say( SAY_NETMSG, "Криттер не является НПЦ" );
    else
    {
        cr.GetEnemyStack( enemyStack );
        player.Say( SAY_NETMSG, "Список врагов:" );
        while( x < enemyStack.length() )
        {
            str = "";
            str += x;
            str += ": ";
            str += enemyStack[ x ];
            player.Say( SAY_NETMSG, str );
            x++;
        }
    }

}

/*
   #pragma bindfunc "bool Critter::toNpc() -> fonline_tla.dll Critter_toNpc"
   #pragma bindfunc "bool Critter::toPlayer() -> fonline_tla.dll Critter_toPlayer"

   void toNpc(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.toNpc();
   }

   void toPlayer(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.toPlayer();
   }

   void isNpc(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        player.GetMap().SetText (player.HexX, player.HexY, 0xFFFFFFFF, "Криттер "+cr.Id+(cr.IsNpc()?" нпс.":" игрок."));
   }

   #pragma bindfunc "string@ Critter::getName() -> fonline_tla.dll Critter_getName"


   void getName(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        player.Say(SAY_NETMSG, "У #"+ cr.Id +" имя: "+cr.getName());
   }

   #pragma bindfunc "string@ Critter::setName(int num) -> fonline_tla.dll Critter_setName"

   void setName(Critter & player, int playerId, int num, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.setName(num);
   }
 */

void deleteCritter( Critter& player, int id, int param, int value )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
        DeleteNpc( cr );
}

void rotateCritter( Critter& player, int id, int param, int value )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
    {
        cr.SetHomePos( cr.HexX, cr.HexY, param );
        cr.SetDir( param );
    }
}

void changeHome( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    cr.SetHomePos( x, y, 0 );
}

void GM_tel( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( valid( cr ) )
        cr.TransitToHex( param1, param2, cr.Dir );
}

void teleportCritter( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
        cr.TransitToHex( x, y, 0 );
}

void getCoords( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    player.Say( SAY_NETMSG, "X = " + cr.HexX + " Y = " + cr.HexY );
}

void GM_lock( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( param0 );
    if( valid( item ) )
        lock( player, param0, param1, param2 );
}

void lock( Critter& player, int itemId, int complexity, int lockId )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( itemId );
    if( valid( item ) )
    {
        item.LockerCondition = LOCKER_LOCKED;
        item.LockerComplexity = complexity;
        item.LockerId = lockId;
        item.Update();
        Item@ key = player.AddItem( PID_KEY, 1 );
        if( valid( key ) )
            key.LockerId = lockId;
        key.Update();
    }
}

void unlock( Critter& player, int itemId, int param, int param2 )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( itemId );

    if( valid( item ) )
    {
        item.LockerCondition = LOCKER_ISOPEN;
        item.LockerComplexity = 0;
        item.LockerId = 0;
        item.Update();
    }
}

void cleanEnemyStacks( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    Critter@[] crits;
    uint crCount = map.GetCritters( 0, FIND_LIFE, crits );
    for( uint i = 0; i < crCount; ++i )
    {
        if( crits[ i ].IsNpc() )
        {
            crits[ i ].ClearEnemyStack();
            crits[ i ].DropPlanes();
        }
    }
}


void SetSkin( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    if( target.ChangeCrType( param1 ) )
        target.StatBase[ ST_BASE_CRTYPE ] = param1;
}

void CreateLoc( Critter& player, int param0, int param1, int param2 )
{
    CreateLocation( param0, param1, param2, null );
}

void DeleteLoc( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocationByPid( param0, 0 );
    DeleteLocation( loc.Id );
}

void getMapId( Critter& cr, int param0, int param1, int param2 )
{
    Map @ map = cr.GetMap();
    if( !valid( map ) )
        return;
    string msg = map.Id;
//   cr.Say(SAY_NETMSG, msg);
    Location @ loc = map.GetLocation();
    if( !valid( loc ) )
    {
        msg += "loc err";
    }
    else
    {
        msg += " " + loc.Id;
    }
    cr.Say( SAY_NETMSG, msg );

}

void setcoolarmor( Critter& cr, int p0, int p1, int p2 )
{
    if( p1 == 0 )
    {
        cr.Say( SAY_NETMSG, "invalid armor pid (second parameter)" );
        return;
    }
    ;
    Critter @ target = GetCritter( def( p0, cr.Id ) );
    Item @ armor = target.GetItem( p1, SLOT_INV );
    if( !valid( armor ) )
    {
        cr.Say( SAY_NETMSG, "armor !valid" );
        return;
    }
    armor.Val1 = target.Id;
    armor.Val2 = target.StatBase[ ST_BASE_CRTYPE ];
    cr.Say( SAY_NETMSG, "BaseCrTypeTarget " + armor.Val2 );
    armor.SetScript( "debug@_CoolArmor" );
    armor.Update();
}


void _CoolArmor( Item& armor, bool firstTime )
{
    if( firstTime )
    {
        armor.SetEvent( ITEM_EVENT_MOVE, "e_ArmorMove" );
    }
}

void e_ArmorMove( Item& item, Critter& cr, uint8 fromSlot )
{
    string msg = fromSlot + " " + item.CritSlot;
    cr.Say( SAY_NETMSG, msg );
    if( uint( item.Val1 ) != cr.Id ) return;
	
    if( ( item.CritSlot == SLOT_HAND1 || item.CritSlot == SLOT_HAND1 ) && fromSlot == SLOT_INV )
    {
        cr.ChangeCrType( 3 );
        cr.MoveItem( item.Id, item.GetCount(), SLOT_ARMOR );
        cr.Action( ACTION_MOVE_ITEM, SLOT_ARMOR, item );
        cr.Action( ACTION_REFRESH, 0, null );
        item.Update();
    }
}

import uint GetAllPlayers( Critter@[]& crs ) from "manager";

void GetAllPl( Critter& cr, int p0, int p1, int p2 )
{
    Critter@[] crs;
    string msg;
    GetAllPlayers( crs );
    if( crs.length() > 0 )
    {
        msg = crs.length();
        cr.Say( SAY_NETMSG, msg );
    }
}

void delItem( Critter& cr, int p0, int p1, int p2 )
{
    if( p0 != 1 )
    {
        Item @ item = cr.GetMap().GetItem( p1 );
        if( !valid( item ) )
            return;
        DeleteItem( item );
    }
    else
    {
        Item @[] items;
        cr.GetMap().GetItems( p1, items );
        if( items.length() > 0 )
        {
            DeleteItems( items );
        }
    }
}

void ChangeProtoItems( Critter& cr, int new, int, int )
{
    Item@[] items;
    cr.GetItems( SLOT_INV, items );
	for( uint i = 0, iEnd = items.length( ); i < iEnd; i++ )
	{
		if( @GetProtoItem( new ) !is null )
			items[i].ChangeProto( new );
	}
}

void setblankscript( Critter& cr, int p0, int p1, int p2 )
{
    Item @ item = GetItem( p0 );
    if( !valid( item ) )
        return;
    item.SetScript( "" );
}

void spawnmob( Critter& cr, int p0, int p1, int p2 )
{
    uint16   hexX = 0, hexY = 0;
    Critter@[] crs;
    Critter@ mob;
    Map @ map = cr.GetMap();
    map.GetEntireCoords( p2, 0, hexX, hexY );
    map.GetCritters( 0, FIND_LIFE, crs );
    for( uint8 i = 0; i < p1; i++ )
    {
        @mob = map.AddNpc( p0, hexX + Random( -5, 5 ), hexY + Random( -5, 5 ), Random( 0, 5 ), null, null, null );
        mob.AddEnemyInStack( cr.Id );
    }
}

void delmob( Critter& cr, int p0, int p1, int p2 )
{
    Critter@[] crs;
    Map @ map = cr.GetMap();
    p1 = ( p1 == 0 ? FIND_DEAD : FIND_ALL );
    map.GetCritters( p0, p1, crs );
    for( uint16 i = 0; i < crs.length(); i++ )
    {
        DeleteNpc( crs[ i ] );
    }
}

void getadmin( Critter& cr, int p0, int p1, int p2 )
{
    Critter @[] crs;
    string msg;
    GetAllPlayers( crs );
    for( uint8 i = 0; i < crs.length(); i++ )
    {
        if( crs[ i ].GetAccess() >= ACCESS_TESTER )
        {
            msg += "player " + GetPlayerName( crs[ i ].Id ) + " id " + crs[ i ].Id + " access " + crs[ i ].GetAccess() + "\n";
        }
    }
    cr.Say( SAY_NETMSG, msg );
}

void getAllPls( Critter& cr, int p1, int p2, int p3 )
{
    #ifdef ANYDATA_ONLINE
    if( IsAnyData( DATA_ALL_PLAYERS ) )
    {
        uint16[] ids;
        Critter @ cr1;
        GetAnyData( DATA_ALL_PLAYERS, ids );
        for( uint i = 0; i < ids.length(); i++ )
        {
            @cr1 = GetCritter( ids[ i ] );
            if( cr1 is null )
                continue;
            cr.Say( SAY_NETMSG, " i " + i + " id= " + ids[ i ] + " access " + cr1.GetAccess() );
        }
    }
    #endif
    #ifndef ANYDATA_ONLINE
    Critter@[] crs;
    GetAllPlayers( crs );
    for( uint i = 0; i < crs.length(); i++ )
    {
        if( crs[ i ] is null )
            continue;
        cr.Say( SAY_NETMSG, " i " + i + " id= " + crs[ i ].Id + " access " + crs[ i ].GetAccess() );
    }
    #endif
    /*
       string func = "general_unsafe@unsafe_show_flare";
       cr.RunClientScript("client_script@GetPlayersWorldRadius", cr.WorldX, cr.WorldY, 300, func, null);
     */
}


void openDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    item.LockerOpen();
}

void closeDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    item.LockerClose();
}

void BlockHex( Critter& cr, int p1, int p2, int p3 )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;
    map.BlockHex( cr.HexX + p1, cr.HexY + p2, p3 != 0 );
}

void UnblockHex( Critter& cr, int p1, int p2, int p3 )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;
    map.UnblockHex( cr.HexX + p1, cr.HexY + p2 );
}

void noopenDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ door = GetItem( uint( p1 ) );
    if( door is null )
        return;
    if( p2 == 0 )
        SETFLAG( door.LockerCondition, LOCKER_NOOPEN );
    else
        UNSETFLAG( door.LockerCondition, LOCKER_NOOPEN );
}

void clearDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ door = GetItem( uint( p1 ) );
    if( door is null )
        return;

    door.LockerClose();

    door.LockerCondition = 0;
    door.LockerId = 0;
    door.LockerComplexity = 0;
    door.Val0 = 0;
    door.Val1 = 0;
}

void di( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    DeleteItem( item );
}

void setScale( Critter& cr, int p1, int p2, int p3 )
{
    cr.StatBase[ ST_SCALE_FACTOR ] = p1;
}
// ID to knock by anubis
void knock( Critter& player, int id, int param1, int param2 )
{
    Critter@ cr = GetCritter( id );
    cr.Say( SAY_EMOTE_ON_HEAD, "теряет сознание" );
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 100, cr.HexX, cr.HexY );
}

import void ApplyGhoul( Critter& cr ) from "morphes";
// fast ghoulefication
void makeGhoul( Critter& cr, int p1, int p2, int p3 )
{
    Critter@ target = GetCritter( p1 != 0 ? p1 : cr.Id );
    if( @target == null )
    {
        cr.Say( SAY_NETMSG, "something wrong" );
        return;
    }
    ApplyGhoul( target );
}

void AddMine( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX + 1, cr.HexY + 1, PID_ACTIVE_MINE, 1 );
    item.SetScript( "_MineInit" );
}

void _MineInit( Item& item, bool firstTime )
{
    item.TrapValue = 150;
    SETFLAG( item.Flags, ITEM_TRAP );
    item.SetEvent( ITEM_EVENT_WALK, "explode@_MineWalk" );
    item.Update();
}
/*
   import void SkillUp(Critter& player, int skill) from "stdlib";

   void UpSkill(Critter& cr, int crId, int skill, int)
   {
        SkillUp(GetCritter(uint(crId)), skill);
   }*/

void liststats( Critter& cr, int p0, int p1, int )
{
    Critter @ target = GetCritter( def( p0, cr.Id ) );
    for( uint16 i = STAT_BEGIN; i < STAT_END; i++ )
    {
        cr.Say( SAY_NETMSG, "id " + target.Id + " stat " + i + " " + target.Stat[ i ] );
    }

    for( uint16 i = SKILL_BEGIN; i < SKILL_END; i++ )
    {
        cr.Say( SAY_NETMSG, "id " + target.Id + " skill " + i + " " + target.Skill[ i ] );
    }
}

void HideAllMaps( Critter& cr, int, int, int )
{
    Critter@[] crs;
    uint crLen = GetAllPlayers( crs );

    Location@[]  locations;
    uint len = GetAllLocations( 0, locations );

    for( uint i = 0; i < len; i++ )
    {
        Location@ loc = locations[ i ];
        if( loc is null )
            continue;

        if( loc.Visible )
        {
            loc.Visible = false;
            Log( "Скрыта локация " + loc.Id );
        }

        loc.GeckVisible = false;

        for( uint k = 0; k < crLen; k++ )
        {
            if( crs[ k ].UnsetKnownLoc( true, loc.Id ) )
                Log( "Стерта для " + crs[ k ].Id );
        }
    }
}

void GM_setcodedoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    setcodedoor( player, param0, param1, param2 );
}

void setcodedoor( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
//	item.SetScript("item@_InitCodeDoor");
	cr.Say( SAY_NETMSG, "Просто предупреждаю, что интерфейс электронного замка НЕ СПОСОБЕН принимать комбинации большие чем 65536, т.е. максимальное количество разрядов у нормального пароля равно 4!");
    item.Val0 = 4;
    item.Val1 = p1 + 1;
    item.Val4 = p3 != 0 ? p3 : Random( pow( 10, item.Val1 ), pow( 10, ( item.Val1 + 1 ) ) - 1 );
    cr.Say( SAY_NETMSG, "code " + item.Val4 );
    item.LockerComplexity = Random( 50, 200 );
    SETFLAG( item.LockerCondition, LOCKER_ELECTRO );
    item.Update();
}

void Flushblack( Critter& player, int p0, int p1, int p3, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( p0 );
    FlushScreen( cr, COLOR_BLACK, COLOR_BLACK, p1 );
}

void GiveItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    cr.AddItem( param1, 1 );
}

void GM_mobinit( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    cr.StatBase[ ST_TEAM_ID ] = 33;
    GM_MobInit( cr );
}

void GM_GetParam( Critter& player, int crId, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.Param[ param1 ] );
}

void GM_SetParam( Critter& player, int crId, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ParamBase[ param1 ] = param2;
        player.Say( SAY_NETMSG, "Done." );
    }
}

void GM_liststats( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter @ target = GetCritter( param0 );
    for( uint16 i = STAT_BEGIN; i < STAT_END; i++ )
    {
        player.Say( SAY_NETMSG, "id " + target.Id + " stat " + i + " " + target.Stat[ i ] );
    }

    for( uint16 i = SKILL_BEGIN; i < SKILL_END; i++ )
    {
        player.Say( SAY_NETMSG, "id " + target.Id + " skill " + i + " " + target.Skill[ i ] );
    }
}

void GM_openDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( uint( param0 ) );
    if( item is null )
        return;

    item.LockerOpen();
}

void GM_closeDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( uint( param0 ) );
    if( item is null )
        return;

    item.LockerClose();
}

void GM_noopenDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( uint( param0 ) );
    if( door is null )
        return;
    if( param1 == 0 )
        SETFLAG( door.LockerCondition, LOCKER_NOOPEN );
    else
        UNSETFLAG( door.LockerCondition, LOCKER_NOOPEN );
}

void GM_clearDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( uint( param0 ) );
    if( door is null )
        return;

    door.LockerClose();

    door.LockerCondition = 0;
    door.LockerId = 0;
    door.LockerComplexity = 0;
    door.Val0 = 0;
    door.Val1 = 0;
}

funcdef void GM_deleteCritterdef( Critter& critter );

void DeleteCritter_all( Critter& critter )
{
	DeleteNpc( critter );
}

void DeleteCritter_default( Critter& critter )
{
	if( critter.KindIndex != 0 )
		DeleteNpc( critter );
}

void DeleteCritter_deads( Critter& critter )
{
	if( critter.IsDead() )
		DeleteNpc( critter );
}

void GM_deleteCritter( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( param1 == 0 )
	{
		Critter@ critter = GetCritter( param0 );
		if( !valid( critter ) ) return;
		DeleteNpc( critter );
	}
	else 
	{
		GM_deleteCritterdef @delete = @DeleteCritter_default;
		if( @param3 !is null )
		{
			if( param3 == "all" )
				@delete = @DeleteCritter_all;
			else if( param3 == "dead" )
				@delete = @DeleteCritter_deads;
		}
		Critter@[] critters(0);
		Map@ map = player.GetMap();
		for( uint i = 0, iEnd = map.GetCrittersHex ( param1, param2, param0, FIND_ALL | FIND_ONLY_NPC, critters ); i < iEnd; i++ )
			if( @critters[i] !is null)
				delete( critters[i] );
	}
}

void GM_delItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( param1 == 0 )
	{
		Item@ item = player.GetMap().GetItem( param0 );
		if( !valid( item ) )
			return;
		DeleteItem( item );
	}
	else 
	{
		Item@[] items(0);
		Map@ map = player.GetMap();
		for( uint16 x = param1 - param0, xMax = param1 + param0; x < xMax; x++ )
			for( uint16 y = param2 - param0, yMax = param2 + param0; y < yMax; y++ )
				map.GetItems( x, y, items );
		DeleteItems( items );
	}
}

void GM_brokeItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = GetItem( param0 );
    if( !valid( item ) )
        return;
    item.Deterioration = param1;
    player.Say( SAY_NETMSG, "предмет " + item.Id + " сломан на " + param1 );
	item.Update();
}

void viewarcadepop( Critter& cr, int clear, int, int )
{
    GameVar@ firegeckoNow = GetGlobalVar( GVAR_firegecko_now );
    GameVar@ alienNow = GetGlobalVar( GVAR_alien_now );
    GameVar@ deathclawNow = GetGlobalVar( GVAR_deathclaw_now );
    GameVar@ flocentNow = GetGlobalVar( GVAR_floaterandcentaur_now );
    GameVar@ clawNow = GetGlobalVar( GVAR_claw_now );
    GameVar@ clawKidNow = GetGlobalVar( GVAR_clawkid_now );

    GameVar@ firegecko = GetGlobalVar( GVAR_firegecko_population );
    GameVar@ alien = GetGlobalVar( GVAR_alien_population );
    GameVar@ deathclaw = GetGlobalVar( GVAR_deathclaw_population );
    GameVar@ flocent = GetGlobalVar( GVAR_floaterandcentaur_population );

    if( clear > 0 )
    {
        firegeckoNow.opAssign( 0 );
        alienNow.opAssign( 0 );
        deathclawNow.opAssign( 0 );
        clawNow.opAssign( 0 );
        clawKidNow.opAssign( 0 );
        flocentNow.opAssign( 0 );
    }

    cr.Say( SAY_NETMSG, "firegecko : " + firegeckoNow.GetValue() + "\nalien : " + alienNow.GetValue() + "\ndeathclaw : " + deathclawNow.GetValue() + "\nclaw : " + clawNow.GetValue() + "\nclawkid :" + clawKidNow.GetValue() + "\nflocent : " + flocentNow.GetValue() );
    cr.Say( SAY_NETMSG, "\neggs\nfiregecko : " + firegecko.GetValue() + "\nalien : " + alien.GetValue() + "\ndeathclaw : " + deathclaw.GetValue() + "\nflocent : " + flocent.GetValue() );
}

void testcte( Critter& cr, int p0, int p1, int )
{
    for( uint8 i = 0; i <= p1; i++ )
    {
        cr.AddTimeEvent( "cte_test", p0 + Random( p0, p0 * 3 ), CTE_TEST, i );
    }
}

uint cte_test( Critter& cr, int identifier, uint& rate )
{
    cr.Say( SAY_NETMSG, "test cte " + rate );
    return 0;
}

void itemsetval( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
    switch( p1 )
    {
    case 0:
        item.Val0 = p3;
        break;
    case 1:
        item.Val1 = p3;
        break;
    case 3:
        item.Val2 = p3;
        break;
    case 4:
        item.Val4 = p3;
        break;
    case 5:
        item.Val5 = p3;
        break;
    case 6:
        item.Val6 = p3;
        break;
    case 7:
        item.Val7 = p3;
        break;
    // case 0 : item.Val8 = p3; break;
    default:
        break;
    }

}

void itemgetval( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
    string msg = "" + item.Val0 + "\n" +
                 item.Val1 + "\n" +
                 item.Val2 + "\n" +
                 item.Val3 + "\n" +
                 item.Val4 + "\n" +
                 item.Val5 + "\n" +
                 item.Val6 + "\n" +
                 item.Val7 + "\n" +
                 item.Val8 + "\n" +
                 item.Val9;

    cr.Say( SAY_NETMSG, msg );

}
/*
   void testidi(Critter& cr, int p0, int p1, int p3)
   {
        Item @ item = GetItem(p0);
        if(@item == null) return;
        if(p3 > 0)
        {
                cr.RunClientScript("client_main@set_indicator", item.Indicator-Random(0,4), 0, 0, "", null);
                return;
        }
        if(p1 == 0) cr.Say(SAY_EMOTE_ON_HEAD, ""+item.Indicator);
        else item.Indicator = p1;
   }*/

void GM_GiveAll( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    Item@[] items;
    if( param1 == 0 )
    {
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
        MoveItems( items, player );
        cr.Say( SAY_NETMSG, "Вещи переданы вам от криттера " + cr.Id );
    }
    else if( param1 == 1 )
    {
        player.GetItems( SLOT_INV, items );
        player.GetItems( SLOT_HAND1, items );
        player.GetItems( SLOT_HAND2, items );
        MoveItems( items, cr );
        cr.Say( SAY_NETMSG, "Вещи переданы криттеру " + player.Id );
    }
    else if( param1 == 2 )
    {
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
        DeleteItems( items );
        cr.Say( SAY_NETMSG, "Удалены вещи у криттера " + player.Id );
    }
}

void Clone( Critter& player, int param0, int param1, int param2 )
{
    Critter@ cr = GetCritter( param0 );
    if( !valid( cr ) )
        return;
    if( param1 == 1 )
    {
        for( uint i = 0; i <= 565; i++ )
        {
            cr.ParamBase[ i ] = player.ParamBase[ i ];
        }
        player.Say( SAY_NETMSG, "Вы присвоили свои параметры персонажу " + cr.Id );
    }
    else if( param1 == 0 )
    {
        for( uint i = 0; i <= 565; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
        player.Say( SAY_NETMSG, "Вам присвоенны параметры персонажа " + cr.Id );
    }
}

void GM_Clone( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( valid( cr ) )
    {
        for( uint i = 0; i <= 80; i++ )
        {
            player.StatBase[ i ] = cr.StatBase[ i ];
        }
        for( uint i = 200; i <= 207; i++ )
        {
            player.SkillBase[ i ] = cr.SkillBase[ i ];
        }
        for( uint i = 209; i <= 217; i++ )
        {
            player.SkillBase[ i ] = cr.SkillBase[ i ];
        }

        for( uint i = 260; i <= 278; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
        for( uint i = 300; i <= 439; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
        for( uint i = 470; i <= 476; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
        for( uint i = 480; i <= 498; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
        for( uint i = 550; i <= 565; i++ )
        {
            player.ParamBase[ i ] = cr.ParamBase[ i ];
        }
		player.ParamBase[ 208 ] = cr.Param[ 208 ];
        player.Say( SAY_NETMSG, "Вам присвоенны параметры персонажа " + cr.Id + ".");
    }
}

import void _TraderInit( Critter& trader, bool firstTime ) from "trader";

void GM_TraderInit( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( !valid( cr ) )
        return;
    _TraderInit( cr, true );
}

#define OUR_MAX_DISTANCE    ( 16 )
#define OUR_MAX_POWER       ( 50 )
#define OUR_MAX_LOOP_NUMBER ( 16 )
#define OUR_MAX_LOOP_DECAY  ( 3 )
#define OUR_LOOP_TIME_MUL  ( 250 )
void SetRad( Critter& player, int HexX, int HexY, int PID, string@ param_string, int[] @ param_array )
{
	Map@ map = player.GetMap();
	if( !valid( map ) ) 
	{
		player.Say( SAY_NETMSG, "На глобале нельзя!" );
		return;
	}
	if( ABS( player.HexX - HexX ) > OUR_MAX_DISTANCE ||
	    ABS( player.HexY - HexY ) > OUR_MAX_DISTANCE )
	{
		player.Say( SAY_NETMSG, "Предмет можно спаунить не дальше чем на " + OUR_MAX_DISTANCE + " гексов от себя!" );
		return;
	}
	map.SetLoopTime( 0, REAL_SECOND( 5 ) * OUR_LOOP_TIME_MUL ); //каждый тик происходит раз в 2 секунды
	Item@ item = map.AddItem( HexX, HexY, PID, 1 ); //добавляем наш "ключевой предмет" на наш гекс на карте
	item.Val1 = OUR_MAX_POWER;
	map.SetData( MAP_DATA_POWER, 0 ); //используем это поле как счётчик
	map.SetData( MAP_DATA_STATE_TURRETS_OFF, PID ); //используем это поле для хранения значения PID "радиоактивных предметов"
    map.SetEvent( MAP_EVENT_LOOP_0, "_RadiationLoop0" ); //включаем цикл
}

void _RadiationLoop0( Map& map )
{
	//Находим всех существ на карте
	Critter@[] critters;
	map.GetCritters( 0, FIND_ALL, critters );
	//Загружаем обратно наше значение PIDа "радиоактивных предметов"
	uint16 PID = map.GetData( MAP_DATA_STATE_TURRETS_OFF ); 
	//Находим все наши спецпредметы:
	Item@[] items;
	map.GetItems( PID, items );
	//Ядро функции:
	for( uint j = 0; j < critters.length(); j++ ) 
	{
		if( _CritCountItem( critters[j], PID_GEIGER_COUNTER ) == 0 ) continue; //Лишь посвящённые должны видеть это.
		string result = "";
		for( uint i = 0; i < items.length(); i++ )
		{ //Интенсивность радиации падает в зависимости от дистанции до криттера, на 1 за шаг
			if( !valid( items[i] ) ) continue;
			if( items[i].Val1 <= 0 ) 
			{
				DeleteItem( items[i] ); //Убираем этот "отработавший" источник.
				@items[i] = null;
				continue; //Предмет не может иметь отрицательный уровень радиации!
			}
			int distance = GetDistantion( critters[j].HexX, critters[j].HexY, items[i].HexX, items[i].HexY );
			int power = CLAMP( items[i].Val1 - distance, 0, OUR_MAX_POWER );
			if( power > 0 )
				result += "\nИсточник №" + items[i].Id + ": " + distance + " метров, " + power + " рад.";
			items[i].Val1 -= OUR_MAX_LOOP_DECAY;
		}
		critters[j].Say( SAY_NETMSG, "Дозиметр показывает:" + ( result == "" ? " тут безопасно!" : result ) );
	}
	//Увеличиваем счётчик повторов, что бы после OUR_MAX_LOOP_NUMBER выключить цикл.
	uint16 loop_number = map.GetData( MAP_DATA_POWER );
	if( loop_number >= OUR_MAX_LOOP_NUMBER ) 
	{
		map.SetData( MAP_DATA_POWER, 0 ); //обнуляем счётчик
		map.SetEvent( MAP_EVENT_LOOP_0, "" ); //выключаем после этой итерации
	}
	else
		map.SetData( MAP_DATA_POWER, loop_number + 1 ); //увеличиваем счётчик на 1
}

void setautodoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( param0 );
    if( door is null )
        return;
    uint16 x = 0;
    uint16 y = 0;
    Map@   map = door.GetMapPosition( x, y );
    uint16 x0 = x;
    uint16 y0 = y;
    for( uint8 i = 0; i < 6; i++ )
    {
        map.MoveHexByDir( x, y, i, 1 );
        if( param1 != 2 )
        {
			map.AddItem( x, y, PID_ROCK, 1 ); //новая строка!
            Item@ pedal = map.AddItem( x, y, PID_AUTODOOR, 1 );
            pedal.Val1 = door.Id;
            pedal.Val2 = param1;
        }
        else
        {
            Item@ pedal = map.GetItem( x, y, PID_AUTODOOR );
            if( valid( pedal ) )
                DeleteItem( pedal );
        }
        x = x0;
        y = y0;
    }
}

void TestJukebox( Critter& cr, int pid, int hx, int hy )
{
	Item@ item = @cr.GetMap().AddItem( hx, hy, pid, 1 );
	if( @item !is null)
		item.SetScript( "jukebox@_JukeboxInit" );
}

void setjukebox( Critter& cr, int id, int, int )
{
    Item @ item = GetItem( id );
    if( @item == null || item.GetType() != ITEM_TYPE_CONTAINER )
        return;
    item.SetScript( "jukebox@_JukeboxInit" );
}

void GM_GetItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = GetItem( param0 );
    if( !valid( item ) )
        return;
    MoveItem( item, 0, player );
}
/*	deprecated
   import void TransitCritterToCell(Critter& cr, uint16 itemId) from "world";

   void transit(Critter& cr, int dir, int, int)
   {
        TransitCritterToCell(cr, dir);
   }
 */
void chagecell( Critter& cr, int x, int y, int )
{
    cr.StatBase[ ST_CELL_X ] = x;
    cr.StatBase[ ST_CELL_Y ] = y;
}

import void arcadehiveinsert( Critter& cr, uint16 x, uint16 y, uint8 type ) from "arcade_menu";
import void arcadehivelist( Critter& cr ) from "arcade_menu";
import void arcadehiveclear( Critter& cr ) from "arcade_menu";
import void arcadehivedelone( Critter& cr, uint8 index ) from "arcade_menu";

void arcadehiveadd( Critter& cr, int x, int y, int type )
{
    arcadehiveinsert( cr, x, y, type );
}

void arcadehivelist( Critter& cr, int, int, int )
{
    arcadehivelist( cr );
}

void arcadehiveclear( Critter& cr, int, int, int )
{
    arcadehiveclear( cr );
}

void arcadehivedel( Critter& cr, int index, int, int )
{
    arcadehivedelone( cr, index );
}

import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

void testbox( Critter& cr, int p0, int, int )
{
    uint8 flags = 0;
    SETFLAG( flags, INPUTBOX_CLOSE_ON_ENTER );   // close on enter
    ShowInputBoxScreen( cr, "debug@unsafe_test_inputbox#mywindow", p0, flags );
}

void unsafe_test_inputbox( Critter& cr, int skill, int p1, int p2, string@ message, int[] @ p4 )
{
    cr.Say( SAY_NORM, "message " + message );
}

void setworld( Critter& cr, int id, int x, int y )
{
    Critter @ target = GetCritter( id > 0 ? id : cr.Id );
    if( target is null )
        return;

    target.SetWorldPos( x, y );
}

void additemsrndpic( Critter& cr, int id, int x, int y )
{
    Map @ map = cr.GetMap();
    if( map is null )
    {
        cr.Say( SAY_NETMSG, "map" );
        return;
    }

    for( uint8 i = 0; i < x; ++i )
    {
        Item @ item = map.AddItem( cr.HexX + ( Random( -10, 10 ) ), cr.HexY + ( Random( -10, 10 ) ), 2004, 1 );
        if( item is null )
            continue;
        /*
           string = "";
           brl1000.frm
         * brl2000.frm
         * tirs002.frm
         * weed05.frm
         * weed08.frm
         * boxes1.frm
         * boxes2.frm
         * boxes3.frm
         * boxes4.frm
         * car2.frm
         * car4.frm
         * chair1.frm
         * chair3.frm
         * njunk5.frm
         * njunk6.frm
         * trash3.frm
         * t
         */

        uint hash = GetStrHash( "art\\scenery\\corpse1.png" );


        item.SetMapPic( hash );

        cr.Say( SAY_NETMSG, "add " + hash );
    }

}

void delsatmobs( Critter& cr, int id, int x, int y )
{
    for( uint8 i = id; i < x; ++i )
    {
        Location @ loc = GetLocationByPid( i, 0 );
        if( loc is null )
            continue;

        Map @ map = loc.GetMapByIndex( 0 );
        if( map is null )
            continue;

        Critter@[] crs;
        map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, crs );
        Log( "delete len " + crs.length() );
        for( uint16 ii = 0, jj = crs.length(); ii < jj; ++ii )
        {
            if( crs[ ii ] is null )
                continue;

            Log( "delete " + ii );
            DeleteNpc( crs[ ii ] );
        }
    }
}

void itemrndpic( Critter& cr, int id, int x, int y )
{
    Item @ item = GetItem( id );
    if( item is null )
        return;

    uint hash = GetStrHash( "art\\scenery\\corpse1.png" );
    item.SetMapPic( hash );
}

void addplant( Critter& cr, int id, int x, int y )
{
    Item @ item = cr.AddItem( id, 1 );
    if( item is null )
        return;

    item.Val3 = x;
    item.SetScript( "plant@_InitPlant" );

}

void evilplant( Critter& cr, int id, int, int )
{
    cr.GetMap().AddNpc( id, cr.HexX - 3, cr.HexY - 3, 0, null, null, "mob@_MobInit" );

}

void droptime( Critter& cr, int id, int, int )
{
    for( uint i = TIMEOUT_BEGIN; i < TIMEOUT_END; i++ )
    {
        cr.TimeoutBase[ i ] = 0;
    }
}

void addtime( Critter& cr, int id, int, int )
{
    uint time = cr.TimeoutBase[ TO_REPLICATION ];
    if( time > __FullSecond )
    {
        time += REAL_SECOND( 10 );
    }
    else
    {
        time = __FullSecond + REAL_MINUTE( 1 );
    }

    cr.TimeoutBase[ TO_REPLICATION ] =  time;
}
import uint GetTile( Map& map, uint16 hexX, uint16 hexY, uint8 layer ) from "qmap";
void        gettile( Critter& cr, int id, int, int )
{
    Map @ map = cr.GetMap();
    if( map is null )
        return;
    // for(uint8 i = 0; i < 5; ++i){
    uint hash = map.GetTile( THX( cr.HexX ), THX( cr.HexY ) ); // GetTile(map, THX(cr.HexX), THX(cr.HexY), i);
    cr.Say( SAY_NETMSG, "tile hash\n* " + hash );
    // }
}

void gettiles( Critter& cr, int id, int, int )
{
    uint hash0 = GetStrHash( "art/tiles/road02.frm" ),
         hash1 = GetStrHash( "road02.frm" );
    cr.Say( SAY_NETMSG, "tile hash\n* " + hash0 + "\ntile hash\n* " + hash1 );
}

void varset( Critter& cr, int id, int x, int )
{
    GameVar@ isStored = GetLocalVar( LIVAR_motel_isStored, id );

    int      val = isStored.GetValue();

    cr.Say( SAY_NETMSG, "" + val );

    if( x > 0 )
    {
        uint8 temp = Random( 1, 100 );

        isStored.opAssign( temp );
    }
} /*

     void testgetdur(Critter& cr, int id, int, int){
         Item @ item = GetItem(id);
         if(item is null) return;

         cr.Say(SAY_NETMSG, "dur "+item.GetDurability());
     }

     void testsetdur(Critter& cr, int id, int val, int){
         Item @ item = GetItem(id);
         if(item is null) return;

         item.SetDurability(val);
         cr.Say(SAY_NETMSG, "dur "+item.GetDurability());
     }*/

import void ActivateMobScript( Map& map ) from "mob"; // Export

void testmob( Critter& cr, int id, int val, int )
{
    ActivateMobScript( cr.GetMap() );
}

#define SAT_ENERGY_MAX    ( 28 )

void spawnsateng( Critter& cr, int id, int val, int )
{
    Location @ loc;
    Item @ item;
    for( uint8 i = 13; i < 25; ++i )
    {
        @loc = GetLocation( i );
        if( loc is null )
            continue;

        Map @ map = loc.GetMapByIndex( 0 );
        if( map is null )
            continue;

        Item@[] conts;
        map.GetItemsByType( ITEM_TYPE_CONTAINER, conts );
        // GetItemsByType (int type, Item@[]@+ items)
        uint16 len = conts.length();

        // uint8 count = 2
        for( uint16 ii = 0; ii < 2; ++ii )
        {

            @item = conts[ Random( 0, len - 1 ) ];

            if( !(item is null) )
            {
                item.AddItem( PID_MICRO_FUSION_CELL, Random( 1, 3 ), 0 );
                Log( "SPAWN " + item.HexX + ":" + item.HexY );
            }
        }
    }
}

void testscreen(Critter& cr, int, int, int){
	cr.ShowScreen( SCREEN_DIALOGBOX, 2, "answer_test" );
        cr.Say( SAY_DIALOGBOX_TEXT, "Вас устраивает ваша зарплата?" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Да" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Нет" );
}

void answer_test( Critter& cr, uint answerI, string& answerS )
{
	string msg = "";
	if(answerI > 0){
		msg = "Правда чтоли?";
	}else{
		msg = "ВРешь!";
	}

	cr.Say(SAY_NETMSG, msg);
}

void test_npc(Critter& cr, int, int, int){
    cr.GetMap().AddNpc( 5, cr.HexX - 3, cr.HexY - 3, 0, null, null, "map_start@_InitAdventureGM" );
}


