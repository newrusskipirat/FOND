                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name);                           
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
}                                                  

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}                                       
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}                            

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	}                      
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}                                                                                                                                                                                      

string[]__critterHistoryInfo;                                                                                                                                                                                                                                                                                                                                                                                                                                           

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

class Sprite
{
	Sprite()
	{
		Id=0;
		Hash=0;
		Width=0;
		Height=0;
		FrmCount=0;
		DrawFrame=-1;
	}
	
	void Load(string&name,int path)
	{
		if(name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		RefreshData();
	}
	
	void Load(uint nameHash,uint8 dir)
	{
		Id=LoadSprite(nameHash,dir);
		Hash=nameHash;
		RefreshData();
	}
	
	void LoadByIni(string&iniKey,int path)
	{
		string@name=GetIfaceIniStr(iniKey);
		if(@name!=null&&name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		RefreshData();
	}
	
	void Draw(int x,int y)
	{
		if(Id!=0)
		DrawSprite(Id,DrawFrame,x,y,0);
	}
	
	void Draw(int x,int y,uint8 sprIndex)
	{
		if(Id!=0)
		DrawSprite(Id,DrawFrame,x,y,0);
	}
	
	uint GetHashName()
	{
		return Hash;
	}
	
	private void RefreshData()
	{
		if(Id!=0)
		{
			Width=GetSpriteWidth(Id,0);
			Height=GetSpriteHeight(Id,0);
			FrmCount=GetSpriteCount(Id);
			DrawFrame=-1;
		}
		else
		{
			Width=0;
			Height=0;
			FrmCount=0;
			DrawFrame=-1;
		}
	}
	
	uint Id;
	uint Hash;
	int Width;
	int Height;
	uint FrmCount;
	int DrawFrame;
}   

import int GUI_GetActiveMainScreen()from"client_gui";
import int GUI_GetActiveScreen()from"client_gui";
import int GetIniValue(string&iniKey,int defaultValue)from"ini_parser";
import int[]@GetIniValues2(string&iniKey,int[]@defaultValues)from"ini_parser";  

Sprite TabPic;
int[]Position;
int StepX;
int StepY;
bool LevelUp;
int CurTab;

bool IsHeavyDmg;
bool IsBullOver;
bool IsBleed;
bool IsBldTox;

void InitChosenTabs()
{
	TabPic.LoadByIni("ChosenTabPic",(4));
	Position=GetIniValues2("ChosenTab",null);
	StepX=GetIniValue("ChosenTabStepX",0);
	StepY=GetIniValue("ChosenTabStepY",5);
	if(StepX!=0)
	StepX+=TabPic.Width;
	if(StepY!=0)
	StepY+=TabPic.Height;
	LevelUp=false;
	CurTab=0;
	
	IsHeavyDmg=false;
	IsBullOver=false;
	IsBleed=false;
	IsBldTox=false;
}

void SetChosenTabLevelUp(bool enable)
{
	LevelUp=enable;
}

void SetChosenTabHeavyDmg(bool enable)
{
	IsHeavyDmg=enable;
}

void SetChosenTabBullOver(bool enable)
{
	IsBullOver=enable;
}

void SetChosenTabBleed(bool enable)
{
	IsBleed=enable;
}

void SetChosenTabBldTox(bool enable)
{
	IsBldTox=enable;
} 

void DrawChosenTabs()
{
	if(GUI_GetActiveMainScreen()!=(5))
	return;
	
	CritterCl@chosen=GetChosen();
	if(not(@chosen!=null))
	return;
	
	if(LevelUp&&(GUI_GetActiveMainScreen()!=(5)||
	GUI_GetActiveScreen()==(13)||GUI_GetActiveScreen()==(32)))
	LevelUp=false;
	
	CurTab=0;
	
	if(chosen.Mode[(510)]!=0)
	DrawTab(GetMsgStr((3),(441)),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))));
	
	if(chosen.Mode[(540)]>1)
	DrawTab(GetMsgStr((3),(439)),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))));
	
	if(LevelUp)
	DrawTab(GetMsgStr((3),(442)),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))));
	
	if(chosen.IsOverweight())
	DrawTab(GetMsgStr((3),(440)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	
	if((chosen.Damage[(500)]!=0)||(chosen.Damage[(501)]!=0))
	DrawTab(GetMsgStr((3),(443)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));   
	
	if(chosen.IsInjured())
	DrawTab(GetMsgStr((3),(445)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	
	if(chosen.IsAddicted())
	DrawTab(GetMsgStr((3),(446)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	
	if(chosen.Timeout[(239)]>0)
	DrawTab("Переход : VALUE",chosen.Timeout[(239)],((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	
	if(chosen.Timeout[(237)]>0)
	DrawTab("Смерть : VALUE",chosen.Timeout[(237)],((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	
	if(IsTurnBased()&&chosen.IsTurnBasedTurn())
	DrawTab(GetMsgStr((3),(449)),GetTurnBasedTime()/1000,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))));
	
	if(IsTurnBased()&&!chosen.IsTurnBasedTurn())
	DrawTab(GetMsgStr((3),(450)),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xAA)&0xFF)<<8)|((0)&0xFF)))));
	
	if((((chosen.StatBase[(146)])&((0x010)))!=0))
	DrawTab(GetMsgStr((3),(451)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	if((((chosen.StatBase[(146)])&((0x040)))!=0))
	DrawTab(GetMsgStr((3),(452)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF))))); 
	
	if(chosen.StatBase[(149)]>0)
	DrawTab(GetMsgStr((3),(453)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));
	if((((chosen.StatBase[(146)])&((0x008)))!=0))
	DrawTab(GetMsgStr((3),(454)),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))));  
	
	uint8 hunger=chosen.StatBase[(128)];
	uint8 thrist=chosen.StatBase[(127)];
	uint8 dyspnea=chosen.StatBase[(126)];
	
	if(hunger<=90)
	{
		string msg="Голод";
		
		if(hunger>50&&hunger<=75){
			msg="Голод";
		}else if(hunger>30&&hunger<=50){
			msg="Сильный Голод";
		}else if(hunger>10&&hunger<=30){
			msg="Истощение";
		}else if(hunger<=10){
			msg="Сильное Истощение";
		}
		
		uint color=__GetGradient(((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),hunger);
		
		DrawTab(msg,color);
	}
	
	if(thrist<=90)
	{
		string msg="Жажда";
		
		if(thrist>50&&thrist<=90){
			msg="Жажда";
		}else if(thrist>30&&thrist<=50){
			msg="Сильная Жажда";
		}else if(thrist>10&&thrist<=30){
			msg="Обезвоживаение";
		}else if(thrist<=10){
			msg="Сил.Обезвоживаение";
		}
		
		uint color=__GetGradient(((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),thrist);
		
		DrawTab(msg,color);
	}
	
	if(dyspnea<=90)
	{
		string msg="Удушье";
		
		if(dyspnea>50&&dyspnea<=75){
			msg="Нехватка Воздуха";
		}else if(dyspnea>30&&dyspnea<=50){
			msg="Сильная Нехватка";
		}else if(dyspnea>10&&dyspnea<=30){
			msg="Удушье";
		}else if(dyspnea<=10){
			msg="Сильное Удушье";
		}
		
		uint color=__GetGradient(((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0xC8)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0xAA)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),dyspnea);
		DrawTab(msg,color);
	}
}

void DrawTab(string@text,uint color)
{
	bool offsetY=false;
	
	if(Position[0]+StepX*(CurTab+1)>__ScreenWidth)
	{
		offsetY=true;
	}
	
	uint8 tempTab=CurTab;
	
	if(offsetY)
	{
		tempTab-=__ScreenWidth/(127);
	}
	
	TabPic.Draw(Position[0]+tempTab*StepX,Position[1]+tempTab*StepY+(offsetY?25:0));
	DrawText(text,Position[0]+tempTab*StepX,Position[1]+tempTab*StepY+(offsetY?25:0),TabPic.Width,TabPic.Height,color,(5),(0x000C));
	CurTab++;
}

void DrawTab(string@text,int value,uint color)
{
	
	bool offsetY=false;
	
	if(Position[0]+StepX*(CurTab+1)>__ScreenWidth)
	{
		offsetY=true;
	}
	
	uint8 tempTab=CurTab;
	
	if(offsetY)
	{
		tempTab-=__ScreenWidth/(127);
	}
	
	uint16 time=value/__TimeMultiplier+1;
	
	text=ReplaceText(text,"VALUE",time);
	TabPic.Draw(Position[0]+tempTab*StepX,Position[1]+tempTab*StepY+(offsetY?25:0));
	DrawText(text,Position[0]+tempTab*StepX,Position[1]+tempTab*StepY+(offsetY?25:0),TabPic.Width,TabPic.Height,color,(5),(0x000C));
	CurTab++;
}
