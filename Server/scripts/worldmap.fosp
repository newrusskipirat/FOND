                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                                                                                                                                                                

import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";                                                            

uint[][]PositionDirs=
{
	{0},
	
	{1,4,3,2,1,0,5,2,3,4,5,0,1},
	{1,5,0,1,2,3,4,1,0,5,4,3,2},
	{1,4,2},
	{1,5,1},
	{2,1,2,4,5},
	{2,1,2,4,5}
};                                                                                                                                                                                                                        

class CCheck
{
	uint Type;
	uint Index;
	uint8 Operator;
	int Value;
	
	CCheck()
	{
		Type=0;
		Index=0;
		Operator=0;
		Value=0;
	}
	
	void Set(uint type,uint index,uint8 operator,int value)
	{
		Type=type;
		Index=index;
		Operator=operator;
		Value=value;
	}
}

class CEncounterObject
{
	uint ObjectType;
	uint16 Pid;
	uint DialogId;
	string ScriptName;
	uint DistanceLength;
	CEncounterObject@[]Childs;
	CCheck[]Checks;
	
	uint RatioValue;
	bool IsDead;
	
	uint Minimum;
	uint Maximum;
	uint InvSlot;
	
	CEncounterObject()
	{
		ObjectType=0;
		Pid=0;
		DialogId=0;
		ScriptName="";
		DistanceLength=0;
		RatioValue=0;
		IsDead=false;
		Minimum=0;
		Maximum=0;
		InvSlot=0;
	}
	
	CEncounterObject@NewCheck(uint type,uint index,uint8 operator,int value)
	{
		Checks.grow(1);
		Checks.last().Set(type,index,operator,value);
		return this;
	}
	
	CEncounterObject@Dialog(uint dialog)
	{
		DialogId=dialog;
		return this;
	}
	CEncounterObject@Script(string&script)
	{
		ScriptName=script;
		return this;
	}
	CEncounterObject@Distance(uint distance)
	{
		DistanceLength=distance;
		return this;
	}
	CEncounterObject@CheckRandom(int value)
	{
		NewCheck((0),0,0,value);
		return this;
	}
	CEncounterObject@CheckParam(uint index,uint8 operator,int value)
	{
		NewCheck((1),index,operator,value);
		return this;
	}
	CEncounterObject@CheckParamAny(uint index,uint8 operator,int value)
	{
		NewCheck((6),index,operator,value);
		return this;
	}
	CEncounterObject@CheckLVar(uint index,uint8 operator,int value)
	{
		NewCheck((2),index,operator,value);
		return this;
	}
	CEncounterObject@CheckLVarAny(uint index,uint8 operator,int value)
	{
		NewCheck((5),index,operator,value);
		return this;
	}
	CEncounterObject@CheckGVar(uint index,uint8 operator,int value)
	{
		NewCheck((3),index,operator,value);
		return this;
	}
	CEncounterObject@CheckHour(uint8 operator,int value)
	{
		NewCheck((4),0,operator,value);
		return this;
	}
	CEncounterObject@Ratio(uint ratio)
	{
		RatioValue=ratio;
		return this;
	}
	CEncounterObject@Dead(bool dead)
	{
		IsDead=dead;
		return this;
	}
	CEncounterObject@Slot(uint slot)
	{
		InvSlot=slot;
		return this;
	}
	
	CEncounterObject@AddItem(uint16 pid,uint min,uint max,uint slot)
	{
		CEncounterObject new_child;
		Childs.insertLast(@new_child);
		new_child.Pid=pid;
		new_child.Minimum=min;
		new_child.Maximum=max;
		new_child.InvSlot=slot;
		return this;
	}
}

class CEncounterGroup
{
	uint TeamNum;
	uint Position;
	uint Spacing;
	uint Distance;
	CEncounterObject[]Objects;
	
	CEncounterGroup()
	{
		TeamNum=0;
		Position=0;
		Spacing=0;
		Distance=0;
	}
	
	CEncounterObject@NewObject()
	{
		Objects.grow(1);
		return Objects.last();
	}
	
	CEncounterObject@AddCritter(uint16 pid)
	{
		CEncounterObject@obj=NewObject();
		obj.ObjectType=(1);
		obj.Pid=pid;
		return obj;
	}
	
	CEncounterObject@AddItem(uint16 pid)
	{
		CEncounterObject@obj=NewObject();
		obj.ObjectType=(2);
		obj.Pid=pid;
		return obj;
	}
}

class CEncounter
{
	uint Chance;
	uint StrNum;
	uint16 LocPid;
	bool IsSpecial;
	uint[]Groups;
	uint[]RatioMin;
	uint[]RatioMax;
	uint[]Actions;
	CCheck[]Checks;
	
	CEncounter()
	{
		Chance=0;
		StrNum=0;
		LocPid=0;
		IsSpecial=false;
	}
	
	CEncounter@AddGroup(uint group,uint ratioMin,uint ratioMax)
	{
		Groups.grow(1);
		RatioMin.grow(1);
		RatioMax.grow(1);
		Groups.last()=group;
		RatioMin.last()=ratioMin;
		RatioMax.last()=ratioMax;
		return this;
	}
	
	CEncounter@Fighting(uint fromGroup,uint toGroup)
	{
		Actions.insertLast(fromGroup);
		Actions.insertLast(toGroup);
		Actions.insertLast((1));
		return this;
	}
	
	CEncounter@NewCheck(uint type,uint index,uint8 operator,int value)
	{
		Checks.grow(1);
		Checks.last().Set(type,index,operator,value);
		return this;
	}
	
	CEncounter@LocationPid(uint16 locationPid)
	{
		LocPid=locationPid;
		return this;
	}
	CEncounter@Special(bool special)
	{
		IsSpecial=special;
		return this;
	}
	CEncounter@CheckRandom(int value)
	{
		NewCheck((0),0,0,value);
		return this;
	}
	CEncounter@CheckParam(uint index,uint8 operator,int value)
	{
		NewCheck((1),index,operator,value);
		return this;
	}
	CEncounter@CheckParamAny(uint index,uint8 operator,int value)
	{
		NewCheck((6),index,operator,value);
		return this;
	}
	CEncounter@CheckLVar(uint index,uint8 operator,int value)
	{
		NewCheck((2),index,operator,value);
		return this;
	}
	CEncounter@CheckLVarAny(uint index,uint8 operator,int value)
	{
		NewCheck((5),index,operator,value);
		return this;
	}
	CEncounter@CheckGVar(uint index,uint8 operator,int value)
	{
		NewCheck((3),index,operator,value);
		return this;
	}
	CEncounter@CheckHour(uint8 operator,int value)
	{
		NewCheck((4),0,operator,value);
		return this;
	}
	CEncounter@AssignLVar(uint index,uint8 operator,int value)
	{
		NewCheck((10),index,operator,value);
		return this;
	}
}

class CEncounterTable
{
	uint16[]LocationPids;
	CEncounter[]Encounters;
	
	void AddLocationPid(uint16 locationPid)
	{
		LocationPids.insertLast(locationPid);
	}
	
	CEncounter@AddEncounter(uint chance,uint strNum)
	{
		Encounters.grow(1);
		Encounters.last().Chance=chance;
		Encounters.last().StrNum=strNum;
		return@Encounters.last();
	}
}

class CZone
{
	int Difficulty;
	uint Terrain;
	uint Fill;
	uint MorningChance;
	uint AfternoonChance;
	uint NightChance;
	CEncounterTable@Table;
	
	CZone()
	{
		Difficulty=0;
		Terrain=0;
		Fill=0;
		MorningChance=0;
		AfternoonChance=0;
		NightChance=0;
		@Table=null;
	}
}

CEncounterGroup[]EncounterGroups((114));
CEncounterTable[]EncounterTables((96));
CZone[]Worldmap((7)*(12));    

void SetZone(uint zx,uint zy,uint table,int difficulty,uint terrain,uint fill,uint morningChance,uint afternoonChance,uint nightChance)
{
	CZone@zone=Worldmap[zy*(7)+zx];
	@zone.Table=EncounterTables[table];
	zone.Difficulty=difficulty;
	zone.Terrain=terrain;
	zone.Fill=fill;
	zone.MorningChance=morningChance;
	zone.AfternoonChance=afternoonChance;
	zone.NightChance=nightChance;
}

void SetZone(uint zx,uint zy,uint table,int difficulty,uint terrain,uint fill,uint chance)
{
	SetZone(zx,zy,table,difficulty,terrain,fill,chance,chance,chance);
}    

void AddTableToAllTables(CEncounterTable&globalTable)
{
	for(uint i=0;i<(96);i++)
	{
		CEncounterTable@table=EncounterTables[i];
		
		for(uint j=0;j<globalTable.LocationPids.length();j++)
		{
			table.LocationPids.grow(1);
			table.LocationPids.last()=globalTable.LocationPids[j];
		}
		
		for(uint j=0;j<globalTable.Encounters.length();j++)
		{
			table.Encounters.grow(1);
			table.Encounters.last()=globalTable.Encounters[j];
		}
	}
}    

bool CheckCompare(int val1,uint8 operator,int val2)
{
	if(operator==62)
	return val1>val2;
	if(operator==60)
	return val1<val2;
	if(operator==61)
	return val1==val2;
	Log("Unknown operator.");
	return false;
}

void CheckAssignVar(GameVar&val1,uint8 operator,int val2)
{
	if(operator==61)
	val1=val2;
	else if(operator==43)
	val1+=val2;
	else if(operator==45)
	val1-=val2;
	else if(operator==42)
	val1*=val2;
	else if(operator==47)
	val1/=val2;
	else
	Log("Unknown operator.");
}

bool CheckChecks(CCheck[]&checks,Critter@[]&critters)
{
	for(int i=0,j=checks.length();i<j;i++)
	{
		CCheck@check=checks[i];
		switch(check.Type)
		{
			case(0):
			if(Random(1,100)>check.Value)
			return false;
			break;
			case(4):
			if(not CheckCompare(__Hour,check.Operator,check.Value))
			return false;
			break;
			case(1):
			for(uint i=0,j=critters.length();i<j;i++)
			if(not CheckCompare(critters[i].Param[check.Index],check.Operator,check.Value))
			return false;
			break;
			case(2):
			
			for(uint i=0,j=critters.length();i<j;i++)
			{
				GameVar@lvar=GetLocalVar(check.Index,critters[i].Id);
				if(not(@lvar!=null))
				{
					
					return false;
				}
				
				if(not CheckCompare(lvar.GetValue(),check.Operator,check.Value))
				return false;
			}
			break;
			case(3):
			{
				GameVar@gvar=GetGlobalVar(check.Index);
				if(not(@gvar!=null))
				{
					
					return false;
				}
				if(not CheckCompare(gvar.GetValue(),check.Operator,check.Value))
				return false;
			}
			break;
			default:
			continue;
		}
	}
	return true;
}

void AssignChecks(CCheck[]&checks,Critter@[]&critters)
{
	for(int i=0,j=checks.length();i<j;i++)
	{
		CCheck@check=checks[i];
		if(check.Type==(10))
		{
			for(uint i=0,j=critters.length();i<j;i++)
			{
				GameVar@lvar=GetLocalVar(check.Index,critters[i].Id);
				CheckAssignVar(lvar,check.Operator,check.Value);
			}
		}
	}
}     

class CFoundedEncounter
{
	uint Index;
	uint16[]LocationPids;
	CEncounter@Encounter;
	bool IsGenerated;
	uint FullSecond;
	uint PositionX;
	uint PositionY;
	uint OwnerId;
	bool OwnerGroup;
	bool TurnBased;
	uint LocationId;
	uint16 StartHexX;
	uint16 StartHexY;
	bool[]DirBusy;
	uint AskChance;
	
	CFoundedEncounter()
	{
		Index=0;
		@Encounter=null;
		IsGenerated=false;
		FullSecond=0;
		PositionX=0;
		PositionY=0;
		OwnerId=0;
		OwnerGroup=false;
		TurnBased=false;
		LocationId=0;
		StartHexX=0;
		StartHexY=0;
		DirBusy.resize(6);
	}
}

CFoundedEncounter[]FoundedEncounters(1000);
uint FoundedEncountersLastIndex=0;

CFoundedEncounter@CreateFoundedEncounter(uint x,uint y,CEncounter@encounter,uint16[]&locationPids,uint ownerId,bool ownerGroup)
{
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==0)
		{
			FoundedEncountersLastIndex++;
			ge.Index=FoundedEncountersLastIndex;
			ge.LocationPids=locationPids;
			@ge.Encounter=encounter;
			ge.IsGenerated=false;
			ge.FullSecond=__FullSecond;
			ge.PositionX=x;
			ge.PositionY=y;
			ge.OwnerId=ownerId;
			ge.OwnerGroup=ownerGroup;
			ge.LocationId=0;
			for(uint k=0;k<6;k++)
			ge.DirBusy[k]=false;
			return ge;
		}
	} 
	
	FoundedEncounters.resize(FoundedEncounters.length()*2);
	return CreateFoundedEncounter(x,y,encounter,locationPids,ownerId,ownerGroup);
}

CFoundedEncounter@GetFoundedEncounter(uint index)
{
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==index)
		return ge;
	}
	return null;
}

bool CheckFoundedEncounter(uint index)
{
	return(GetFoundedEncounter(index)!is null);
}

CFoundedEncounter@GetNearFoundedEncounter(Critter@[]@group,uint x,uint y,uint radius)
{
	int combatMode=group[0].Mode[(516)];
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==0)
		continue; 
		
		if(__FullSecond-ge.FullSecond<(((10)*__TimeMultiplier*3600))&&ge.IsGenerated&&
		(not(@ge.Encounter!=null)||(not ge.Encounter.IsSpecial&&CheckChecks(ge.Encounter.Checks,group)))&&
		
		(ge.PositionX/10==x/10&&ge.PositionY/10==y/10)&&
		group[0].Id!=ge.OwnerId&&
		(@GetLocation(ge.LocationId)!=null))
		{
			return ge;
		}
	}
	return null;
}

uint GetFreeDir(bool[]&dirBysy)
{
	
	uint dir=Random(0,5);
	if(not dirBysy[dir])
	{
		dirBysy[dir]=true;
		return dir;
	} 
	
	for(uint i=0;i<6;i++)
	{
		if(not dirBysy[i])
		{
			dirBysy[i]=true;
			return i;
		}
	} 
	
	return Random(0,5);
}

void RotatePosition(uint toDir,uint[]&positionsDirs)
{
	for(uint i=1,j=positionsDirs.length();i<j;i++)
	{
		positionsDirs[i]+=toDir;
		if(positionsDirs[i]>5)
		positionsDirs[i]-=6;
	}
}

void MovePositionPoint(Map&map,uint16&pointX,uint16&pointY,uint[]&positionDirs,uint pathIndex,uint count,uint spacing)
{
	uint steps=positionDirs[0];
	uint pathLen=(positionDirs.length()-1)/2;
	count*=steps;
	count%=pathLen;
	if(steps>1)
	{
		for(uint i=0;i<spacing;i++)
		{
			for(uint j=0;j<steps;j++)
			{
				uint dir=positionDirs[1+pathLen*pathIndex+count+j];
				map.MoveHexByDir(pointX,pointY,dir,1);
			}
		}
	}
	else
	{
		uint dir=positionDirs[1+pathLen*pathIndex+count];
		map.MoveHexByDir(pointX,pointY,dir,spacing);
	}
}

void ParseEncounterObject(CEncounterObject@obj,Map@map,uint16 posX,uint16 posY,uint8 reversDir,Critter@[]&crittersGrouop,uint teamId)
{
	if(obj.ObjectType==(1))
	{
		if(not map.IsHexPassed(posX,posY))
		return;
		
		int[]items;
		if(obj.Childs.length()>0)
		{
			for(uint i=0,j=obj.Childs.length();i<j;i++)
			{
				CEncounterObject@child=obj.Childs[i];
				uint count=Random(child.Minimum,child.Maximum);
				if(count>0)
				{
					items.insertLast(child.Pid);
					items.insertLast(count);
					items.insertLast(child.InvSlot);
				}
			}
		}
		
		int[]params={(104),obj.DialogId,(107),(1),(106),teamId,(84),-1};
		Critter@npc=map.AddNpc(obj.Pid,posX,posY,reversDir,params,items,obj.ScriptName);
		if(not(@npc!=null))
		return;
		
		if(obj.IsDead)
		{
			npc.ToDead(Random(0,1)==0?(102):(103),null);
		}
		else
		{
			crittersGrouop.insertLast(@npc);
		}
	}
	else if(obj.ObjectType==(2))
	{
		Item@item=map.AddItem(posX,posY,obj.Pid,1);
		if(not(@item!=null))
		return;
		
		if(obj.Childs.length()>0&&item.GetType()==(8))
		{
			for(uint i=0,j=obj.Childs.length();i<j;i++)
			{
				CEncounterObject@child=obj.Childs[i];
				uint count=Random(child.Minimum,child.Maximum);
				if(count>0)
				item.AddItem(child.Pid,count,0);
			}
		}
	}
	else
	{
		Log("Unknown object type<"+obj.ObjectType+">.");
	}
}

void ActionFighting(Critter@[]&npcL,Critter@[]&npcR)
{
	for(int i=0,j=npcL.length();i<j;i++)
	{
		Critter@nl=npcL[i];
		bool nlIsNpc=nl.IsNpc();
		for(int k=0,l=npcR.length();k<l;k++)
		{
			Critter@nr=npcR[k];
			if(nlIsNpc)
			{
				AddAttackPlane(nl,0,nr);
				nl.AddEnemyInStack(nr.Id);
				nl.Wait(Random(4000,5000));
			}
			if(nr.IsNpc())
			{
				AddAttackPlane(nr,0,nl);
				nr.AddEnemyInStack(nl.Id);
				nr.Wait(Random(4000,5000));
			}
		}
	}
}

Map@GenerateEncounter(CFoundedEncounter@fe,Critter@[]@critters)
{
	CEncounter@encounter=fe.Encounter;
	uint16 locPid=((@encounter!=null)?encounter.LocPid:0);
	if(locPid==0)
	locPid=fe.LocationPids[Random(0,fe.LocationPids.length()-1)];
	
	fe.LocationId=CreateLocation(locPid,fe.PositionX,fe.PositionY,null);
	if(fe.LocationId==0)
	{
		Log("CreateLocation fail, location pid<"+locPid+">.");
		return null;
	}
	
	Location@location=GetLocation(fe.LocationId);
	if(not(@location!=null))
	{
		Log("GetLocation fail.");
		return null;
	}              
	
	Map@map=location.GetMapByIndex(0);
	if(not(@map!=null))
	{
		Log("GetMapByIndex fail.");
		return null;
	}
	
	uint16 startX=0,startY=0;
	if(not map.GetEntireCoords(0,0,startX,startY))
	{
		Log("Default entire not found.");
		return null;
	}
	fe.StartHexX=startX;
	fe.StartHexY=startY;
	
	map.SetData(56,1);
	
	if(not(@encounter!=null))
	{
		fe.IsGenerated=true;
		return map;
	}
	
	Critter@leader=critters[0];
	Critter@[][]crittersGrouops(encounter.Groups.length());
	
	for(uint i=0,j=encounter.Groups.length();i<j;i++)
	{
		uint groupNum=encounter.Groups[i];
		
		if(groupNum==(uint(-1)))
		{
			Critter@[]@crGroup=crittersGrouops[i];
			crGroup.resize(critters.length());
			for(uint k=0,l=critters.length();k<l;k++)
			@crGroup[k]=critters[k];
			continue;
		}
		
		if(groupNum>=(114))
		{
			Log("Invalid group number.");
			continue;
		}
		
		CEncounterGroup@group=EncounterGroups[groupNum];
		uint ratio=Random(encounter.RatioMin[i],encounter.RatioMax[i]);
		
		uint distance=group.Distance;
		if(distance==0)
		distance=7+leader.Stat[(1)]+leader.Perk[(381)]*3;
		
		uint teamId=group.TeamNum;
		if(teamId==0)
		teamId=(24)+i;
		
		uint position=group.Position;
		uint spacing=group.Spacing;
		if(position==(1))
		spacing=leader.Stat[(1)]+leader.Perk[(381)]*3;
		
		uint[]positionDirs=PositionDirs[position];
		uint steps=positionDirs[0];
		uint dirsCount=0;
		
		uint freeDir=GetFreeDir(fe.DirBusy);
		if(freeDir!=0)
		RotatePosition(freeDir,positionDirs);
		uint reversDir=freeDir+3;
		if(reversDir>5)
		reversDir-=6; 
		
		uint16[]pointX={startX,startY};
		uint16[]pointY={startX,startY};
		if(position!=(0))
		{
			uint16 hx=pointX[0],hy=pointY[0];
			map.MoveHexByDir(pointX[0],pointY[0],freeDir,position!=(1)?distance:spacing);
			map.GetHexCoord(hx,hy,pointX[0],pointY[0],0.0f,0);
			pointX[1]=pointX[0];
			pointY[1]=pointY[0];
			MovePositionPoint(map,pointX[1],pointY[1],positionDirs,1,0,spacing);
		}
		
		for(uint k=0,l=group.Objects.length();k<l;k++)
		{
			CEncounterObject@obj=group.Objects[k];
			
			if(not CheckChecks(obj.Checks,critters))
			continue;
			
			uint otherDistance=obj.DistanceLength;
			uint count=obj.RatioValue*ratio/100;
			if(count==0)
			count=1;
			
			uint16 oldPosX=startX,oldPosY=startY;
			for(uint n=0;n<count;n++)
			{
				uint16 posX,posY;
				if(otherDistance>0||position==(0))
				{
					posX=startX+Random(-5,5);
					posY=startY+Random(-5,5);
					map.MoveHexByDir(posX,posY,freeDir,otherDistance>0?otherDistance:distance);
				}
				else
				{
					uint pathIndex=dirsCount%2;
					posX=pointX[pathIndex]+(position==(1)?Random(-3,0):0);
					posY=pointY[pathIndex]+(position==(1)?Random(-3,0):0);
					MovePositionPoint(map,pointX[pathIndex],pointY[pathIndex],positionDirs,pathIndex,dirsCount,spacing);
					dirsCount++;
				}
				
				map.GetHexCoord(oldPosX,oldPosY,posX,posY,0.0f,0);
				oldPosX=posX;
				oldPosY=posY;
				ParseEncounterObject(obj,map,posX,posY,reversDir,crittersGrouops[i],teamId);
			}
		}
	}
	
	for(uint i=0,j=encounter.Actions.length();i<j;i+=3)
	{
		uint fromGroup=encounter.Actions[i];
		uint toGroup=encounter.Actions[i+1];
		uint action=encounter.Actions[i+2];
		
		if(action==(1)&&fromGroup<crittersGrouops.length()&&toGroup<crittersGrouops.length())
		ActionFighting(crittersGrouops[fromGroup],crittersGrouops[toGroup]);
	}
	
	fe.IsGenerated=true;
	return map;
}                                 

void FindEncounter(Critter@[]&group,Item@car,uint x,uint y,uint&encounterDescriptor,bool&waitForAnswer,bool empty,int ec)
{
	encounterDescriptor=0;
	waitForAnswer=false;
	
	uint zx=x/(50);
	uint zy=y/(50);
	if(zx>=(7)||zy>=(12))
	{
		
		return;
	}
	
	CZone@zone=Worldmap[zy*(7)+zx];
	Critter@leader=group[0]; 
	
	if(empty)
	{
		CFoundedEncounter@fe=GetNearFoundedEncounter(group,x,y,(50)/10);
		if(fe is null)
		@fe=CreateFoundedEncounter(x-x%10+4,y-y%10+4,null,zone.Table.LocationPids,leader.Id,group.length()>1);
		
		if(not(@fe!=null))
		return;
		waitForAnswer=false;
		encounterDescriptor=fe.Index;
		return;
	} 
	
	CFoundedEncounter@feAlready=GetNearFoundedEncounter(group,x,y,(50)/4);
	if((@feAlready!=null))
	{
		int outdoorsman=leader.Skill[(217)]+zone.Difficulty;
		outdoorsman=(((outdoorsman)>(95))?(95):(((outdoorsman)<(6))?(6):(outdoorsman)));
		if(outdoorsman>=Random(1,100))
		{
			uint8 say=feAlready.TurnBased?(16):(15);
			if((@feAlready.Encounter!=null))
			{
				leader.SayMsg(say,(4),feAlready.OwnerGroup?(10000022):(10000021),
				"$who @msg gm "+feAlready.Encounter.StrNum+"@$player"+GetPlayerName(feAlready.OwnerId));
			}
			else
			{
				leader.SayMsg(say,(4),feAlready.OwnerGroup?(10000024):(10000023),
				"$player"+GetPlayerName(feAlready.OwnerId));
			}
			waitForAnswer=true;
			if(leader.Skill[(217)]<=95)
			leader.StatBase[(76)]+=100-leader.Skill[(217)]-zone.Difficulty;
			else
			leader.StatBase[(76)]+=5-zone.Difficulty;
		}
		
		for(uint i=0,j=group.length();i<j;i++)
		group[i].Say((41),"");
		encounterDescriptor=feAlready.Index;
		return;
	}
	
	if(leader.Param[(703)]==(3)||ec<1)
	return; 
	
	uint chance;
	if(((__Hour)>=7&&(__Hour)<=11))
	chance=zone.MorningChance;
	if(((__Hour)>=12&&(__Hour)<=21))
	chance=zone.AfternoonChance;
	else
	chance=zone.NightChance;
	if(ec>99)
	{}
	else if(uint(Random(1,100))>uint(chance*(ec*0.01f)))
	return; 
	
	int luck=0;
	for(uint i=0,j=group.length();i<j;i++)
	luck+=group[i].Stat[(6)];
	luck/=group.length();
	
	int roll=Random(0,100)+luck-5+2*leader.Perk[(342)]+leader.Perk[(348)]+leader.Perk[(346)];
	if(roll<0)
	roll=0;
	int maxRoll=0;
	
	CEncounter[]@encounters=zone.Table.Encounters;
	CEncounter@[]encountersThru(encounters.length());
	for(uint i=0,j=encounters.length();i<j;i++)
	{
		CEncounter@enc=encounters[i];
		if(CheckChecks(enc.Checks,group))
		{
			maxRoll+=enc.Chance;
			@encountersThru[i]=encounters[i];
		}
		else
		{
			@encountersThru[i]=null;
		}
	}
	
	roll=roll*maxRoll/100;
	for(uint i=0,j=encountersThru.length();i<j;i++)
	{
		CEncounter@enc=encountersThru[i];
		
		if(not(@enc!=null))
		continue;
		if(uint(roll)>enc.Chance&&i<j-1)
		{
			roll-=enc.Chance;
			continue;
		}
		
		CFoundedEncounter@fe=CreateFoundedEncounter(x-x%10+4,y-y%10+4,enc,zone.Table.LocationPids,leader.Id,group.length()>1);
		if(not(@fe!=null))
		return;
		
		int outdoorsman=leader.Skill[(217)]+zone.Difficulty;
		outdoorsman=(((outdoorsman)>(95))?(95):(((outdoorsman)<(6))?(6):(outdoorsman)));
		if(outdoorsman>=Random(1,100))
		{
			leader.SayMsg((14),(4),(10000020),"$who @msg gm "+enc.StrNum+"@");
			waitForAnswer=true;
			if(leader.Skill[(217)]<=95)
			leader.StatBase[(76)]+=100-leader.Skill[(217)]-zone.Difficulty;
			else
			leader.StatBase[(76)]+=5-zone.Difficulty;
		}
		
		for(uint i=0,j=group.length();i<j;i++)
		group[i].Say((41),"");
		encounterDescriptor=fe.Index;
		break;
	}
}

void InviteToEncounter(Critter@[]&group,Item@car,uint encounterDescriptor,int combatMode,uint&mapId,uint16&hexX,uint16&hexY,uint8&dir)
{
	mapId=0;
	
	CFoundedEncounter@fe=GetFoundedEncounter(encounterDescriptor);
	if(not(@fe!=null))
	{
		Log("GetFoundedEncounter fail.");
		return;
	}
	
	bool isGenerated=fe.IsGenerated;
	Map@map=null;
	if(isGenerated)
	{
		Location@location=GetLocation(fe.LocationId);
		if(not(@location!=null))
		{
			
			return;
		}
		
		@map=location.GetMapByIndex(0);
	}
	else
	{
		@map=GenerateEncounter(fe,group);
	}
	
	if(not(@map!=null))
	{
		Log("Map not found.");
		return;
	}
	
	if(not isGenerated&&combatMode==(2))
	{
		map.SetTurnBasedAvailability(true);
		fe.TurnBased=true;
	}
	
	Critter@leader=group[0];
	mapId=map.Id;
	hexX=fe.StartHexX;
	hexY=fe.StartHexY;
	if(isGenerated)
	{
		if((@car!=null))
		{
			
			hexX=uint16(-1);
			hexY=uint16(-1);
		}
		else
		{
			dir=GetFreeDir(fe.DirBusy);
			map.MoveHexByDir(hexX,hexY,dir,leader.Stat[(1)]+leader.Perk[(381)]*3);
			dir+=3;
			if(dir>5)
			dir-=6;
		}
	}
	else
	{
		if((@car!=null))
		{
			
			hexX=uint16(-1);
			hexY=uint16(-1);
		}
		
		dir=Random(0,5);
	}
	
	if(isGenerated||(@fe.Encounter!=null))
	{
		for(uint i=0,j=group.length();i<j;i++)
		{
			Critter@cr=group[i];
			if(not isGenerated)
			cr.SayMsg((11),(4),(10000010),"$who @msg gm "+fe.Encounter.StrNum+"@");
			else if((@fe.Encounter!=null))
			cr.SayMsg((11),(4),fe.OwnerGroup?(10000012):(10000011),"$who @msg gm "+fe.Encounter.StrNum+"@$player"+GetPlayerName(fe.OwnerId));
			else
			cr.SayMsg((11),(4),fe.OwnerGroup?(10000014):(10000013),"$player"+GetPlayerName(fe.OwnerId));
		}
	}
	if((@fe.Encounter!=null))
	AssignChecks(fe.Encounter.Checks,group);
}