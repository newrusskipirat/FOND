                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

uint[]MAPS_ROAD={750,751,752,755,756,757,760,761,762,765,766,767,770,771,772,775,776,777,780,781,782,785,786,787,790,791,792,795,796,797};
uint[]MAPS_WASTELAND={500,501,502,503,504,505,506,507,508,509};               

class CIMP
{
	bool Destroible;
	
	uint16 TileGroup;
	
	uint16 HexX;
	uint16 HexY;
	uint Hash;
	
	Item@object;
	
	CIMP()
	{
		@object=null;
		
		HexX=0;
		HexY=0;
		Hash=0;
		
		Destroible=false;
	}
	
	CIMP(uint hash,Item&item,bool destroible)
	{
		Hash=hash;
		@object=item;
		
		Destroible=destroible;
		
		if(SetPic())
		{
			HexX=object.HexX;
			HexY=object.HexY;
		}
	}
	
	CIMP(uint hash,Map&map)
	{
		Spawn(map);
		SetPic(hash);
	}
	
	bool Spawn(Map&map)
	{
		uint16 hexX=0,hexY=0,beginX=0,beginY=0,endX=0,endY=0;
		uint hash=0;
		@object=null;
		
		if(map.GetEntireCoords(255,0,beginX,beginY)&&map.GetEntireCoords(0,0,endX,endY))
		{
			uint count=0;
			
			if(!tileInited)
			InitTiles();
			do
			{
				hexX=Random(beginX+1,endX-1);
				hexY=Random(beginY+1,endY-1);
				
				hash=map.GetTile(((hexX)>>1),((hexY)>>1));
				
				for(uint i=1;i<=32;++i)
				if((((TileGroup)&(pow(2,i)))!=0)&&IsTileAvalible(hash,i))
				break;
				
				if(count++>=50)
				return false;
			}
			while(!map.IsHexPassed(hexX,hexY));
			
			@object=map.AddItem(hexX,hexY,(904),1);
			
			if(@object!is null)
			object.SetEvent((4),"cimp@e_SkillImp");
			
			HexX=hexX;
			HexY=hexY;
		}
		return(@object!is null);
	}
	
	private bool SetMapPic(uint hash)
	{
		if(object is null)
		return false;
		
		object.SetMapPic(hash);
		object.Update();
		return true;
	}
	
	bool SetPic(){return SetPic(Hash);}
	bool SetPic(uint hash){return SetMapPic(hash);}
	Item@get_Object(){return@object;}
}

bool e_SkillImp(Item&item,Critter&cr,int skill)
{
	
	if(skill==(-3)&&item.GetItems(uint(-1),null)==1)
	{
		DeleteItem(item);
		return true;
	}
	return false;
}

class CLO:CIMP
{
	
	int RechLevel;
	uint16 GroupType;
	
	RespawnedItemGroup@Group;
	
	CLO()
	{
		Destroible=false;
		RechLevel=0;
		GroupType=uint16(-1);
		@Group=null;
	}
	
	CLO(uint16 groupType,int rechLvl,bool destroible)
	{
		Destroible=false;
		RechLevel=rechLvl;
		GroupType=groupType;
		
		@Group=GetItemGroup(GroupType);
		TileGroup=Group.TileGroup;
		Destroible=destroible;  
		
		if(Group is null)
		Log("NULL!!"); 
		
	}
	
	CLO(uint mapPid,int rechLvl)
	{
		Destroible=false;
		RechLevel=rechLvl;
		GroupType=0;
		
		for(;GroupType<(14);++GroupType){
			@Group=GetItemGroup(GroupType);
			if(Group.MapProtos.find(mapPid)==-1)
			continue;
			
			TileGroup=Group.TileGroup;
			Destroible=true;
		}
		
		if(Group is null)
		Log("NULL!!");
		
	}
	
	bool SpawnInto()
	{
		if(Group is null||object is null)
		{
			Log("NULL!!");
			return false;
		}
		
		Map@map=GetMap(object.MapId);
		if(map is null)
		{
			return false;
		}
		else
		{
			if(Group.MapProtos.find(map.GetProtoId())==-1)
			{
				
				DeleteItem(object);
				return false;
			}
		}
		
		int len=Group.Length()-1;   
		
		for(uint16 i=0;i<len;++i)
		{
			uint8 chance=Random(0,95);
			uint16 index=Random(0,len);  
			
			uint8 count=0;
			uint16 pid=0;
			
			Group.GetItem(index,pid,count);
			
			while(Group.RespItems[index].Chance>chance&&--count>0)
			{
				if(@Object is null)
				{
					Log("NULL!!OBJ");
					return false;
				}
				
				chance=Random(chance,95);
				object.AddItem(pid,1,0);
			}
		}
		return true;
	}
	
	bool SpawnMap(Map&map)
	{
		return Spawn(map);
		
	}
	
	bool Add(Map&map)
	{
		if(!Spawn(map))
		return false;
		
		if(!SetPic(GetLOHash(GroupType)))
		return false;
		
		if(!SpawnInto())
		return false;
		return true;
	}
}

class RespawnedItem
{
	uint8 Chance;
	uint8 Count;
	uint16 Pid;
	
	RespawnedItem()
	{
		Chance=0;
		Count=0;
		Pid=0;
	}
	
	RespawnedItem(uint16 pid,uint8 chance,uint8 count)
	{
		Chance=chance;
		Count=count;
		Pid=pid;
	} 
	
}

class RespawnedItemGroup
{
	RespawnedItem[]RespItems;
	uint[]MapProtos;
	uint TileGroup;
	
	RespawnedItemGroup()
	{
		RespItems.resize(0);
	}
	
	uint16 Length()
	{
		return RespItems.length();
	}
	
	bool GetItem(uint16 index,uint16&pid,uint8&count)
	{
		if(index>=RespItems.length())
		return false;
		
		pid=RespItems[index].Pid;
		count=RespItems[index].Count;
		
		return true;
	}
}                                                                                          

class GroupRock:RespawnedItemGroup
{
	GroupRock()
	{
		
		RespItems.insertLast(RespawnedItem((19),50,5));
		RespItems.insertLast(RespawnedItem((536),3,1));
		RespItems.insertLast(RespawnedItem((537),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
	}
} 

class GroupAnimalCorpse:RespawnedItemGroup
{
	GroupAnimalCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((539),1,2));
		RespItems.insertLast(RespawnedItem((1440),3,3));
		RespItems.insertLast(RespawnedItem((449),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
	}
} 

class GroupSmallTrash:RespawnedItemGroup
{
	GroupSmallTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,5));
		RespItems.insertLast(RespawnedItem((98),3,2));
		RespItems.insertLast(RespawnedItem((532),2,5));
		RespItems.insertLast(RespawnedItem((542),2,5));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),1,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupTrash:RespawnedItemGroup
{
	GroupTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,2));
		RespItems.insertLast(RespawnedItem((98),3,1));
		RespItems.insertLast(RespawnedItem((532),5,2));
		RespItems.insertLast(RespawnedItem((542),4,2));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),2,1));
		RespItems.insertLast(RespawnedItem((227),1,1));
		RespItems.insertLast(RespawnedItem((226),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
} 

class GroupSleeper:RespawnedItemGroup
{
	GroupSleeper()
	{
		
		RespItems.insertLast(RespawnedItem((572),5,3));
		RespItems.insertLast(RespawnedItem((40),1,1));
		RespItems.insertLast(RespawnedItem((48),1,1));
		RespItems.insertLast(RespawnedItem((259),1,1));
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((314),1,1));
		RespItems.insertLast(RespawnedItem((315),1,1));
		RespItems.insertLast(RespawnedItem((316),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupBox:RespawnedItemGroup
{
	GroupBox()
	{
		
		RespItems.insertLast(RespawnedItem((227),3,1));
		RespItems.insertLast(RespawnedItem((226),3,1));
		RespItems.insertLast(RespawnedItem((79),1,1));
		RespItems.insertLast(RespawnedItem((98),3,3));
		RespItems.insertLast(RespawnedItem((475),1,2)); 
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}  

class GroupMetalTrash:RespawnedItemGroup
{
	GroupMetalTrash()
	{ 
		
		RespItems.insertLast(RespawnedItem((297),3,1));
		RespItems.insertLast(RespawnedItem((475),3,1));
		RespItems.insertLast(RespawnedItem((1475),3,1));
		RespItems.insertLast(RespawnedItem((538),3,1));
		RespItems.insertLast(RespawnedItem((50),3,1));
		RespItems.insertLast(RespawnedItem((1508),3,1));
		RespItems.insertLast(RespawnedItem((1502),3,1));
		RespItems.insertLast(RespawnedItem((1504),3,1));
		RespItems.insertLast(RespawnedItem((1505),3,1));
		RespItems.insertLast(RespawnedItem((1509),3,1));
		RespItems.insertLast(RespawnedItem((1510),3,1));
		RespItems.insertLast(RespawnedItem((1507),3,1));
		RespItems.insertLast(RespawnedItem((1506),3,1));
		RespItems.insertLast(RespawnedItem((1503),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupNewspMachine:RespawnedItemGroup
{
	GroupNewspMachine()
	{
		
		RespItems.insertLast(RespawnedItem((41),3,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=4;
	}
}

class GroupBottleBox:RespawnedItemGroup
{
	GroupBottleBox()
	{
		
		RespItems.insertLast(RespawnedItem((532),10,2));
		RespItems.insertLast(RespawnedItem((542),15,3));
		RespItems.insertLast(RespawnedItem((124),2,3));
		RespItems.insertLast(RespawnedItem((125),2,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupPlant:RespawnedItemGroup
{
	GroupPlant()
	{ 
		
		RespItems.insertLast(RespawnedItem((271),100,2));
		RespItems.insertLast(RespawnedItem((272),100,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupCorpse:RespawnedItemGroup
{
	GroupCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((532),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupEvilMinds:RespawnedItemGroup
{
	GroupEvilMinds()
	{
		RespItems.insertLast(RespawnedItem((349),100,1));
		
		RespItems.insertLast(RespawnedItem((401),100,1));
		RespItems.insertLast(RespawnedItem((1036),100,1));
		RespItems.insertLast(RespawnedItem((405),100,1));
		
		RespItems.insertLast(RespawnedItem((35),100,10));
		RespItems.insertLast(RespawnedItem((1035),100,24));
		RespItems.insertLast(RespawnedItem((39),100,100));
		
	}
}

class GroupRoad:RespawnedItemGroup
{
	GroupRoad()
	{
		
		RespItems.insertLast(RespawnedItem((532),5,1));
		RespItems.insertLast(RespawnedItem((542),5,1));
		RespItems.insertLast(RespawnedItem((468),3,2));
		RespItems.insertLast(RespawnedItem((226),2,1));
		RespItems.insertLast(RespawnedItem((227),2,1));
		RespItems.insertLast(RespawnedItem((295),2,1));
		RespItems.insertLast(RespawnedItem((439),25,3));
		RespItems.insertLast(RespawnedItem((572),27,3));
		RespItems.insertLast(RespawnedItem((1512),5,2));
		RespItems.insertLast(RespawnedItem((449),4,1));
		RespItems.insertLast(RespawnedItem((540),10,1));
		RespItems.insertLast(RespawnedItem((534),15,1));
		RespItems.insertLast(RespawnedItem((19),10,3));
		RespItems.insertLast(RespawnedItem((535),2,2)); 
		
		MapProtos=MAPS_ROAD;
		
		TileGroup=(1);
	}
}    

class GroupPeopleontheroad:RespawnedItemGroup
{
	GroupPeopleontheroad()
	{
		
		RespItems.insertLast(RespawnedItem((317),1,1));
		RespItems.insertLast(RespawnedItem((905),1,1));
		RespItems.insertLast(RespawnedItem((262),4,1));
		RespItems.insertLast(RespawnedItem((225),1,1));
		RespItems.insertLast(RespawnedItem((471),1,1));
		RespItems.insertLast(RespawnedItem((571),1,1));
		RespItems.insertLast(RespawnedItem((448),1,1));
		RespItems.insertLast(RespawnedItem((289),1,1));
		RespItems.insertLast(RespawnedItem((297),1,1));
		RespItems.insertLast(RespawnedItem((543),1,1));
		RespItems.insertLast(RespawnedItem((1427),1,1));
		RespItems.insertLast(RespawnedItem((1428),1,1));
		RespItems.insertLast(RespawnedItem((1555),3,1));
		RespItems.insertLast(RespawnedItem((1556),3,2));
		RespItems.insertLast(RespawnedItem((535),1,3));
		RespItems.insertLast(RespawnedItem((1440),3,3));
		RespItems.insertLast(RespawnedItem((449),1,1)); 
		
		MapProtos=MAPS_WASTELAND;
		
		TileGroup=(2);
	}
} 

class GroupRuins:RespawnedItemGroup
{
	GroupRuins()
	{
		
		RespItems.insertLast(RespawnedItem((126),3,2));
		RespItems.insertLast(RespawnedItem((267),3,2));
		RespItems.insertLast(RespawnedItem((266),2,1));
		RespItems.insertLast(RespawnedItem((314),2,2));
		RespItems.insertLast(RespawnedItem((315),3,1));
		RespItems.insertLast(RespawnedItem((316),4,3));
		RespItems.insertLast(RespawnedItem((117),1,1));
		RespItems.insertLast(RespawnedItem((317),1,1));
		RespItems.insertLast(RespawnedItem((905),1,1));
		RespItems.insertLast(RespawnedItem((262),2,1));
		RespItems.insertLast(RespawnedItem((225),1,1));
		RespItems.insertLast(RespawnedItem((471),1,1));
		RespItems.insertLast(RespawnedItem((571),1,1));
		RespItems.insertLast(RespawnedItem((448),1,1));
		RespItems.insertLast(RespawnedItem((289),3,1));
		RespItems.insertLast(RespawnedItem((297),3,1));
		RespItems.insertLast(RespawnedItem((543),1,1));
		RespItems.insertLast(RespawnedItem((1427),1,1));
		RespItems.insertLast(RespawnedItem((1428),1,1));
		RespItems.insertLast(RespawnedItem((468),3,1));
		RespItems.insertLast(RespawnedItem((226),4,2));
		RespItems.insertLast(RespawnedItem((572),3,2));
		RespItems.insertLast(RespawnedItem((1512),3,1));
		RespItems.insertLast(RespawnedItem((1512),4,2));
		RespItems.insertLast(RespawnedItem((535),3,3));
		RespItems.insertLast(RespawnedItem((542),2,5));
		RespItems.insertLast(RespawnedItem((519),15,27));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),1,2));
		
		uint[]tempPids={600,601,602};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupJunkyard:RespawnedItemGroup
{
	GroupJunkyard()
	{
		
		RespItems.insertLast(RespawnedItem((267),2,1));
		RespItems.insertLast(RespawnedItem((266),1,1));
		RespItems.insertLast(RespawnedItem((289),1,1));
		RespItems.insertLast(RespawnedItem((297),1,1));
		RespItems.insertLast(RespawnedItem((1564),10,2));
		RespItems.insertLast(RespawnedItem((572),3,2));
		RespItems.insertLast(RespawnedItem((117),1,1));
		RespItems.insertLast(RespawnedItem((536),3,3));
		RespItems.insertLast(RespawnedItem((537),3,2));
		RespItems.insertLast(RespawnedItem((535),3,3));
		RespItems.insertLast(RespawnedItem((538),4,2));
		RespItems.insertLast(RespawnedItem((1426),1,1));
		RespItems.insertLast(RespawnedItem((1473),7,2));
		RespItems.insertLast(RespawnedItem((1474),4,2));
		RespItems.insertLast(RespawnedItem((1475),5,2));
		RespItems.insertLast(RespawnedItem((1477),3,2));
		RespItems.insertLast(RespawnedItem((1478),1,2));
		RespItems.insertLast(RespawnedItem((1502),4,2));
		RespItems.insertLast(RespawnedItem((1503),6,2));
		RespItems.insertLast(RespawnedItem((1504),4,2));
		RespItems.insertLast(RespawnedItem((1505),3,2));
		RespItems.insertLast(RespawnedItem((1506),5,2));
		RespItems.insertLast(RespawnedItem((1507),4,2));
		RespItems.insertLast(RespawnedItem((1508),4,2));
		RespItems.insertLast(RespawnedItem((1509),3,2));
		RespItems.insertLast(RespawnedItem((1510),3,2));
		RespItems.insertLast(RespawnedItem((1511),4,2));
		RespItems.insertLast(RespawnedItem((1513),3,2));
		RespItems.insertLast(RespawnedItem((1517),1,1));
		RespItems.insertLast(RespawnedItem((1517),7,2));
		RespItems.insertLast(RespawnedItem((1680),4,1));
		RespItems.insertLast(RespawnedItem((1681),4,1));
		RespItems.insertLast(RespawnedItem((3852),3,1));
		RespItems.insertLast(RespawnedItem((356),6,2));
		RespItems.insertLast(RespawnedItem((55),2,2));
		RespItems.insertLast(RespawnedItem((377),3,2));
		RespItems.insertLast(RespawnedItem((98),6,2));
		RespItems.insertLast(RespawnedItem((475),7,3));
		RespItems.insertLast(RespawnedItem((50),4,2));
		RespItems.insertLast(RespawnedItem((439),3,2));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		
		uint[]tempPids={43};
		MapProtos=tempPids;
		
		TileGroup=2;
	}
}

uint GetLOHash(uint16 groupType)
{
	string temp="art\\scenery\\";
	string[]tempAdd;
	switch(groupType)
	{                            
		
		case(100):
		tempAdd.insertLast("locker5.frm");
		break;
		
		case(10):
		tempAdd.insertLast("dead01.frm");
		tempAdd.insertLast("dead02.frm");
		tempAdd.insertLast("dead03.frm");
		tempAdd.insertLast("dead04.frm");
		tempAdd.insertLast("v13bones.frm");
		tempAdd.insertLast("bone01.frm");
		tempAdd.insertLast("bone03.frm");
		break;
		
		case(9): 
		
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		break;
		
		case(8):
		tempAdd.insertLast("crate01.frm");
		tempAdd.insertLast("crate02.frm");
		tempAdd.insertLast("crate03.frm");
		break;
		
		case(7):
		tempAdd.insertLast("mailbx.frm");
		tempAdd.insertLast("newsp1.frm");
		tempAdd.insertLast("newsp2.frm");
		tempAdd.insertLast("newsp3.frm");
		tempAdd.insertLast("newsp4.frm");
		tempAdd.insertLast("newsp5.frm");
		tempAdd.insertLast("newsp6.frm");
		tempAdd.insertLast("novbud1.frm");
		tempAdd.insertLast("novbud2.frm");
		break;
		
		case(6):
		tempAdd.insertLast("junk1.frm");
		tempAdd.insertLast("junk2.frm");
		tempAdd.insertLast("junk3.frm");
		tempAdd.insertLast("junk4.frm");
		tempAdd.insertLast("junk5.frm");
		break;
		
		case(5):
		tempAdd.insertLast("boxes1.frm");
		tempAdd.insertLast("boxes2.frm");
		tempAdd.insertLast("boxes3.frm");
		tempAdd.insertLast("boxes4.frm");
		tempAdd.insertLast("njunk5.frm");
		tempAdd.insertLast("njunk6.frm");
		tempAdd.insertLast("boxes02.frm");
		tempAdd.insertLast("boxes03.frm");
		tempAdd.insertLast("boxes04.frm");
		break;
		
		case(4):
		tempAdd.insertLast("bed1.frm");
		tempAdd.insertLast("bed2.frm");
		tempAdd.insertLast("bed3.frm");
		tempAdd.insertLast("bed4.frm");
		tempAdd.insertLast("bed5.frm");
		tempAdd.insertLast("bed6.frm");
		tempAdd.insertLast("bed7.frm");
		tempAdd.insertLast("bed8.frm");
		break;
		
		case(3):
		tempAdd.insertLast("trashcn.frm");
		tempAdd.insertLast("kont1.frm");
		tempAdd.insertLast("kontsmet.frm");
		tempAdd.insertLast("weed05.frm");
		break;
		
		case(2):
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		tempAdd.insertLast("weed08.frm");
		tempAdd.insertLast("weed09.frm");
		tempAdd.insertLast("weed15.frm");
		tempAdd.insertLast("weed16.frm");
		tempAdd.insertLast("weed17.frm");
		tempAdd.insertLast("trash1.frm");
		tempAdd.insertLast("trash2.frm");
		tempAdd.insertLast("trash3.frm");
		break;
		
		case(1):
		tempAdd.insertLast("bone05.frm");
		tempAdd.insertLast("bone04.frm");
		tempAdd.insertLast("bone02.frm");
		break;
		
		case(0):
		tempAdd.insertLast("rock01.frm");
		tempAdd.insertLast("rock02.frm");
		tempAdd.insertLast("rock04.frm");
		tempAdd.insertLast("rock05.frm");
		tempAdd.insertLast("rock09.frm");
		tempAdd.insertLast("rock10.frm");
		tempAdd.insertLast("rubble1.frm");
		tempAdd.insertLast("drock1.frm");
		tempAdd.insertLast("drock2.frm");
		tempAdd.insertLast("drock3.frm");
		tempAdd.insertLast("drock4.frm");
		tempAdd.insertLast("drock8.frm");
		break;
		
		case(11):
		tempAdd.insertLast("weed17.frm");
		break;
		
		case(12):
		tempAdd.insertLast("weed17.frm");
		break;
		
		case(13):
		tempAdd.insertLast("weed17.frm");
		break;
		
		default:
		tempAdd.insertLast("bone04.frm");
		break;
	}
	
	uint rnd=Random(0,tempAdd.length()-1);
	
	temp+=tempAdd[rnd]; 
	
	return GetStrHash(temp);
} 

RespawnedItemGroup@GetItemGroup(uint16 groupType)
{
	RespawnedItemGroup@temp;
	switch(groupType)
	{    
		
		case(100):
		@temp=GroupEvilMinds();
		break;
		
		case(10):
		@temp=GroupCorpse();
		break;
		case(9):
		@temp=GroupPlant();
		break;
		case(8):
		@temp=GroupBottleBox();
		break;
		case(7):
		@temp=GroupNewspMachine();
		break;
		case(6):
		@temp=GroupMetalTrash();
		break;
		case(5):
		@temp=GroupBox();
		break;
		case(4):
		@temp=GroupSleeper();
		break;
		case(3):
		@temp=GroupTrash();
		break;
		case(2):
		@temp=GroupSmallTrash();
		break;
		case(1):
		@temp=GroupAnimalCorpse();
		break;
		case(0):
		@temp=GroupRock();
		break;
		case(11):
		@temp=GroupRoad();
		break;
		case(12):
		@temp=GroupPeopleontheroad();
		break;
		case(13):
		@temp=GroupJunkyard();
		break;
		default:
		@temp=null;
		break;
	}
	
	if(temp is null)
	Log("NULL!!!");
	
	return@temp;
}

bool tileInited=false;

uint[][]tileGroups((8));

void InitTiles()
{ 
	
	uint[]@data=tileGroups[(1)];
	data.resize(0);            
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=43;++i)
	{
		string temp=("art/tiles/")+"road"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(3)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"curb0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(2)];
	data.resize(0);
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg500"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"edg600"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg601"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg700"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=4;++i)
	{
		string temp=("art/tiles/")+"eds00"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(6)];
	data.resize(0);  
	
	data.insertLast(GetStrHash(("art/tiles/")+"cav4008"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4009"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4010"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4011"+(".frm"))); 
	
	@data=tileGroups[(7)];
	data.resize(0);
	
	for(uint8 i=1;i<=6;++i)
	{
		for(uint8 j=1;j<=7;++j)
		{
			string temp=("art/tiles/")+"bld_floor_"+i+"_"+j+(".png");
			data.insertLast(GetStrHash(temp));
		}
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_7_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=3;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_8_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(5)];
	data.resize(0);
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"cav100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"cav200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=5;++i)
	{
		string temp=("art/tiles/")+"cav300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=7;++i)
	{
		string temp=("art/tiles/")+"cav400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(4)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"brick0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=13;++i)
	{
		string temp=("art/tiles/")+"brick"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	tileInited=true;     
	
}                                        

bool IsTileAvalible(uint hash,uint8 group)
{
	uint[]@data=tileGroups[group];
	
	for(uint16 i=0,j=data.length();i<j;++i)
	{
		
		if(data[i]==hash)
		{
			
			return true;
		}
	}
	
	return false;
}

bool IsTileGround(uint hash)
{
	return IsTileAvalible(hash,(6));
}

bool SpawnLoMapPid(Map@map)
{
	if(@map is null){Log("cimp null map");return false;}
	
	uint mapPid=map.GetProtoId();
	RespawnedItemGroup@group=null;
	
	for(uint8 i=0;i<(14);++i){
		@group=GetItemGroup(i);
		
		if(group.MapProtos.find(mapPid)==-1){
			Log("no map type"+i);
			continue;
		}
		
		int rechLvl=(1000);
		
		for(uint16 ii=0;ii<(100);++ii)
		{
			uint8 temp=Random(1,99);
			rechLvl-=temp;
			if(rechLvl>0)
			{
				CLO@clo=CLO(i,temp,false);
				
				if(clo is null)
				{
					Log("clo null");
					continue;
				}
				
				clo.Add(map);
				
				Log("clo add "+clo.HexX+":"+clo.HexY);
			}else{break;}
			
		}
		
	}
	return true;
}     

void tc(Critter&cr,int,int,int){
	
	CLO@clo=CLO((11),10000,true);
	clo.Spawn(cr.GetMap());
}

void spawnlomap(Critter&cr,int id,int,int){
	Map@map=cr.GetMap();
	if(id>0){
		@map=GetMap(id);
	}
	
	if(map is null){cr.Say((11),"no map");return;}
	
	bool r=SpawnLoMapPid(map);
	
	cr.Say((11),""+(r?"":"не")+"успех");
}
