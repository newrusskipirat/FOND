// Author: rifleman17
#include "_macros.fos"
#include "_colors.fos"
#include "_npc_pids.fos"

import void AffectPoison( Critter& cr, int value ) from "poison";
import void AffectRadiation( Critter& cr, int value ) from "radiation";

// from new SDK

import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

// Дверь, которая зпкроется через 2 игровые минуты илии через некоторое число реальных секунд , указанное в val3

void _DeleteItemInit( Item& item, bool ) { DeleteItem( item ); }

void _DoorAutoCloseInit( Item& door, bool firstTime )
{
    door.SetEvent( ITEM_EVENT_SKILL, "e_UseAutoCloseDoor" );
}

bool e_UseAutoCloseDoor( Item& door, Critter& cr, int skill )
{
    CreateTimeEvent( __FullSecond + REAL_MINUTE( door.Val3 == 0 ? 2 : door.Val3 ), "e_AutoCloseDoor", door.Id, true );
    return false;
}

uint e_AutoCloseDoor( uint[] @ val )
{
    Item@ door = GetItem( val[ 0 ] );
    if( not valid( door ) )
    {
        return 0;
    }
    if( !FLAG( door.LockerCondition, LOCKER_ISOPEN ) )
        return 0;
    uint16 x = 0;
    uint16 y = 0;
    Map@   map = door.GetMapPosition( x, y );
    if( not valid( map ) )
    {
        return 0;
    }

    Critter@ cr = map.GetCritter( x, y );
    if( valid( cr ) )
    {
        if( cr.IsLife() )
        {
            return REAL_MINUTE( 3 );
        }
        else
        {
            // Попытка сдвинуть труп. Если не получится, дверь поверх трупа закроется
            cr.TransitToMap( map.Id, x - 1, y, cr.Dir );
        }
    }

    if( door.LockerClose() )
        return 0;

    return REAL_MINUTE( 3 );
}

// Дверь, которая не открывается стандартными способами
void _ClosedDoorInit( Item& door, bool firstTime )
{
    door.SetEvent( ITEM_EVENT_SKILL, "_UseDoor" );
}

bool _UseDoor( Item& door, Critter& cr, int skill )
{
    return true;
}

// Дверь, при использовании которой открывается диалог
void _DialogDoorInit( Item& door, bool firstTime )
{
    door.SetEvent( ITEM_EVENT_SKILL, "_UseDialogDoor" );
}

bool _UseDialogDoor( Item& door, Critter& cr, int skill )
{
    RunDialog( cr, door.Val3, door.HexX, door.HexY, false );
    return true;
}

// Голодиск с номером, присвоенном в Val0
void _HoloInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() != PID_HOLODISK )
        return;
    item.HolodiskNumber = item.Val0;
    item.SetScript( "" );
    item.Update();

}

// from old lite

// powermagic - ????????? ????? ??? ????????
void _RndAnim( Item& item, bool firstTime ) // Sprite& sprite) // ItemCl& itemCl
{
    int rndFrm = Random( 0, item.Val1 );    // itemCl.GetSpriteCount(item.GetProtoId())); // + 1
    // item.Animate(rndFrm, rndFrm);
    item.AnimStayBegin      = rndFrm;
    item.AnimStayEnd        = rndFrm;
    item.AnimShowBegin      = rndFrm;
    item.AnimShowEnd        = rndFrm;
    item.AnimHideBegin      = rndFrm;
    item.AnimHideEnd        = rndFrm;
//	for (int i = 0; i > Sprite.FrmCount; i++)
    return;
}

void _ItemBagInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ItemBagPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_ItemBagUseItem" );
// item.SetEvent(ITEM_EVENT_USE_ITEM, "e_ItemBagOpen");
}

bool e_ItemBagPick( Item& item, Critter& crit, int skill )
{
    /*
       if(skill == SKILL_PICK_ON_GROUND)// && item.Accessory == ACCESSORY_CRITTER)
       {
       crit.ShowScreen(SCREEN_CLOSE, 0, "");
       crit.ShowContainer(null, item,TRANSFER_HEX_CONT_UP);
       crit.Say(SAY_NETMSG, "pick inv");
       }
       else */if( skill == SKILL_PICK_ON_GROUND && item.Accessory == ACCESSORY_HEX )
    {
//     crit.ShowContainer(crit, item, TRANSFER_CRIT_LOOT );
        MoveItem( item, item.GetCount(), crit );
        crit.Say( SAY_NETMSG, "pick grnd" );
//      crit.ShowScreen(SCREEN_BAG,
    }
    return true;
}

import void SwitchState( Item& locker ) from "lockers";

bool e_ItemBagUseItem( Item& item, Critter& crit, Item@ usedItem )
{
    if( valid( usedItem ) && usedItem.GetProtoId() == PID_SHOVEL )
    {
        Map @ map = crit.GetMap();
        if( map.IsHexPassed( item.HexX + 2, item.HexY + 2 ) )
        {
            string logMsg;
            Item @ hole = map.AddItem( item.HexX + 2, item.HexY + 2, ITEM_TREASURE_HOLE, 1 );
            SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            logMsg = "Init = " + SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            crit.Say( SAY_NETMSG, logMsg );
//       if(FLAG(hole.LockerCondition,LOCKER_ISOPEN)) {SwitchState(hole);}
            hole.Val4 = hole.HexX;
            hole.Val5 = hole.HexY;
            hole.Val7 = crit.WorldX;
            hole.Val8 = crit.WorldY;
            Item @ treasureMap = crit.AddItem( ITEM_TREASURE_MAP, 1 );
            treasureMap.Val7 = crit.WorldX;
            treasureMap.Val8 = crit.WorldY;
            treasureMap.SetLexems( "$hexX" + treasureMap.Val7 + "$hexY" + treasureMap.Val8 );
//       treasureMap.SetLexems("$hexY"+treasureMap.Val8);
            return true;
        }
    }
    else if( item.Accessory == ACCESSORY_HEX )
    {
//     MoveItem(usedItem, usedItem.GetCount(), item, 0);
        crit.ShowScreen( SCREEN_CLOSE, 0, "" );
        crit.ShowContainer( null, item, item.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
        return true;
    }
    return false;
}
/*
   void _TreasureInit(Item& item, bool firstTime)
   {
   item.SetEvent(ITEM_EVENT_USE_ON_ME, "e_TreasureOpen");
   item.SetEvent(ITEM_EVENT_SKILL, "e_TreasureUse");
   //   GraveSetFrm(item, 1);
   }

   bool e_TreasureOpen(Item& item, Critter& crit, Item@ usedItem)
   {
   if(valid(usedItem) && usedItem.GetProtoId()==PID_SHOVEL)
        {

                SwitchState(item);
                if(FLAG(item.LockerCondition,LOCKER_ISOPEN))
                {
   //             item.ChangeProto(902);
                  item.Val6 = 1;
                }
                else {item.Val6 = 0;}
                item.Update();
                return true;
        }
   return false;
   }



   bool e_TreasureUse(Item& item, Critter& cr, int skill)
   {
        if(skill==SKILL_PICK_ON_GROUND || skill==SK_LOCKPICK)
        {
                if(FLAG(item.LockerCondition,LOCKER_ISOPEN)) {cr.ShowContainer(null,item,TRANSFER_HEX_CONT_DOWN);}
                else {cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SHOVEL_NEEDED);}
                return true;
        }
        return false;
   }
 */
void _ShovelInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ShovelUse" );
}

bool e_ShovelUse( Item& item, Critter& cr, int skill )
{
    if( skill == SK_TRAPS  && item.Accessory == ACCESSORY_CRITTER ) // && item.GetProtoId() == PID_SHOVEL
    {
        Map @ map = cr.GetMap();
        if( map.IsHexPassed( cr.HexX + 2, cr.HexY + 2 ) )
        {
            string logMsg;
            Item @ hole = map.AddItem( cr.HexX + 2, cr.HexY + 2, ITEM_TREASURE_HOLE, 1 );
            SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            hole.Val4 = hole.HexX;
            hole.Val5 = hole.HexY;
            hole.Val7 = cr.WorldX;
            hole.Val8 = cr.WorldY;
            Item @ treasureMap = cr.AddItem( ITEM_TREASURE_MAP, 1 );
            treasureMap.SetLexems( "$hexX" + treasureMap.Val7 + "$hexY" + treasureMap.Val8 );
            return true;
        }
    }
    return false;
}



// powermagic
// key && key brunch script

void _KeyBunchInit( Item& item, bool firstTime )

{

    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_KeyBunchAdd" );

    item.SetEvent( ITEM_EVENT_USE, "e_KeyBunchUse" );

    item.SetEvent( ITEM_EVENT_SKILL, "e_KeyBunchSkill" );

}



bool e_KeyBunchTest( Item& item, Critter& cr, int skill )

{

    if( skill == SKILL_PUT_CONT )

    {

        cr.Say( SAY_NETMSG, "dude great!" );

        return true;

    }

    return false;

}



/*

   string@ FormatTags   (       const string&            text,

                const string@+          lexems

        )       */



bool e_KeyBunchSkill( Item& item, Critter& cr, int skill ) // 143

{

    string msg;

    switch( skill )

    {

    case SK_REPAIR:
    {
        Item@ temp = cr.AddItem( 82, 1 );
        msg = Random( 0, 51 );
        temp.SetLexems( "$KeyLex" + Random( 0, 51 ) );
    }

    case SKILL_PICK_ON_GROUND:
        if( item.Accessory == ACCESSORY_HEX )
        {
            MoveItem( item, item.GetCount(), cr );
            return true;
        }                                                                                                                /* {key = item.Id; cr.ShowScreen(SCREEN_BAG , 0, "item@KeyAddScreen"); return true;}*/

        if( item.ContainerId == cr.Id )
        {
            cr.Say( SAY_NETMSG, "that's work" );
            key = item.Id;
            cr.ShowScreen( SCREEN_CLOSE, 0, "@"    ); /* cr.ShowScreen(SCREEN_BAG , 0, "item@KeyAddScreen");*/ return true;
        }



    case SK_TRAPS: // skill == SKILL_PICK_ON_GROUND || SCREEN_BAG

    {

//     item.SetEvent(ITEM_EVENT_SKILL, "e_KeyBunchTest");
        Item@[] keys;
        item.GetItems( 0, keys );
        if( keys.length() > 0 )
        {
            cr.Action( ACTION_PICK_CRITTER, 0, null );
            for( uint8 i = 0; i < keys.length(); i++ )
            {
                MoveItem( keys[ i ], keys[ i ].GetCount(), cr );
            }
            cr.Say( SAY_NETMSG, "SUCK MY BALLS BITCH!!! " + item.Accessory );
            return true;
        }
    }
    case SK_SCIENCE:
    {
        Item@[] keys;
        item.GetItems( 0, keys );
        int[] keysId;
        if( keys.length() > 0 )
        {
            for( uint8 i = 0; i < keys.length(); i++ )
            {
                keysId[ i ] = keys[ i ].Id;
//                        msg = keys[i].Info;
//                        cr.Say(SAY_NETMSG, msg);
            }
            cr.RunClientScript( "_ItemLexRtn", 0, 0, 0, null, keysId );
        }
        return true;
    }
    }
    return false;
}



//     cr.ShowContainer(null, item, TRANSFER_FAR_CONT);

//     cr.SetEvent(CRITTER_EVENT_USE_SKILL, "e_CrUseSkill");

/*if(skill == SKILL_PUT_CONT)

   {

   cr.Say(SAY_NETMSG, "dude great!");

   }

   //     cr.ShowScreen(SCREEN_CLOSE, null, null);



   //     cr.ShowScreen(SCREEN_BAG , 0, "item@TestScreen");





   Item@[] keys;

   item.GetItems(0, keys);*//*

   for(uint8 i = 0; i < keys.length(); i++)

   {

   if(keys[i].GetType() != ITEM_TYPE_KEY)

   {

     MoveItem(keys[i], keys[i].GetCount(), cr);

   }

   cr.Say(SAY_NETMSG, "key "+keys[i].Id);

   uint         GetItems (uint specialId, Item@[]@+ items)

   }*/



bool e_KeyBunchAdd( Item& item, Critter& cr, Item@ usedItem )
{
    if( usedItem.GetType() == ITEM_TYPE_KEY )
    {
        MoveItem( usedItem, usedItem.GetCount(), item, 0 );
        cr.Say( SAY_NETMSG, "You're added some key to brunch" );
        return true;
    }
    return false;
}

uint key;

bool e_KeyBunchUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( valid( onItem ) && onItem.GetType() == ITEM_TYPE_DOOR )
    {
        Item@[] keys;
        item.GetItems( 0, keys );
        if( onItem.LockerCondition == LOCKER_LOCKED )
        {
            for( uint8 i = 0; i < keys.length(); i++ )
            {
                if( keys[ i ].LockerId == onItem.LockerId )
                {
                    onItem.LockerId = 0;
                    onItem.LockerComplexity = 0;
                    cr.Say( SAY_NETMSG, "You're ulock the door" );
                }
            }
        }
    }
    return false;
}



void KeyUseScreen( Critter& player, uint answerI, string& answerS )
{
//   Item@ item = GetItem(answerI);

//   Critter @ cr = GetCritter(item.CritId);

    if( answerS.length() != 0 )
    {
//        uint keyNumber = Random(0, 65534);
//        onDoor.LockerCondition = LOCKER_LOCKED;
//        onDoor.LockerComplexity = lockpick;
//        Log("Locked, LockerCompl = " + onDoor.LockerComplexity);
//        onDoor.LockerId = keyNumber;
//        key.LockerId = keyNumber;
        Item @ key = GetItem( player.StatBase[ ST_VAR0 ] );
        key.SetLexems( "$KeyLex" + answerS );
        key.Update();
//     key.SetEvent(ITEM_EVENT_USE, "");
    }
//   else
//   {
//     key.SetLexems("$KeyLex"+ "noNameKey");
//   }

//     @key = null;
//      @onDoor = null;
//   cr.Say(SAY_NETMSG, keyName);
}

/*

   bool e_CrUseSkill(Critter& cr, int skill, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)

   {

   if(skill == SKILL_PUT_CONT)

   {

    if(onItem.GetType() == ITEM_TYPE_KEY)

    {

      return false;

    }

    cr.Say(SAY_NETMSG, "type = "+onItem.GetType());

    return true;

   //     if(item.GetType() == ITEM_TYPE_KEY) {cr.Say(SAY_NETMSG, "work");} else {cr.Say(SAY_NETMSG, "rok");}

   }

   return false;

   }*/



void _LockerInit( Item& item, bool firstTime )
{
//   if(firstTime)
//   {
//     item.SetLexems("$KeyLex"+"unnamed key");
    item.SetEvent( ITEM_EVENT_USE, "e_LockerKeyUse" );
//   }
}



// Item @ key;
// Item @ onDoor;
// uint16 lockpick = 0;

bool ItemLockedCont( Item& item )
{
    if( item.GetType() == ITEM_TYPE_CONTAINER )
    {
        uint16 proto = item.GetProtoId();
        if( 41 < proto && proto < 46 )
        {
            return true;
        }
        if( 127 < proto && proto < 140 )
        {
            return true;
        }
        if( 180 < proto && proto < 190 )
        {
            return true;
        }
        if( 366 < proto && proto < 371 )
        {
            return true;
        }
        switch( proto )
        {
        case 245:
            return true;
        case 501:
            return true;
        case 502:
            return true;
        case 521:
            return true;
        }
    }
    return false;
}


bool e_LockerKeyUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( valid( onItem ) )
    {
        if( ( onItem.GetType() == ITEM_TYPE_DOOR || ItemLockedCont( onItem ) ) && onItem.Val1 == 0 && onItem.Val0 == 0 )
        {
            if( _LockerIsClose( onItem ) ) /*onItem.LockerCondition == LOCKER_ISOPEN*/
            {
                if( onItem.LockerCondition != LOCKER_LOCKED && onItem.LockerComplexity == 0 )
                {
//        cr.Say(SAY_NETMSG, "if passed");
//              @onDoor = onItem;
//        @key = item;
//              lockpick = cr.Skill[SK_LOCKPICK];
                    switch( item.GetProtoId() )
                    {
                    case PID_LOCKER_LOW:
                        onItem.Val0 = 1;
                        break;
                    case PID_LOCKER_MED:
                        onItem.Val0 = 2;
                        break;
                    case PID_LOCKER_HARD:
                        onItem.Val0 = 3;
                        break;
                    }

                    Item @ key = cr.AddItem( PID_BLANK_KEY, 1 );
                    uint keyNumber = Random( 0, 65534 );
                    onItem.LockerCondition = LOCKER_LOCKED;
                    onItem.LockerComplexity = item.Val0;
                    Log( "Locked, LockerCompl = " + onItem.LockerComplexity );
                    onItem.LockerId = keyNumber;
                    key.LockerId = keyNumber;
                    item.SetLexems( "$KeyLex" + "unnamed key" );
                    cr.StatBase[ ST_VAR0 ] = key.Id;
                    cr.ShowScreen( SCREEN_SAY, 0, "item@KeyUseScreen" );
                    key.Update();
                    DeleteItem( item );
                    return true;
                }
                else
                {
                    cr.Say( SAY_NETMSG, "Дверь уже заперта, сначала взломайте замок." );
                    return true;
                }
            }
            else
            {
                cr.Say( SAY_NETMSG, "Сначала закройте объект" );
                return true;
            }
        }
        else
        {
            cr.Say( SAY_NETMSG, "Этот объект нельзя запереть" );
            return true;
        }
//     cr.Say(SAY_NETMSG, "if 2 not passed");
    }

//   cr.Say(SAY_NETMSG, "all if not passed");

    return false;
}

void _LightEnvInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_LightEnvSkill" );
}

bool e_LightEnvSkill( Item& item, Critter& cr, int skill )
{
//   if(skill == SKILL_LOOT_CRITTER || skill == SKILL_PICK_ON_GROUND || skill == SKILL_PUT_CONT || skill == SKILL_TAKE_ALL_CONT)
//   {
    cr.Say( SAY_NETMSG, "Don't steal the light!" );
    return true;
//   }
//  return false;
}

// Sargonius
// Очистка голодиска
// А ещё вверху кто-то запорол кодировку русских комментов, беда.
void _EmptyDisk( Item& item, bool firstTime )
{
    if( firstTime )
        item.HolodiskNumber = 0;         // Обнуляем номер голодиска
}

bool e_FillRegistrationDocs( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.Val1 == 0 )
    {
        cr.Say( SAY_NETMSG, "Вы вписали своё имя в документ, теперь он действительный" );
        string@ name = GetPlayerName( cr.Id );
        item.SetLexems( "$ModocRegistrationName" + name );
        item.Val1 = cr.Id;
        return true;
    }
    else
    {
        string@ name = GetPlayerName( item.Val1 );
        cr.Say( SAY_NETMSG, "Документ заполнен на имя: " + name );
        return true;
    }
}

// flare


#define FLARE_BURN_TIME    ( 1000 )

// import bool GetPlayerRadius(Critter@ player, Critter@[]@ crs, uint16 radius) from "main";
import uint GetPlayers( Critter& cr, uint16 radius, bool square, Critter@[]& crs ) from "manager";

string dataName;                 // for anyData;
// uint16 flareLocId = 0;

bool ShowFlare( Critter@[] crs ) // crs[length-1] - critter who run function
{
    uint8 length = crs.length();
    Map @ map = crs[ length - 1 ].GetMap();
    if( !valid( map ) )
        return false;
    Location @ loc = map.GetLocation();
    if( !valid( loc ) || loc.AutoGarbage == false )
    {
        crs[ crs.length() - 1 ].Say( SAY_NETMSG, "Запускать ракету здесь - бессмыслеца. Найдите более подходящее место." );
        return false;
    }
    /*dataName = "flare_"+loc.Id;
       uint16[] playersId;
       if(IsAnyData(dataName)) GetAnyData(dataName, playersId);
       for(uint16 i = 0; i < length; i++)
       {
       //push_back(playersId, crs[i].Id);
       playersId.insertLast(crs[i].Id);
       if(!crs[i].IsKnownLoc(true, loc.Id)) crs[i].SetKnownLoc(true, loc.Id);
       }
       SetAnyData(dataName, playersId);
       MakeLocVisible(loc, true);
       loc.Color != COLOR_RED?loc.Color = COLOR_RED:0;*/
    uint flareLocId = loc.Id;
    CreateTimeEvent( __FullSecond + FLARE_BURN_TIME, "e_ShowFlare", flareLocId, false );
    return true;
}

uint e_ShowFlare( uint[] @ values )
{
    Location @ loc = GetLocation( values[ 0 ] );
    if( !valid( loc ) )
        return 0;
    /*uint16[] playersId;
       MakeLocVisible(loc, false);
       dataName = "flare_"+loc.Id;
       if(IsAnyData(dataName)) GetAnyData(dataName, playersId);
       uint8 length = playersId.length();
       if(length <= 0) return 0;
       Critter @ cr;
       for(uint8 i = 0; i < length; i++)
       {
       @cr = GetCritter(playersId[i]);
       if(cr.IsKnownLoc(true, loc.Id))
       cr.UnsetKnownLoc(true, loc.Id);
       }
       EraseAnyData(dataName);*/
    return 0;
}

/*void MakeLocVisible(Location& loc, bool visible)
   {
   visible?loc.GeckVisible=true:loc.GeckVisible=false;
   visible?loc.GeckCount=1:loc.GeckCount=0;
   visible?loc.AutoGarbage=false:loc.AutoGarbage=true;
   //return false; //fail
   }*/

void _FlareGun( Item& item, bool firstTime )
{
    // if(firstTime)
    // {
    item.SetEvent( ITEM_EVENT_SKILL, "e_FlareGunSkill" );
    // }
}

bool e_FlareGunSkill( Item& item, Critter& cr, int skill ) // 143
{
    if( skill != SK_TRAPS )
        return false;
    return FlareGunUse( cr, item );
}

bool FlareGunUse( Critter& cr, Item& item ) // export
{
    if( item.AmmoCount > 0 )
    {
        Critter@[] crs;
        GetGlobalMapCritters( cr.WorldX, cr.WorldY, 200, FIND_LIFE | FIND_ONLY_PLAYERS, crs );
        crs.insertLast( cr );
        if( !ShowFlare( crs ) )
            return false;
        item.AmmoCount -= 1;
        item.Update();
        cr.Say( SAY_NETMSG, "Вы запустили сигнальную ракету." );
    }
    return true;
}
/* //старая функция?? ShowFlare(crs) не будет работать с найденным.
   void testflare(Critter& cr, int p0, int p1, int p2)
   {
   Critter@[] crs;
   uint len = GetPlayers(cr, uint16(p0), p1!=0, crs);
   cr.Say(SAY_NETMSG, "вспышку увидят "+len);
   ShowFlare(crs);
   }*/
// end of flare

// gm item / quest reward

uint expBook;

void _ExpBookInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ExpBookSkill" );
    if( firstTime )
    {

        item.SetEvent( ITEM_EVENT_USE, "e_ExpBookUse" );
    }
}

bool e_ExpBookSkill( Item& item, Critter& cr, int skill )
{
    switch( skill )
    {
    case  SK_TRAPS:
        expBook = item.Id;
        cr.ShowScreen( SCREEN_SAY, 1, "ExpBookScreen" );
        break;
    case SK_REPAIR:
        item.Val1 = ( item.Val1 == 0 ? 1 : 0 );
        break;
    case SK_SCIENCE:
        cr.Say( SAY_NETMSG, "item state = " + item.Val1 );
        break;
    }
    return true;
}

void ExpBookScreen( Critter& cr, uint answerI, string& answerS )
{
    Item@ expBook0 = GetItem( expBook );
    expBook0.SetEvent( ITEM_EVENT_SKILL, "" );
    if( answerS.length() > 0 )
        StrToInt( answerS, expBook0.Val0 );
    cr.Say( SAY_NETMSG, "" + expBook0.Val0 + " " + answerI + " " + answerS );
}

bool e_ExpBookUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_NETMSG, "" + item.Val0 );
    if( item.Val0 != 0 )
    {
        if( item.Val1 == 0 )
        {
            cr.StatBase[ ST_EXPERIENCE ] += item.Val0;
        }
        else
        {
            cr.StatBase[ ST_UNSPENT_SKILL_POINTS ] += item.Val0;
            cr.Say( SAY_NETMSG, "U recive " + item.Val0 + " skill points" );
        }
        DeleteItem( item );
        return true;
    }
    return false;
}

// master key. unlock and open door
void _InitMasterKey( Item& key, bool firstTime )
{
    // if(firstTime)
    // {
    key.SetEvent( ITEM_EVENT_USE, "e_MasterKeyUse" );
    // }
}

bool e_MasterKeyUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( valid( onItem ) && ( onItem.GetType() == ITEM_TYPE_DOOR || onItem.GetType() == ITEM_TYPE_CONTAINER ) )
    {
        onItem.LockerOpen();
        onItem.LockerComplexity = 0;
//     SETFLAG(onItem.LockerCondition,LOCKER_ISOPEN);
        onItem.LockerId = 0;
//     onItem.LockerCondition = LOCKER_ISOPEN;
        SwitchState( item );
        item.Update();
    }
    return false;
}

import bool SlotMachineWork( Critter& cr, Item& onehanded, int skill, Item@ item ) from "casino";

void _InitSlotMachine( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_SlotMachineUse" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_SlotMachineOnMe" );
}

bool e_SlotMachineUse( Item& item, Critter& cr, int skill )
{
    Item@key1 = cr.GetItem( PID_SLOT_MACHINE_KEY, SLOT_HAND1 );
    switch( skill )
    {
    case SK_REPAIR:
        if( item.LockerComplexity != 0 )
        {
            cr.Say( SAY_NETMSG, "not repair needed" );
            return true;
        }
        else if( @key1 != null )
        {
            item.LockerId = key1.LockerId;
            item.LockerComplexity = 100;
            item.Update();
            cr.Say( SAY_NETMSG, "U are repair slot machine" );
        }
        else
        {
            Item @ key = cr.AddItem( PID_SLOT_MACHINE_KEY, 1 );
            uint16 rnd = Random( 1, 65534 );
            key.LockerId = rnd;
            item.LockerId = rnd;
            item.LockerComplexity = 100;
            item.Update();
            key.Update();
            cr.Say( SAY_NETMSG, "U are repair slot machine" );
            return true;
        }
    case SK_LOCKPICK:
        if( cr.StatBase[ ST_AGILITY ] * 2 > Random( 15, 25 - ( cr.StatBase[ ST_LUCK ] / 2 ) ) )
        {
            return false;
        }
        else
        {
            cr.Say( SAY_EMOTE_ON_HEAD, "do something with machine" );
            return true;
        }
    case SKILL_PICK_ON_GROUND:
        if( item.LockerComplexity == 0 || ( @key1 != null && key1.LockerId == item.LockerId ) )
            cr.ShowContainer( null, item, item.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
        else if( cr.CountItem( PID_BOTTLE_CAPS ) >= 5 )
        {
            SlotMachineWork( cr, item, skill, null );
            return true;
        }
        else
        {
            cr.Say( SAY_NETMSG, "need money" );
            return true;
        }
        // case SKILL_PUT_CONT : if(valid(item)) cr.Say(SAY_NORM, "yep"); return true;
    }

    return false;
}

bool e_SlotMachineOnMe( Item& item, Critter& cr, Item@ usedItem )
{
    if( @usedItem == null )
        return false;
    SlotMachineWork( cr, item, SKILL_PICK_ON_GROUND, usedItem );
    return true;
}

#include "_ltp.fos"

#define STR_RUSS_ROULL_LOSE    ( 9000 )
#define STR_RUSS_ROULL_WIN     ( 9001 )
/*
   void russRoulReg(Critter& player, int var, int con, int param2)
   {
        LTPREG(0,process_test)
   }

   void russRoulStart(Critter& cr, int type, int time, int param)
   {
        StartProcess(cr, uint(type), uint(param), uint(time));
   }
 */

bool ltp_roul_inited = false;
void ltp_roul_init()
{
    LTPREG( LTP_RUSSROUL, process_russ_roul )
    ltp_roul_inited = true;
}

uint process_russ_roul( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_RUSSROUL )

    if( param0 == 0 )
    {
        Item@ item = GetItem( uint( param1 ) );
        if( valid( item ) )
        {
            item.AmmoCount--;
            item.Update();
        }
        /*
		cr.StatBase[ ST_CURRENT_HP ] = 1;
        cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( Random( 0, 1 ) == 0 ? true : false ), Random( 20, 100 ), cr.HexX, cr.HexY );
		*/
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_RUSS_ROULL_LOSE );
		cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
    }
    else
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_RUSS_ROULL_WIN );
    }

    return 0;
}

void _RevolverInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_RevolverSkill" );
}

void StartRussRull(Critter& cr, uint16 item_id) {
        if( !ltp_roul_inited )
            ltp_roul_init();
        uint8 russianRoll = Random( 10, 70 ) - ( cr.StatBase[ ST_LUCK ] / 2 );
        uint  rndTime =  Random( 3, 5 ) * 1000;
        bool  roll = ( russianRoll >= 10 ) && ( russianRoll <= 20 );

        StartProcess( cr, LTP_RUSSROUL, roll ? 0 : 1, item_id, 0, rndTime );
        cr.Say( SAY_EMOTE_ON_HEAD, "Взводит курок" );
}

bool e_RevolverSkill( Item& item, Critter& cr, int skill )
{
	if( skill == SK_TRAPS ) 
	{
        if( item.AmmoCount <= 0 )
            return false;
		StartRussRull(cr, item.Id);
        return true;
	}
    return false;
}



void _InitPoliceStuff( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PoliceStuffUse" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_PoliceStuffPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_PoliceStuffHammer" );
}


bool e_PoliceStuffPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        Map @ map = cr.GetMap();
        Location @ loc = map.GetLocation();
        if( item.Val1 == 0 )
        {
            return false;
        }
        cr.Say( SAY_NETMSG, "Вы не можете перенести табличку, она закреплена." );
        return true;
    }
    return true;
}

bool e_PoliceStuffHammer( Item& item, Critter& cr, Item@ usedItem )
{
    int HammerTime = ( 11 - cr.Stat[ ST_STRENGTH ] ) * 60;
    if( item.GetProtoId() == PID_SIGN )
    {
        if( ( cr.Timeout[ TO_SK_REPAIR ] == 0 ) && ( cr.StatBase[ ST_LEVEL ] >= 6 ) )
        {
            if( valid( usedItem ) && ( usedItem.GetProtoId() == PID_SLEDGEHAMMER ) )
            {
                if( cr.CountItem( PID_IRON_PROD ) >= 1 )
                {
                    item.Val1 += 1;
                    cr.DeleteItem( PID_IRON_PROD, 1 );
                    cr.Say( SAY_NETMSG, "вы забиваете кувалдой крепежные штыри" );
                    cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + HammerTime;
                }
                else
                    cr.Say( SAY_NETMSG, "нет крепежных штырей" );
                return true;
            }
            if( valid( usedItem ) && ( usedItem.GetProtoId() == PID_CROWBAR ) )
            {
                if( item.Val1 >= 1 )
                {
                    item.Val1 -= 1;
                    cr.Say( SAY_NETMSG, "вы выдергиваете ломиком крепежные штыри" );
                    cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + HammerTime;
                }
                else
                    cr.Say( SAY_NETMSG, "табличка не закреплена" );
                return true;
            }
        }
        cr.Say( SAY_NETMSG, "у вас недостаточно сил" );
    }
    return false;
}

bool e_PoliceStuffUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_SIGN )
    {
		if( item.Val2 != 0)
		{
			cr.Say( SAY_NETMSG, "Вы убрали текст с таблички." );
			item.SetLexems( null );
			item.Update();
			return true;
		}
        if( item.Val0 == 0 )
        {
			cr.StatBase[ ST_LAST_DOOR_ID ] = item.Id;
			cr.StatBase[ ST_LAST_CONT_ID ] = item.Accessory;        
			ShowInputBoxScreen( cr, "main@unsafe_MakeDescLex#Текст таблички:", 0, INPUTBOX_CLOSE_ON_ENTER );
        }
        else
            cr.Say( SAY_NETMSG, "Табличка уже заполнена." );
    }
    return true;
}

void SignUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        item.SetLexems( "" + answerS );
        item.Val0 = 1;
        item.Update();
    }
}


import bool SetTrapOnItem( Critter& cr, Item& trap, Item& onItem ) from "trap"; // Export
import bool UseSkillOnTrappedItem(Item& trappedItem, Critter& cr,  int skill) from "trap"; // Export

void _TestTrapInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_TestTrapUse" );
}

bool e_TestTrapUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	//return false;
    if( @cr == null || @item == null || @onItem == null )
        return false;
    // if(onItem.LockerCondition == LOCKER_ELECTRO) return false;
    if( SetTrapOnItem( cr, item, onItem ) )
    {
        onItem.SetEvent( ITEM_EVENT_SKILL, "trap@UseSkillOnTrappedItem" );
        return true;
    }
    return false;

}

void _WhistInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_WhistUse" );
}

bool e_WhistUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    map.PlaySound( "whist.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    cr.Say( SAY_EMOTE_ON_HEAD, "Свестит в свисток." );
    return true;
}

void _InitRpNamer( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_RpNamerUse" );
}

bool e_RpNamerUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_INFOPAD )
    {
        ShowInputBoxScreen( cr, "item@unsafe_RpNamerUseScreen#Ваше описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
        cr.StatBase[ ST_VAR0 ] = item.Id;
    }
    return true;
}

void unsafe_RpNamerUseScreen( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	RpNamerUseScreen( player, 0, param3 );
}


void RpNamerUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        player.SetLexems( answerS );
        if(valid(item)) _SubItem( item, 1 );
    }
}

void _music_fleita( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_fleitaUse" );
}

bool e_fleitaUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    if( Random( 1, 5 ) > 4 )
        map.PlaySound( "flute.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 3 )
        map.PlaySound( "flute2.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 2 )
        map.PlaySound( "flute3.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 1 )
        map.PlaySound( "flute4.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 0 )
        map.PlaySound( "flute5.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    cr.Say( SAY_EMOTE_ON_HEAD, "Играет на флейте." );
    Location @ loc = map.GetLocation();
    if( ( loc.WorldX <= 50 ) || ( loc.WorldX >= 150 ) || ( loc.WorldY <= 50 ) || ( loc.WorldY >= 150 ) )
    {
        cr.Say( SAY_NETMSG, "Вы слишком далеко от фермы." );
        return true;
    }
    if( ( loc.WorldX >= item.Val2 - 20 ) && ( loc.WorldX <= item.Val2 + 20 ) && ( loc.WorldY >= item.Val3 - 20 ) && ( loc.WorldY <= item.Val3 + 20 ) )
    {
        cr.Say( SAY_NETMSG, "Тут брамины уже паслись." );
        return true;
    }
    if( loc.Id >= 100 && loc.Id <= 139 )
    {
        cr.Say( SAY_NETMSG, "Начинаете пасти стадо." );
        item.Val1 = map.Id;
        item.Val2 = loc.WorldX;
        item.Val3 = loc.WorldY;
        cr.AddTimeEvent( "cte_BrahminEat", ( 60 * 3 ) * __TimeMultiplier, CTE_WORK, 0 );
    }
    return true;
}

uint cte_BrahminEat( Critter& cr, int identifier, uint& rate )
{
    Critter@[] brahmins;
    Item@ flute = cr.GetItem( PID_FLUTE, SLOT_HAND1 );
    Map @ map = cr.GetMap();
    if( !valid( flute ) || !valid( map ) )
        return 0;
    if( ( map.GetCritters( NPC_PID_Brahmin, FIND_LIFE_AND_KO | FIND_ONLY_NPC, brahmins ) > 0 ) && map.Id == uint( flute.Val1 ) )
    {
        for( uint i = 0, ii = brahmins.length(); i < ii; i++ )
        {
            brahmins[ i ].StatBase[ ST_VAR5 ] += 1;
        }
        cr.Say( SAY_NETMSG, "Брамины кажется насытились тут" );
    }
    return 0;
}

void _dosimetr( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_dosimetrUse" );
}

bool e_dosimetrUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    cr.Say( SAY_EMOTE_ON_HEAD, "Производит замер." );
    Location @ loc = map.GetLocation();
    if( ( loc.WorldX >= item.Val1 - 20 ) && ( loc.WorldX <= item.Val1 + 20 ) && ( loc.WorldY >= item.Val2 - 20 ) && ( loc.WorldY <= item.Val2 + 20 ) )
    {
        cr.Say( SAY_NETMSG, "Кажется место правильное, остается только подождать несколько минут." );
        item.Val3 = map.Id;
        cr.AddTimeEvent( "cte_dosimetrUse", 60 * 3, CTE_WORK, 0 );
    }
    return true;
}

uint cte_dosimetrUse( Critter& cr, int identifier, uint& rate )
{
    Item@ dosimetr = cr.GetItem( PID_DOSIMETR, SLOT_HAND1 );
    Map @ map = cr.GetMap();
    if( !valid( dosimetr ) || !valid( map ) )
        return 0;
    if( map.Id == uint( dosimetr.Val3 ) )
    {
        cr.Say( SAY_NETMSG, "Индикатор изменил цвет на желтый, можно возвращаться." );
        DeleteItem( dosimetr );
        cr.AddItem( PID_DOSIMETR_USED, 1 );
    }
    else
        cr.Say( SAY_NETMSG, "Время прошло, но индикатор не сменил цвет, кажется мы сделали что-то неправильно." );
    return 0;
}

void _TraderBadge( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_traderbadgeUse" );
}

bool e_traderbadgeUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "Показывает значек торговца" );
    return true;
}

void _PochtaBadge( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PochtaBadgeUse" );
}

bool e_PochtaBadgeUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "Показывает значек почтальона" );
    return true;
}

void _kosakInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_kosakUse" );
}

bool e_kosakUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    if( Random( 0, 1 ) > 0 )
        map.PlaySound( "drugs1.wav", cr.HexX, cr.HexY, 1 );
    else
        map.PlaySound( "drugs2.wav", cr.HexX, cr.HexY,  1 );
    cr.Say( SAY_EMOTE_ON_HEAD, "Раскуривает косяк" );
    cr.StatBase[ ST_EXPERIENCE ] += Random( 500, 1000 );
	cr.StatBase[ ST_RADIATION_LEVEL ] += Random( 0, 2 );
	AffectPoison( cr, Random( 10, 20 ) );
	cr.StatBase[ ST_HUNGER ] -= Random( 4, 8 );
	cr.StatBase[ ST_THRIST ] -= Random( 4, 8 );
    cr.DeleteItem( PID_KOSYAK, 1 );
    return true;
}

import void Warn( Critter& admin, int param0, int param1, int param2 )  from "warning"; // ErlKing
import void say( Critter& player, int param0, int param1, int param2 )  from "gm";      // ErlKing

void _InitGmPistol( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_GmPistolUse" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_GmPistolPick" );
    item.SetEvent( ITEM_EVENT_ATTACK, "e_GmPistolAttack" );
}

bool e_GmPistolUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_GM_PISTOL && cr.GetAccess() >= ACCESS_MODER )
    {
        cr.ShowScreen( SCREEN_DIALOGBOX, 3, "answer_GmPistol_GM_menu" );
        cr.Say( SAY_DIALOGBOX_TEXT, "Что желаешь хозяин?" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "скачать help" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "скачать warn" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "очистить help" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "очистить warn" );
    }
    return true;
}

void answer_GmPistol_GM_menu( Critter& cr, uint answerI, string& answerS )
{
    if( !valid( cr ) )
        return;
    if( answerI == 0 )
    {
        file f;
        if( f.open( "logs\\help_pleads.txt", "r" ) >= 0 )
        {
            string word = "";
            uint   pos = 0;
            f.setPos( 0 );
            while( !f.isEndOfFile() )
            {
                pos = f.getPos();
                if( pos == 0 )
                {
                    f.readLine( word );
                    cr.RunClientScript( "client_main@loger", 0, 0, 0, word, null );
                }
                else
                {
                    f.readLine( word );
                    cr.RunClientScript( "client_main@loger", 1, 0, 0, word, null );
                }
            }
            f.close();
        }
        else
            Log( "can't open!" );
    }
    if( answerI == 1 )
    {
        file f;
        if( f.open( "logs\\warnings.txt", "r" ) >= 0 )
        {
            string word = "";
            uint   pos = 0;
            f.setPos( 0 );
            while( !f.isEndOfFile() )
            {
                pos = f.getPos();
                if( pos == 0 )
                {
                    f.readLine( word );
                    cr.RunClientScript( "client_main@loger", 0, 1, 0, word, null );
                }
                else
                {
                    f.readLine( word );
                    cr.RunClientScript( "client_main@loger", 1, 1, 0, word, null );
                }
            }
            f.close();
        }
        else
            Log( "can't open!" );
    }
    if( answerI == 2 )
    {
        file f;
        if( f.open( "logs\\help_pleads.txt", "w" ) >= 0 )
        {
            // f.writeString("");
            f.close();
        }
        else
            Log( "can't open!" );
    }
    if( answerI == 3 )
    {
        file f;
        if( f.open( "logs\\help_pleads.txt", "w" ) >= 0 )
        {
            // f.writeString("");
            f.close();
        }
        else
            Log( "can't open!" );
    }
}

bool e_GmPistolPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        DeleteItem( item );
    }
    return false;
}

bool e_GmPistolAttack( Item& item, Critter& cr, Critter& target )
{
    if( cr.IsPlayer() )
    {
        if( cr.GetAccess() >= ACCESS_MODER )
        {
            cr.StatBase[ ST_VAR0 ] = target.Id;
            cr.ShowScreen( SCREEN_DIALOGBOX, 5, "answer_GmPistolAttack_GM" );
            cr.Say( SAY_DIALOGBOX_TEXT, "Что желаешь хозяин?" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "предупреждение" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "+ опыт" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "+ скиллпоинты" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "+ деньги" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "+ нокаут" );
            return true;
        }
        else
        {
            cr.StatBase[ ST_VAR0 ] = target.Id;
            cr.ShowScreen( SCREEN_DIALOGBOX, 7, "answer_GmPistolAttack_player" );
            cr.Say( SAY_DIALOGBOX_TEXT, "Выберите предупреждение" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "сленг" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "повергейминг" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "выход из роли" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "мародерство" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "клептомания" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 5 ), "метагейм" );
            cr.Say( SAY_DIALOGBOX_BUTTON( 6 ), "мультоводство" );
            return true;
        }
    }
    return true;
}

import uint GetAllPlayers( Critter@[]& crs ) from "manager";

void answer_GmPistolAttack_player( Critter& cr, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( cr.Stat[ ST_VAR0 ] );
    if( target is null or target.IsNpc() )
    {
        cr.Say( SAY_NETMSG, "Игрок не найден." );
        return;
    }
    if( cr.Stat[ ST_VAR5 ] > 3 )
        return;
    cr.StatBase[ ST_VAR5 ] += 1;
    string plead;
    if( answerI == 0 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "НА СЕРВЕРЕ ЗАПЕРЩЕН СЛЕНГ И НЕИГРОВОЕ ОБЩЕНИЕ" );
        plead = " - сленг";
    }
    else if( answerI == 1 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "НЕ СТРОЙТЕ ИЗ СЕБЯ РЕМБО, ПОМНИТЕ ОБ ИНСТИНКТЕ САМОСОХРАНЕНИЯ" );
        plead = " - рембо";
    }
    else if( answerI == 2 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "ПРИДЕРЖИВАЙТЕСЬ СВОЕЙ ИГРОВОЙ РОЛИ" );
        plead = " - несоответствие роли";
    }
    else if( answerI == 3 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "БЕЗСИСТЕМНОЕ ЛУТАНИЕ ТРУПОВ ЭТО МАРОДЕРСТВО, ОСТАНОВИТЕСЬ" );
        plead = " - мародерство";
    }
    else if( answerI == 4 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "НЕ ШАРЬТЕСЬ ГДЕ ПОПАЛО, ПРИСТРЕЛЯТ ЗА ВОРОВСТВО" );
        plead = " - клептомания";
    }
    else if( answerI == 5 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "ИСПОЛЬЗОВАНИЕ ИНФОРМАЦИИ ПОЛУЧЕННОЙ НЕИГРОВЫМ ПУТЕМ ЗАПРЕЩЕНО" );
        plead = " - метагейм";
    }
    else if( answerI == 6 )
    {
        target.ShowScreen( SCREEN_DIALOGBOX, 0, "answer_NULL" );
        target.Say( SAY_DIALOGBOX_TEXT, "ЗАПРЕЩЕНО ВЗАИМОДЕЙСТВИЕ МЕЖДУ СВОИМИ ПЕРСОНАЖАМИ" );
        plead = " - мультоводство";
    }
    if( plead != "" )
    {
        cr.Say( SAY_NETMSG, "предупреждение выдано" );
        Critter@[] crs;
        GetAllPlayers( crs );
        string str = "жалоба от |0xFFFF0000 <|0xFFFFFF00 " + GetPlayerName( cr.Id ) + "(" + cr.Id + ") на " + GetPlayerName( target.Id ) + "(" + target.Id + ")|0xFFFF0000 > |0xFFBB33CC " + plead;
        for( uint i = 0, j = crs.length(); i < j; i++ )
        {
            if( crs[ i ] is null or crs[ i ].GetAccess() < ACCESS_MODER )
                continue;
            crs[ i ].Say( SAY_NETMSG, str );
        }
        file f;
        if( f.open( "logs\\warnings.txt", "a" ) >= 0 )
        {
            f.writeString( "жалоба от " + GetPlayerName( cr.Id ) + "\t " + cr.Id + "\t на " + GetPlayerName( target.Id ) + "\t" + target.Id + "\t" + plead + "\n" );
            f.close();
        }
    }
}

void answer_NULL( Critter& cr, uint answerI, string& answerS )
{
    return;
}

void answer_GmPistolAttack_GM( Critter& cr, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( cr.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerI == 0 ) // предупреждение
    {
        Warn( cr, target.Id, 0, 0 );
    }
    else if( answerI == 1 ) // наградить опытом
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@GmPistol_exp" );
    }
    else if( answerI == 2 ) // наградить скилами
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@GmPistol_skill" );
    }
    else if( answerI == 3 ) // наградить скилами
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@GmPistol_money" );
    }
    else if( answerI == 4 ) // нокаут на
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@GmPistol_knockdown" );
    }
}

void GmPistol_exp( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.StatBase[ ST_EXPERIENCE ] += number;
        player.Say( SAY_NETMSG, "вы выдали " + number + " опыта игроку " + target.Id );
    }
}

void GmPistol_skill( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.StatBase[ ST_UNSPENT_SKILL_POINTS ] += number;
        player.Say( SAY_NETMSG, "вы выдали " + number + " скиллпоинтов игроку " + target.Id );
    }
}

void GmPistol_money( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.AddItem( PID_BOTTLE_CAPS, number );
        player.Say( SAY_NETMSG, "вы выдали " + number + " монет, персонажу " + target.Id );
    }
}

void GmPistol_knockdown( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( Random( 0, 1 ) == 0 ? true : false ), number, target.HexX, target.HexY );
        player.Say( SAY_NETMSG, "вы уронили игрока " + target.Id + " на " + number );
    }
}

void _InitRPStuff( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_RPStuffUse" );
}

bool e_RPStuffUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery ) { //Тело функции полностью переделано!
    if( item.Val0 == 0 ) {
        item.Val0 = 1;
        if( cr.Stat [ST_INTELLECT] <= 3 ) {
            cr.Say( SAY_NETMSG, "Вы без понятия, что делать с этим предметом." );
            return true;
        }
        if( cr.Stat [ST_INTELLECT] <= 5 ) {
            cr.StatBase[ ST_VAR0 ] = item.Id;
            cr.ShowScreen( SCREEN_SAY, 0, "item@RPStuffUseScreen" );
            return true;
        }
        cr.StatBase[ ST_LAST_DOOR_ID ] = item.Id;
        cr.StatBase[ ST_LAST_CONT_ID ] = item.Accessory;        
        ShowInputBoxScreen( cr, "main@unsafe_MakeDescLex#Описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
    } else {
        cr.Say( SAY_NETMSG, "Прийдётся пораскинуть мозгами, что бы найти способ изменить этот предмет." );
    }
    return true;
}

void RPStuffUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        uint16 itemPid = item.GetProtoId();

        switch( itemPid )
        {
        case PID_RPSTUFF1:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF2:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF3:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF4:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPGUN1:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPGUN2:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPGUN3:
            item.SetLexems( "" + answerS );
            break;
        }

        item.Val0 = 1;
        item.Update();
    }
}

void _InitPuti( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_DROP, "e_PutiDrop" );
}

void e_PutiDrop( Item& item, Critter& cr )
{
    if( cr.CountItem( PID_ROPE_USED ) != 0 || cr.CountItem( PID_HANDCUFFS_USED ) != 0 )
    {
        cr.AddItem( PID_PUTI, 1 );
        cr.Say( SAY_NETMSG, "Вы не можете снять путы" );
    }
    DeleteItem( item );
}

// depracated
void _InitCodeDoor( Item& item, bool firstTime )
{
    Log( "Depracated function item@_InitCodeDoor at item.Id " + item.Id );
    // item.SetEvent(ITEM_EVENT_SKILL, "e_CodeDoorSkill");
    // item.LockerCondition = LOCKER_ELECTRO;
}
/*
   bool e_CodeDoorSkill(Item& item, Critter& cr, int skill)
   {
        if(skill == SKILL_PICK_ON_GROUND)
        {
                if(_LockerIsClose(item))
                {

                        cr.RunClientScript("client_screen_codedoor@ShowScreen", item.Id, item.Val1, 0, "Введите код", null);
                        return true;
                }
        }
   return false;
   }*/

void _InitAidKit( Item& item, bool firstTime )
{
    item.SetLexems( "Медикаментов там " + SetupAidLeX( item.Indicator ) + "." );
}

string SetupAidLeX( uint8 aidValue )
{
    string resultTemp = "";

    if( aidValue == 100 )
        resultTemp = "полная сумка";
    else if( aidValue > 80 )
        resultTemp = "достаточно";
    else if( aidValue > 60 )
        resultTemp = "чуть больше половины";
    else if( aidValue > 40 )
        resultTemp = "немного меньше половины";
    else if( aidValue > 20 )
        resultTemp = "совсем не много";
    else if( aidValue > 10 )
        resultTemp = "на дне";
    else if( aidValue > 0 )
        resultTemp = "практически нет";
    else if( aidValue == 0 )
        resultTemp = "нет";

    return resultTemp;
}

void _AutoDoorInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() == PID_AUTODOOR )
        item.SetEvent( ITEM_EVENT_WALK, "e_AutoDoorWalk" );
}

void e_AutoDoorWalk( Item& item, Critter& cr, bool entered, uint8 dir )
{
    Item@ door = GetItem( item.Val1 );
    if( !valid( door ) )
    {
        DeleteItem( item );
        return;
    }
	
	Map @ map = cr.GetMap();
	if( entered )
    {
        if( !FLAG( door.LockerCondition, LOCKER_ISOPEN ) && 
		    !FLAG( door.LockerCondition, LOCKER_LOCKED ) && 
			!(door.LockerCondition == LOCKER_ELECTRO) )
        {
			if( map.GetData(24) > 0 )
				door.LockerOpen();
			else
				if( cr.GetAccess() > ACCESS_CLIENT )
					map.SetText( item.HexX, item.HexY, COLOR_GRAY, ":щёлк:" );
        }
    }
    else
    {
        if( map.GetData(24) > 0 )
        {
            uint16 x = 0;
            uint16 y = 0;
            @ map = door.GetMapPosition( x, y );
            if( map.GetCrittersHex( x, y, 1, FIND_LIFE, null ) == 0 ) door.LockerClose();
        }
		else
			if( cr.GetAccess() > ACCESS_CLIENT )
				map.SetText( item.HexX, item.HexY, COLOR_GRAY, ":клац:" );
    }
}

void _PillsInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PillsUse" );
}

bool e_PillsUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "принимает таблетки" );
    if( item.GetProtoId() == PID_HEART_PILLS )
    {
        cr.AddTimeEvent( "cte_ClearOverDose", REAL_MINUTE( 1 ), CTE_CLEARING_BLOOD, 0 );
        _SubItem( item, 1 );
        return true;
    }
    else if( item.GetProtoId() == PID_PILLS )
    {
		cr.AddTimeEvent( "cte_ClearingBlood", REAL_MINUTE( 1 ), CTE_CLEARING_BLOOD, 59 );
        _SubItem( item, 1 );
        return true;
    }
    return true;
}

uint cte_ClearOverDose( Critter& cr, int identifier, uint& rate )
{
	string[] text = { "ша голова проясняется", "ше сердце перестаёт колоть", "м стало намного легче", "с уже не так сильно колотит от передоза лекарствами" };
	cr.Say( SAY_NETMSG, "Ва"+text[Random(0,text.length()-1)]+"." );

	AffectPoison( cr, cr.StatBase[ ST_OVERDOSE ] * Random( 2, 6 ) );
	
	cr.StatBase[ ST_OVERDOSE ] /= 3;
	return 0;
}

uint cte_ClearingBlood( Critter& cr, int identifier, uint& rate )
{
	if( cr.StatBase[ ST_BLOOD_TOXIC ] > 0 ) {

		string[] text = { "а температура снижается", "е дыхание облегчилось", "и внутренности меньше болят", "а голова слегка проясняется", "е тело стало не так сильно потеть" };
		cr.Say( SAY_NETMSG, "Ваш"+text[Random(0,text.length()-1)]+"." );

		AffectPoison( cr, Random( 4, 8 ) );

		cr.StatBase[ ST_BLOOD_TOXIC ] -= Random( 0, 1 );

		//cr.StatBase[ ST_EXPERIENCE ] += 100;
		
	} else {
		if( FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLOOD_TOXIC ) ) {
			cr.Say( SAY_NETMSG, "Заражение крови вылечено." );
			UNSETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLOOD_TOXIC );
		}
	}

	rate--;
    return rate > 0 ? REAL_MINUTE( 1 ) : 0;
}

void _MercsSignInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_MercsSign" );
}

bool e_MercsSign( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "показывает плакат" );
    return true;
}

void _MercsSign2Init( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_MercsSign2" );
}

bool e_MercsSign2( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "показывает нашивку Черной Стаи" );
    return true;
}

void _InitEmptyHypo( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_EmptyHypoUse" );
}

bool e_EmptyHypoUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    bool onSelf = ( !valid( onCritter ) && !valid( onItem ) && !valid( onScenery ) );
    if( onSelf )
    {
        Item @ hypo = cr.AddItem( PID_HYPO_BLOOD, 1 );
        hypo.Val1 = cr.Id;
        hypo.Val2 = cr.Stat[ ST_TOXIC ];
        hypo.Val3 = cr.Stat[ ST_DESEASE ];
        hypo.Val4 = cr.Stat[ ST_BODY_TYPE ];
        hypo.Val5 = cr.Stat[ ST_POISONING_LEVEL ];
        hypo.Val6 = cr.Stat[ ST_RADIATION_LEVEL ];
        cr.StatBase[ ST_VAR0 ] = hypo.Id;
        cr.ShowScreen( SCREEN_SAY, 0, "item@HypoUseScreen" );
        hypo.Update();
        cr.DeleteItem( PID_HYPODERMIC_NEEDLE, 1 );
        cr.Say( SAY_NETMSG, "Вы взяли у себя образец крови." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Берет образец крови" );
        return true;
    }
    else if( cr.IsPlayer() && valid( cr ) && valid( onCritter ) )
    {
        if( cr.Timeout[ TO_BATTLE ] > 0 || onCritter.Timeout[ TO_BATTLE ] > 0 )
        {
            cr.Say( SAY_NETMSG, "Это неуместно" );
            return true;
        }
        Item @ hypo = cr.AddItem( PID_HYPO_BLOOD, 1 );
        hypo.Val1 = onCritter.Id;
        hypo.Val2 = onCritter.Stat[ ST_TOXIC ];
        hypo.Val3 = onCritter.Stat[ ST_DESEASE ];
        hypo.Val4 = onCritter.Stat[ ST_BODY_TYPE ];
        hypo.Val5 = onCritter.Stat[ ST_POISONING_LEVEL ];
        hypo.Val6 = onCritter.Stat[ ST_RADIATION_LEVEL ];
        cr.StatBase[ ST_VAR0 ] = hypo.Id;
        cr.ShowScreen( SCREEN_SAY, 0, "item@HypoUseScreen" );
        hypo.Update();
        cr.DeleteItem( PID_HYPODERMIC_NEEDLE, 1 );
        cr.Say( SAY_NETMSG, "Вы взяли образец крови." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Берет образец крови" );
        return true;
    }
    else
        cr.Say( SAY_NETMSG, "Это неуместно" );
    return true;
}

void HypoUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ Hypo = GetItem( player.StatBase[ ST_VAR0 ] );
        Hypo.SetLexems( "$HypoLex" + answerS );
        Hypo.Update();
    }
}

void _InitBloodHypo( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_BloodHypoUse" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_BloodHypoSkill" );
}

import void ApplyDesease( Critter& player, int param0, int param1 ) from "morphes";

bool e_BloodHypoUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    bool onSelf = ( !valid( onCritter ) && !valid( onItem ) && !valid( onScenery ) );
    if( onSelf )
    {
        if( item.Val3 != 0 )
        {
            if( item.Val1 == 0 && cr.StatBase[ ST_DESEASE ] <= item.Val3 )
            {
                if( cr.GetTimeEvents( 7, null, null, null ) > 0 && cr.Stat[ ST_TOXIC ] > 0 )
                {
                    cr.EraseTimeEvents( 7 );
                    cr.StatBase[ ST_TOXIC ] = 0;
                }
                cr.StatBase[ ST_DESEASE ] = item.Val3;
            }
            else if( item.Val2 != 0 || Random( 0, 1 ) > 0 )
                ApplyDesease( cr, cr.Id, item.Val3 );
            else if( cr.StatBase[ ST_DESEASE ] < item.Val3 )
                cr.StatBase[ ST_DESEASE ] = item.Val3;
        }
        cr.Say( SAY_NETMSG, "Вы вкололи шприц себе." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Вкалывает шприц" );
        DeleteItem( item );
		cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
        return true;
    }
    else if( cr.IsPlayer() && valid( cr ) && valid( onCritter ) )
    {
        if( cr.Timeout[ TO_BATTLE ] > 0 || onCritter.Timeout[ TO_BATTLE ] > 0 )
        {
            cr.Say( SAY_NETMSG, "Это неуместно" );
            return true;
        }
        if( item.Val3 != 0 && onCritter.IsPlayer() )
        {
            if( item.Val1 == 0 && onCritter.StatBase[ ST_DESEASE ] <= item.Val3 )
            {
                if( onCritter.GetTimeEvents( 7, null, null, null ) > 0 && onCritter.Stat[ ST_TOXIC ] > 0 )
                {
                    onCritter.EraseTimeEvents( 7 );
                    onCritter.StatBase[ ST_TOXIC ] = 0;
                }
                onCritter.StatBase[ ST_DESEASE ] = item.Val3;
            }
            else if( item.Val2 != 0 || Random( 0, 1 ) > 0 )
                ApplyDesease( cr, onCritter.Id, item.Val3 );
            else if( onCritter.StatBase[ ST_DESEASE ] < item.Val3 )
                onCritter.StatBase[ ST_DESEASE ] = item.Val3;
        }
        cr.Say( SAY_NETMSG, "Вы вкололи шприц." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Вкалывает шприц" );
        DeleteItem( item );
		cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
        return true;
    }
    else
        cr.Say( SAY_NETMSG, "Это неуместно" );
    return true;
}

bool e_BloodHypoSkill( Item& item, Critter& cr, int skill )
{
    if( skill == SK_SCIENCE )
    {
        int body = item.Val4;
        if( _CritCountItem( cr, PID_DOCTORS_BAG ) == 0 )
        {
            cr.Say( SAY_NETMSG, "Вам нужны соответствующие инструменты для анализа крови." );
            return true;
        }
        else if( cr.Skill[ SK_SCIENCE ] > 50 || cr.Skill[ SK_SCIENCE ] > 50 )
        {
            switch( body )
            {
            case 0:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 1:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 2:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 3:
                cr.Say( SAY_NETMSG, "Это кровь супермутанта." );
                break;
            case 4:
                cr.Say( SAY_NETMSG, "Это кровь гуля." );
                break;
            case 5:
                cr.Say( SAY_NETMSG, "Это кровь брамина." );
                break;
            case 6:
                cr.Say( SAY_NETMSG, "Это кровь скорпиона" );
                break;
            case 7:
                cr.Say( SAY_NETMSG, "Это кровь крысы" );
                break;
            case 8:
                cr.Say( SAY_NETMSG, "Это кровь летуна" );
                break;
            case 9:
                cr.Say( SAY_NETMSG, "Это кровь кентавра" );
                break;
            case 10:
                cr.Say( SAY_NETMSG, "Это гидравлическая жидкость, непонятно как она попала в шприц." );
                break;
            case 11:
                cr.Say( SAY_NETMSG, "Это кровь собаки" );
                break;
            case 12:
                cr.Say( SAY_NETMSG, "Это жидкость мантиса" );
                break;
            case 13:
                cr.Say( SAY_NETMSG, "Это кровь смертокогтя" );
                break;
            case 14:
                cr.Say( SAY_NETMSG, "Это жидкость из растения" );
                break;
            case 15:
                cr.Say( SAY_NETMSG, "Это кровь гекко" );
                break;
            case 16:
                cr.Say( SAY_NETMSG, "Это кровь чужого" );
                break;
            }
            if( cr.Skill[ SK_SCIENCE ] > 100 && body <= 4 )
            {
                if( item.Val2 == 0 )
                    cr.Say( SAY_NETMSG, "Уровень лейкоцитов в норме." );
                else if( item.Val2 <= 50 )
                    cr.Say( SAY_NETMSG, "В крови присутствуют следы воздействия какого-то вируса." );
                else
                    cr.Say( SAY_NETMSG, "Заметны образования в крови, видимо воздействие вируса было довольно продолжительным." );
            }
        }
        return true;
    }
    return false;
}

void _InitPackage( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_DROP, "e_PackageDrop" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_PackageMove" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_PackagePick" );
}

void e_PackageDrop( Item& item, Critter& cr )
{
    cr.ModeBase[ MODE_NO_WALK ] = 0;
    cr.ModeBase[ MODE_NO_RUN ] = 0;
}

void e_PackageMove( Item& item, Critter& crit, uint8 fromSlot )
{
    if( item.CritSlot == SLOT_HAND1 )
    {
        crit.ModeBase[ MODE_NO_WALK ] = 0;
        crit.ModeBase[ MODE_NO_RUN ] = 1;
    }
    if( fromSlot == SLOT_HAND1 )
    {
        crit.ModeBase[ MODE_NO_WALK ] = 1;
        crit.ModeBase[ MODE_NO_RUN ] = 1;
        crit.Say( SAY_NETMSG, "Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести." );
    }
}

bool e_PackagePick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        if( _CritCountItem( cr, PID_PACKAGE ) == 0 )
        {
            cr.ModeBase[ MODE_NO_WALK ] = 1;
            cr.ModeBase[ MODE_NO_RUN ] = 1;
            cr.Say( SAY_NETMSG, "Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести." );
            return false;
        }
        return true;
    }
    return true;
}

void _InitCompas( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_CompasUse" );
}

bool e_CompasUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    string output = "";

    Location @ loc = GetLocation( 5 );
    if( loc !is null )
    {
        int x = cr.WorldX * 0.1 - loc.WorldX * 0.1, y = cr.WorldY * 0.1 - loc.WorldY * 0.1;
        if( cr.Skill[ SK_OUTDOORSMAN ] < 100 )
        {
            output += "Модок находиться : ";

            if( y > 0 )
                output += "Северо-";
            else if( y < 0 )
                output += "Юго-";
            if( x > 0 )
                output += "Западней";
            else if( x < 0 )
                output += "Восточней";
            else if( y > 0 )
                output = "Модок находиться : Севернее";
            else if( y < 0 )
                output = "Модок находиться : Южнее";
            else
                output = "Стрелка постоянно крутится";
        }
        if( cr.Skill[ SK_OUTDOORSMAN ] >= 100 )
        {
            output = "Координаты : x=" + x + ", y=" + y;
        }
    }
    else
        output = "Компас заклинило.";

    cr.Say( SAY_NETMSG, output );

    return false;
}

void Item_SetFrame( Item& item, uint8 frame ) // Sprite& sprite) // ItemCl& itemCl
{
    item.AnimStayBegin      = frame;
    item.AnimStayEnd        = frame;
    item.AnimShowBegin      = frame;
    item.AnimShowEnd        = frame;
    item.AnimHideBegin      = frame;
    item.AnimHideEnd        = frame;

    return;
}

void _InitScanner( Item& item, bool firstTime )
{
    SETFLAG(item.Flags, ITEM_CAN_USE);
    item.SetEvent( ITEM_EVENT_USE, "UseScanner" );
}

uint[] rad = {10, 25, 50, 100, 200};

bool UseScanner(Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)
{
    if( @onCritter is null && @onItem is null && @onScenery is null && @cr.GetMap() !is null )
	{
        uint16 count = 0;
        if( cr.Skill[ SK_SCIENCE ] < 20 )
            cr.Say( SAY_NETMSG, "Вы не умеете пользоваться этим предметом" );
        if( cr.Skill[ SK_SCIENCE ] >= 20 )
            ++count;
        if( cr.Skill[ SK_SCIENCE ] >= 35 )
            ++count;
        if( cr.Skill[ SK_SCIENCE ] >= 50 )
            ++count;
	    if( cr.Skill[ SK_SCIENCE ] >= 60 )
            ++count;
        if( cr.Skill[ SK_SCIENCE ] >= 75 )
            ++count;

        cr.ShowScreen( SCREEN_DIALOGBOX, count, "item@answer_SCANNER" );
        cr.Say( SAY_DIALOGBOX_TEXT, "Выберите радиус сканируемой зоны" );

        for( uint8 i = 0; i < count; i++ )
        {
            cr.Say( SAY_DIALOGBOX_BUTTON( i ), "" + rad[ i ] );
        }
        return true;
	}
	else return true;
}

void Find(uint rad, Critter& cr, Map& map)
{
	cr.Wait( rad * 50 );
	cr.Say( SAY_NETMSG, "В радиусе " + rad + " метров обнаружено " + map.GetCrittersHex(cr.HexX, cr.HexY, rad, FIND_LIFE, null) + " живых организмов" );
}

void answer_SCANNER( Critter& cr, uint answerI, string& answerS)
{
	Map @map = cr.GetMap();
	if( @map !is null )
		Find(rad[answerI], cr, map);
}

void ProccessFood( Critter& cr, Item& item )
{
	uint8  hungerBonus = item.Proto.Food_Restore;
	uint8  thristBonus = item.Proto.Food_Thrist;
	
	int Hb = cr.StatBase[ ST_HUNGER ];
	int Tb = cr.StatBase[ ST_THRIST ];
	
	cr.StatBase[ ST_HUNGER ] += hungerBonus;
	cr.StatBase[ ST_THRIST ] += thristBonus;
	
	int Ha = CLAMP( cr.StatBase[ ST_HUNGER ], 0, 100 );
	int Ta = CLAMP( cr.StatBase[ ST_THRIST ], 0, 100 );

    uint flag = item.Proto.Food_Flags;
	
	bool isPoison = FLAG( FOOD_POISONED, flag );
	bool isRad = FLAG( FOOD_RADIOACTIVE, flag );

	if( !isPoison && cr.StatBase[ ST_POISONING_LEVEL ] > 0 ) 
		cr.StatBase[ ST_POISONING_LEVEL ] -= ( thristBonus + hungerBonus ) * 0.25;
	if( !isRad && cr.StatBase[ ST_RADIATION_LEVEL ] > 0 ) 
		cr.StatBase[ ST_RADIATION_LEVEL ] -= ( thristBonus + hungerBonus ) * 0.1;

	int Hd = Ha - Hb;
	int Td = Ta - Tb;
	
	//int exp = ( Hd + Td ) * ( isPoison ? 2 : 1 ) * ( isRad ? 2 : 1 ) * 50;
	//cr.StatBase[ ST_EXPERIENCE ] += exp;
	
	cr.StatBase[ ST_THRIST ] += thristBonus;
	//cr.StatBase[ ST_THRIST ] -= hungerBonus / 3;

	uint PID = item.GetProtoId();
	
	if (( PID == PID_BOTTLE_FULL )|| (PID == PID_BOTTLE_DIRTY_FULL)) cr.AddItem( PID_BOTTLE_EMPTY, 1 );
	if ( 	
		PID == PID_ANTIDOTE ||
		PID == PID_GLASS_BOTTLE_FULL ||
		PID == PID_NUKA_COLA ||
		PID == PID_BEER ||
		PID == PID_BOOZE ||
		PID == PID_GAMMA_GULP_BEER ||
		PID == PID_ROENTGEN_RUM ||
		PID == PID_ROT_GUT ||
		PID == PID_GLASS_BOTTLE_DIRTY_FULL
		)
		cr.AddItem( PID_BOTTLE_GLASS, 1 );
	
	if ( 	
		PID == PID_STIMPAK ||
		PID == PID_RADAWAY ||
		PID == PID_PSYCHO ||
		PID == PID_SUPER_STIMPAK ||
		PID == PID_HYPO
		)
		cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );	
	
	if ( PID == PID_JET )
		cr.StatBase[ST_EXPERIENCE] += 3000;
	
	
    if( flag != 0 )
    {
        if( FLAG( FOOD_KNOCKOUT, flag ) )
        {
            cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 25, cr.HexX, cr.HexY );
        }
        if( FLAG( FOOD_POISONED, flag ) )
        {
            AffectPoison( cr, Random( 25, 55 ) );
        }
        if( FLAG( FOOD_RADIOACTIVE, flag ) )
        {
            AffectRadiation( cr, Random( 20, 55 ) * 10 ); //Чувствительность увеличена стократно (1.00 раньше == 100 рад теперь ), небольшой ребаланс (стало в десять раз слабей чем раньше).
        }
    }
}

void _GasMask( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_GasMaskUse" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_GasMaskMove" );
}

void e_GasMaskMove( Item& item, Critter& crit, uint8 fromSlot )
{
    if(item.CritSlot == SLOT_HAND2 )
    {
	crit.Say( SAY_NETMSG, "Вы одели респиратор." );
    }
    if(fromSlot == SLOT_HAND2 )
    {
	crit.Say( SAY_NETMSG, "Вы сняли респиратор." );
    }
}

bool e_GasMaskUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	if (cr.GetItems( SLOT_HAND2, null)!=0)
		{
		cr.Say( SAY_NETMSG, "Уберите из рук все лишнее, чтобы нормально одеть респиратор." );
		}
	else
		{
	        cr.MoveItem(item.Id, 1, SLOT_HAND2);
		}
    return true;
}

void _FireFood( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_FireFoodUse" );
}

bool e_FireFoodUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	cr.Say( SAY_NETMSG, "Пока нет функционала." );
	return false;
}

void _BonesInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_BonesUseItem" );
}

bool e_BonesUseItem( Item& item, Critter& crit, Item@ usedItem )
{
    if( valid( usedItem ) && usedItem.GetProtoId() == PID_SHOVEL )
    {
		DeleteItem( item );
		crit.Say( SAY_NETMSG, "Вы закопали тело." );
        return true;
    }
    return false;
}


void _InitToken( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_TokenPick" );
	item.SetEvent( ITEM_EVENT_DROP, "e_TokenDrop" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_TokenMove" );
}

bool e_TokenPick( Item& item, Critter& cr, int skill )
{
    DeleteItem( item );
	return false;
}

void e_TokenDrop( Item& item, Critter& crit )
{
    DeleteItem( item );
}

void e_TokenMove( Item& item, Critter& crit, uint8 fromSlot )
{
    DeleteItem( item );
}

void SetWorkbench( Critter& cr, int item_id, int item_type, int p2 )
{
	Item@ item = GetItem(item_id);
	if( !valid( item ) ) return;
	string[] type_names = {  "_InitWorkBench",  "_InitFurnace" , "_InitChemLab" ,  "_InitCoinPress", "_InitSawmill", "_InitLathe" };
	if( uint( item_type ) >= type_names.length() ) {
		cr.Say( SAY_NETMSG, "Не так." );
		return;
	}
    item.SetScript( type_names[item_type] );
    item.Update();
}

void _InitWorkBench( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_WorkBenchPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_WorkBenchCloneKey" );	
}

void _InitChemLab ( Item& item, bool firstTime)
{
	item.SetEvent( ITEM_EVENT_SKILL, "e_ChemLabPick" );
}

bool e_ChemLabPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        Item@ Workplace;
        @Workplace = cr.GetMap().GetItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK );
        if( !valid( Workplace ) ) {
			@Workplace = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK, 1 );
			Workplace.SetScript( "_WorkplaceInit" );
		}
		
		if( cr.CountItem( PID_LAB_TOKEN ) == 0 ) cr.AddItem( PID_LAB_TOKEN, 1 );
		cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
    }
    return true;
}

bool e_WorkBenchCloneKey( Item& item, Critter& crit, Item@ usedItem )
{
    if( valid( usedItem ) && usedItem.GetType() == ITEM_TYPE_KEY )
    {
	if( _CritCountItem( crit, PID_CRAFT_M_BARS )<=0 )
		{
		crit.Say( SAY_NETMSG, "Вам нужна железная болванка." );
		return true;
		}
    Item @ newKey = crit.AddItem( PID_BLANK_KEY, 1 );
    newKey.LockerId = usedItem.LockerId;
    newKey.SetLexems( "$KeyLex" + "some key" );
    crit.StatBase[ ST_VAR0 ] = newKey.Id;
    crit.ShowScreen( SCREEN_SAY, 0, "item@KeyUseScreen" );
    newKey.Update();
	crit.DeleteItem( PID_CRAFT_M_BARS, 1 );
    return true;	
	}
    return false;	
}

bool e_WorkBenchPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        Item@ Workplace;
        @Workplace = cr.GetMap().GetItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK );
        if( !valid( Workplace ) ) {
			@Workplace = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK, 1 );
			Workplace.SetScript( "_WorkplaceInit" );
		}
		
		if( cr.CountItem( PID_WORKBENCH_TOKEN ) == 0 ) cr.AddItem( PID_WORKBENCH_TOKEN, 1 );
		cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
    }
    return true;
}

void _InitFurnace( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_FurnaceUseSkill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_FurnaceUseItem" );	
}

bool e_FurnaceUseItem( Item& item, Critter& crit, Item@ usedItem ) {
	if( !valid( usedItem ) ) return false;
	uint pid = usedItem.GetProtoId();

	uint[][] fuel = { 
		{ PID_FIREWOOD, 1 }, 
		{ PID_WOOD_PLANK, 2}, 
		{ PID_WOOD_PART, 3} 
	};
	for( uint i = 0, iEnd = fuel.length(); i < iEnd; i++ ) {
		if( fuel[i][0] == pid ) {
			crit.Say( SAY_NETMSG, "Вы добавили топливо." );
			item.Val0 += fuel[i][1];
			return true;
		}
	}
	
	uint[][] junk = {
		{ PID_HLAM_MEH, 1, 2 },
		{ PID_HLAM2_MEH, 1, 2 },
		{ PID_SPIKE_MEH, 1, 0 },
		{ PID_DETAL_MEH, 1, 1 }		
	};
	for( uint i = 0, iEnd = junk.length(); i < iEnd; i++ ) {
		if( junk[i][0] == pid ) {
			_SubItem( usedItem, 1 );
			crit.Say( SAY_NETMSG, "Вы добавили метал для переплавки." );
			item.Val1 += junk[i][1];
			item.Val2 += junk[i][2];
			return true;
		}
	}
	return false;
}

bool e_FurnaceUseSkill( Item& item, Critter& cr, int skill ) {
    if( ( skill != SKILL_PICK_ON_GROUND ) || ( item.Accessory != ACCESSORY_HEX ) ) { 
		cr.Say( SAY_NETMSG, "Предмет должен стоять на земле. Работайте руками." );
		return false;
	}
	Item@ Workplace;
	@Workplace = cr.GetMap().GetItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK );
	if( !valid( Workplace ) ) {
		@Workplace = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK, 1 );
		Workplace.SetScript( "_WorkplaceInit" );
	}
	if( cr.CountItem( PID_WORKBENCH_TOKEN ) == 0 ) cr.AddItem( PID_WORKBENCH_TOKEN, 1 );
	cr.StatBase[ ST_VAR0 ] = item.Id;
	answer_FurnaceSkill( cr, 0, "" );
    return true;	
}

void answer_FurnaceSkill( Critter& player, uint answerI, string& answerS ) {
	Item@ furnace = GetItem( player.StatBase[ ST_VAR0 ] );
	if( !valid( furnace ) ) return;
	if( answerI == 0 ) player.Say( SAY_EMOTE_ON_HEAD, "смотрит на огонь" );
	if( answerI == 1 ) {
		if( player.CountItem( PID_CROWBAR ) == 0 ) {
			player.Say( SAY_NETMSG, "Вам нужен лом для этого." );
			return;
		}		
		if( furnace.Val2 <= 0 ) {
			player.Say( SAY_EMOTE, "шерудит ломом" );
			player.Say( SAY_NETMSG, "Из этого ничего не вышло." );
			return;
		}			
		player.Say( SAY_EMOTE, "выгребает шлак" );
		player.AddItem( PID_CRAFT_M_JUNK, 1 );
		furnace.Val2--;
	}
	if( answerI == 2 ) {
		if( furnace.Val1 <= 0 ) {
			player.Say( SAY_EMOTE, "проверяет слив металла" );
			player.Say( SAY_NETMSG, "Из этого ничего не вышло." );
			return;
		}			
		player.Say( SAY_EMOTE, "отливает слитки" );
		player.AddItem( PID_IRON_BAR, 1 );
		furnace.Val1--;
	}
	if( answerI == 3 ) {
		if( player.CountItem( PID_CROWBAR ) == 0 ) {
			player.Say( SAY_NETMSG, "Вам нужен лом для этого." );
			return;
		}		
		if( furnace.Val0 <= 0 ) {
			player.Say( SAY_EMOTE, "шерудит ломом" );
			player.Say( SAY_NETMSG, "Из этого ничего не вышло." );
			return;
		}			
		player.Say( SAY_EMOTE, "выгребает угли" );
		player.AddItem( PID_DARTS_LOW, Random(0,10) );
		furnace.Val0--;
	}
	player.ShowScreen( SCREEN_DIALOGBOX, 4, "answer_FurnaceSkill" );
	player.Say( SAY_DIALOGBOX_TEXT, 
		"Топливо: "+furnace.Val0+
		". Металл: "+furnace.Val1+
		". Шлак: "+furnace.Val2+
		". Выберите действие:" );
	player.Say( SAY_DIALOGBOX_BUTTON( 0 ), "смотреть на огонь");
	player.Say( SAY_DIALOGBOX_BUTTON( 1 ), "выгрести шлак");
	player.Say( SAY_DIALOGBOX_BUTTON( 2 ), "слить металл");
	player.Say( SAY_DIALOGBOX_BUTTON( 3 ), "потушить");
}

void _InitCoinPress( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_WorkBenchPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_WorkBenchCloneKey" );	
}

void _InitSawmill( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_WorkBenchPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_WorkBenchCloneKey" );	
}

void _InitLathe( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_WorkBenchPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_WorkBenchCloneKey" );	
}

void _WorkplaceInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_WALK, "_WorkplaceWalk" );
}
void _WorkplaceWalk( Item& item, Critter& crit, bool entered, uint8 dir )
{
	if( !entered )
    {
	    Item@Token = crit.GetItem( PID_WORKBENCH_TOKEN, -1 );
        if( valid( Token )) DeleteItem( Token );
	    Item@Token2 = crit.GetItem( PID_FIREPLACE_TOKEN, -1 );
        if( valid( Token2 )) DeleteItem( Token2 ); 
		Item@Token3 = crit.GetItem ( PID_LAB_TOKEN, -1 );
		if( valid (Token3)) DeleteItem (Token3);
    }
}