                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                       

import int RollVsSkill(Critter&cr,uint skillIndex,int bonus)from"stdlib";  

import bool IsSuccessRvS(int val)from"stdlib";  

import bool IsCriticalRvS(int val)from"stdlib";  

import void HealCritter(Critter&player)from"stdlib";  

import bool TransitToLoc(Critter&cr,uint16 locPid,uint mapIndex,uint entranceNum)from"stdlib";  

import bool TransitToMap(Critter&cr,uint16 mapPid,uint entranceNum)from"stdlib";  

import bool TransitToNewLocation(Critter&cr,uint16 locPid)from"stdlib";  

import void InfoMessage(Critter&player,Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageNorm(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageShout(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageWhisp(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageEmo(Critter&npc,uint strNum)from"stdlib";        

import void TimeoutSet(Critter&npc,int timeoutNumber,uint gameHours)from"stdlib";  

import void TimeoutSub(Critter&npc,uint gameHoursSub)from"stdlib";  

import void TimeoutAdd(Critter&npc,uint gameHoursAdd)from"stdlib";  

import void GroupSetVar(Critter&player,uint16 varId,int value)from"stdlib";  

import void Warn(Critter&player,int npcRole)from"stdlib";  

import void DoorControl(Critter&player,uint entireNum,bool toOpen)from"stdlib";  

import bool DialogNpc(Critter&player,int role)from"stdlib";  

import Critter@GetNearCritterWithRole(Map@map,uint16 hexX,int hexY,uint radius,int role)from"stdlib";              

import void DropDrugEffects(Critter&cr)from"drugs";
import void DropRadiation(Critter&cr)from"radiation";                                            

const uint16[]npc_group_raiders={(337),(338),(339),(340),(341)};
const uint16[]npc_group_mirelurk={(330)};
const uint16[]npc_group_radscorp={(319),(320)};
const uint16[]npc_group_gecko={(316),(317),(327)};
const uint16[]npc_group_rats={(310),(313),(314),(315)};                                                                                                                                                                                        

import void FlushScreen(Critter&cr,bool fadeOut,uint timeMs)from"effects";
import bool FactionInGame(Critter&player,Critter@npc,int faction,int number)from"factions";
import void PackageAlarm(Critter&player,int destination)from"factions";    

void dlg_MoodValue(Critter&player,Critter@npc,string@lexems){
	if(!(@npc!=null))return;
	GameVar@moodVar=GetLocalVar((13000),npc.Id);
	if(!(@moodVar!=null))return;
	if(!(@lexems!=null))@lexems="";
	lexems+="$moodValue "+moodVar.GetValue();
}    

void r_MoodSetRandom(Critter&player,Critter@npc,int min,int max){
	if(!(@npc!=null))return;
	GameVar@moodVar=GetLocalVar((13000),npc.Id);
	if(!(@moodVar!=null))return;
	moodVar=(((Random(min,max))>(moodVar.GetMax()))?(moodVar.GetMax()):(((Random(min,max))<(moodVar.GetMin()))?(moodVar.GetMin()):(Random(min,max))));
}    

void r_MoodSet(Critter&player,Critter@npc,int value){
	if(!(@npc!=null))return;
	GameVar@moodVar=GetLocalVar((13000),npc.Id);
	if(!(@moodVar!=null))return;
	moodVar=(((value)>(moodVar.GetMax()))?(moodVar.GetMax()):(((value)<(moodVar.GetMin()))?(moodVar.GetMin()):(value)));
}    

void r_MoodChange(Critter&player,Critter@npc,int delta){
	if(!(@npc!=null))return;
	GameVar@moodVar=GetLocalVar((13000),npc.Id);
	if(!(@moodVar!=null))return;
	moodVar=(((moodVar.GetValue()+delta)>(moodVar.GetMax()))?(moodVar.GetMax()):(((moodVar.GetValue()+delta)<(moodVar.GetMin()))?(moodVar.GetMin()):(moodVar.GetValue()+delta)));
}        

bool d_MoodCheck(Critter&player,Critter@npc,int checkType,int value){
	if(!(@npc!=null))return false;
	GameVar@moodVar=GetLocalVar((13000),npc.Id);
	if(!(@moodVar!=null))return false;
	int mood=moodVar.GetValue();
	switch(checkType){
		case(0):return mood==value;
		case(-1):return mood<=value;
		case(-2):return mood<value;
		case(1):return mood>=value;
		case(2):return mood>value;
		case(101):return mood>0;
		case(-101):return mood<0;
		default:return false;
	}
	return false;
} 

bool d_GotPet(Critter&player,Critter@npc,int val){
	Critter@[]pets;
	for(uint i=0,iEnd=player.GetFollowGroup((0x01),pets);i<iEnd;i++){
		if(pets[i].CrType==uint(val))return true;
	}
	return false;
}

bool d_GotSlave(Critter&player,Critter@npc,int BODY_TYPE){
	Critter@[]pets;
	for(uint i=0,iEnd=player.GetFollowGroup((0x01),pets);i<iEnd;i++){
		if(pets[i].IsPlayer())continue;
		if(pets[i].Stat[(67)]==BODY_TYPE)return true;
	}
	return false;
}

void r_SellPet(Critter&player,Critter@npc,int val){
	Critter@[]pets;
	
	for(uint i=0,iEnd=player.GetFollowGroup((0x01),pets);i<iEnd;i++){
		if(pets[i].CrType==uint(val)){
			DeleteNpc(pets[i]);
			return;
		}
	}
}

void r_SellSlave(Critter&player,Critter@npc,int BODY_TYPE){
	Critter@[]pets;
	
	for(uint i=0,iEnd=player.GetFollowGroup((0x01),pets);i<iEnd;i++){
		if(pets[i].IsPlayer())continue;
		if(pets[i].Stat[(67)]==BODY_TYPE){
			DeleteNpc(pets[i]);
			return;
		}
	}
}

bool d_GotTarget(Critter&player,Critter@npc){
	Critter@[]groups;
	player.GetFollowGroup((0x01),groups);
	return groups.length()>0;
}

void r_JailTarget(Critter&player,Critter@npc){
	Critter@[]groups;
	player.GetFollowGroup((0x01),groups);
	if(groups.length()==0)return;
	Critter@target=@groups[0];
	if(!(@target!=null)||!target.IsPlayer())return;
	Map@map=player.GetMap();
	uint8 temp_dir=Random(0,5);
	uint16 hexX=390,hexY=405;
	for(uint i=0;i<6;i++){
		hexX=390;hexY=405;
		map.MoveHexByDir(hexX,hexY,(temp_dir+i)%6,2);
		if(map.IsHexPassed(hexX,hexY))break;
	}
	Item@[]items;
	target.GetItems((0),items);
	target.GetItems((1),items);
	target.GetItems((2),items);
	MoveItems(items,player);
	target.TransitToMap(map.Id,hexX,hexY,0);
}

bool d_GotJailed(Critter&player,Critter@npc){
	Critter@jailed=player.GetFollowLeader();
	if(!(@jailed!=null)||jailed.GetMapId()!=player.GetMapId())return false;
	if(player.CountItem((41))<500)return false;
	return true;
}

void r_FreeJailed(Critter&player,Critter@npc){
	Critter@jailed=player.GetFollowLeader();
	if(!(@jailed!=null)||jailed.GetMapId()!=player.GetMapId())return;
	player.DeleteItem((41),500);
	Map@map=jailed.GetMap();
	uint8 temp_dir=Random(0,5);
	uint16 hexX=390,hexY=390;
	for(uint i=0;i<6;i++){
		hexX=390;hexY=390;
		map.MoveHexByDir(hexX,hexY,(temp_dir+i)%6,2);
		if(map.IsHexPassed(hexX,hexY))break;
	}
	jailed.TransitToMap(map.Id,hexX,hexY,0);
}

int DFGroupCount(Critter&player,Critter@npc)
{
	Critter@leader;
	if(not(@player.GetFollowLeader()!=null))
	@leader=player;
	else
	@leader=player.GetFollowLeader();
	
	Critter@[]groups;
	groups.insertLast(@leader);
	leader.GetFollowGroup((0x01),groups);
	return groups.length();
} 

bool d_GroupCountMore(Critter&player,Critter@npc,int val)
{
	return DFGroupCount(player,npc)>=val;
}

bool d_GroupCountLess(Critter&player,Critter@npc,int val)
{
	return DFGroupCount(player,npc)<val;
}  

bool d_GroupLevelMore(Critter&player,Critter@npc,int val)
{
	Critter@[]groups;
	groups.insertLast(@player);
	player.GetFollowGroup((0x01),groups);
	for(uint i=0;i<groups.length();i++)
	if(groups[i].Stat[(77)]<val)
	return false;
	return true;
}

bool d_GroupLevelLess(Critter&player,Critter@npc,int val)
{
	Critter@[]groups;
	groups.insertLast(@player);
	player.GetFollowGroup((0x01),groups);
	for(uint i=0;i<groups.length();i++)
	if(groups[i].Stat[(77)]>val)
	return false;
	return true;
} 

bool d_IsToHeal(Critter&player,Critter@npc)
{
	return player.Stat[(72)]<player.Stat[(7)];
} 

bool d_IsLocationVisible(Critter&player,Critter@npc,int LocNum)
{
	return player.IsKnownLoc(false,uint16(LocNum));
} 

bool d_IsLocationNotVisible(Critter&player,Critter@npc,int LocNum)
{
	return not player.IsKnownLoc(false,uint16(LocNum));
} 

bool d_IsAddict(Critter&player,Critter@npc)
{
	for(uint i=(__AddictionBegin);i<=(__AddictionEnd);i++)
	if(player.Addiction[i]!=0)
	return true;
	return false;
} 

bool d_IsNotAddict(Critter&player,Critter@npc)
{
	return not d_IsAddict(player,npc);
} 

bool d_GroupPresent(Critter&player,Critter@npc)
{
	return DFGroupCount(player,npc)>1;
} 

bool d_NotGroupPresent(Critter&player,Critter@npc)
{
	return not d_GroupPresent(player,npc);
}      

bool d_TimeoutCheck(Critter&player,Critter@npc,int timeoutNumber)
{   
	
	int variable=0;
	
	switch(timeoutNumber)
	{
		case 0:
		variable=(6160);
		break;
		case 1:
		variable=(6161);
		break;
		case 2:
		variable=(6162);
		break;
		case 3:
		variable=(6163);
		break;
		case 4:
		variable=(6164);
		break;
		case 5:
		variable=(6165);
		break;
		case 6:
		variable=(6166);
		break;
		case 7:
		variable=(6167);
		break;
		case 8:
		variable=(6168);
		break;
	}
	GameVar@t=GetLocalVar(variable,npc.Id);
	
	if(not(@t!=null))
	return true;
	if(__FullSecond>=uint(t.GetValue()))
	return true;
	else
	return false;
}   

bool d_NotTimeoutCheck(Critter&player,Critter@npc,int timeoutNumber)
{
	return not d_TimeoutCheck(player,npc,timeoutNumber);
}   

bool d_canGive(Critter&player,Critter@npc,int itemPID,int min)
{
	if(int(player.CountItem(itemPID))<min)return false;
	if(!(@npc!=null))return false;
	if(npc.Merc[(800)]<50)return false;
	return true;
}

bool d_failGive(Critter&player,Critter@npc,int itemPID,int min)
{
	return!d_canGive(player,npc,itemPID,min);
}

void r_genProps(Critter&player,Critter@npc)
{
	if(!(@npc!=null))return;
	npc.MercBase[(800)]=Random(1,100);
	
} 

void r_tryGive(Critter&player,Critter@npc,int itemPID,int min)
{
	if(Random(1,100)<50){
		npc.Say((1),"Так, погодь секунду..");
		return;
	}
	if(!(@npc!=null))return;
	npc.Say((1),"Ага, давай сюда..");
	Item@item=player.GetItem(itemPID,-1);
	if(@item!is null)
	do{if(item.GetCount()>(uint(min)))
		item.SetCount(item.GetCount()-(uint(min)));else
		DeleteItem(item);}while(false);
}  

void r_showVar(Critter&player,Critter@npc)
{
	GameVar@friendshipandmagic=::GetUnicumVar((12002),player.Id,npc.Id);
	player.Say((11),"Ваша лояльность: "+friendshipandmagic.GetValue());
}  

bool d_TimeoutOk(Critter&player,Critter@npc)
{
	if(!(@npc!=null))
	return false;
	GameVar@to=GetUnicumVar((2031),player.Id,npc.Id);
	if(!(@to!=null))
	return false;
	uint time=to.GetValue();
	if(time==0)
	return true;
	return(time<__FullSecond);
} 

bool d_NotTimeoutOk(Critter&player,Critter@npc)
{
	return!d_TimeoutOk(player,npc);
}

bool d_CheckMonth(Critter&playe,Critter@npc,int monthFrom,int monthTo)
{
	return(__Month<=monthTo&&__Month>=monthFrom);
} 

void r_SetUniqTO(Critter&player,Critter@npc,int value)
{
	if(!(@npc!=null))
	return;
	GameVar@to=GetUnicumVar((2031),player.Id,npc.Id);
	if(!(@to!=null))
	return;
	to=value*60+__FullSecond;
} 

void r_SayMessageDelayed(Critter&player,Critter@npc,int strNum,int delaySeconds,int sayType)
{
	if(!(@npc!=null))
	return;
	uint[]values={npc.Id,uint(sayType),uint(strNum)};
	CreateTimeEvent(__FullSecond+delaySeconds,"e_SayMessage",values,false);
}

uint e_SayMessage(uint[]@values)
{
	if(values.length()<3)
	return 0;
	Critter@cr=GetCritter(values[0]);
	if(!(@cr!=null))
	return 0;
	int did=cr.Stat[(104)];
	if(did==0)
	return 0;
	cr.SayMsg(values[1],(1),(1000000000+(did)*100000+(values[2])));
	return 0;
} 

void dlg_TrySpy(Critter&player,Critter@banker,string@playerName)
{
	if(!(@banker!=null))
	return;
	if(!((@playerName!=null)&&playerName.length()>0)||(not(@playerName!=null)))
	return;
	if(playerName.length()<=1)
	return;
	
	uint BankerDialog=banker.Stat[(104)];
	uint DlgStr=100;
	string lexems="$Victim "+playerName;
	
	Critter@cr=GetPlayer(playerName);
	if(!(@cr!=null))
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+0)),lexems);
		return;
	}
	
	if(player.Id==cr.Id)
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+9)));
		return;
	} 
	
	if(cr.Stat[(71)]==(0))
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+10))+"@";
	}
	else if(cr.Stat[(71)]==(1))
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+11))+"@";
	}
	else
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+12))+"@";
	} 
	
	if(cr.Stat[(83)]/cr.Stat[(77)]<=2)
	{
		lexems+="$ReplCount @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+13))+"@";
	}
	else if(cr.Stat[(83)]/cr.Stat[(77)]>2&&cr.Stat[(83)]/cr.Stat[(77)]<10)
	{
		lexems+="$ReplCount @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+14))+"@";
	}
	else
	{
		lexems+="$ReplCount @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+15))+"@";
	} 
	
	lexems+="$Born "+(__Year-cr.Stat[(70)]);
	
	if(player.Skill[(214)]>=40-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+1)),lexems);
	} 
	
	if(player.Skill[(214)]>=50-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		lexems="";
		lexems+="$Level "+cr.Stat[(77)];
		player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+2)),lexems);
	} 
	
	if(player.Skill[(214)]>=60-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		int[]Values={-2147483647,-1000,-750,-500,-250,250,500,750,1000};
		int[]Descs={6125,6122,6119,6116,6113,6110,6107,6104,6101};
		int CurKarma=0;
		for(uint i=0;i<Values.length();i++)
		{
			if(int(cr.Stat[(80)])>=Values[i])
			{
				CurKarma=Descs[i];
			}
			else
			{
				break;
			}
		}
		player.SayMsg((13),(3),CurKarma);
	} 
	
	if(player.Skill[(214)]>=70-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		lexems="";
		
		if(cr.StatBase[(0)]<4)
		{
			lexems+="$Strength @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+16))+"@";
		}
		else if(cr.StatBase[(0)]>=4&&cr.StatBase[(0)]<7)
		{
			lexems+="$Strength"+"";
		}
		else if(cr.StatBase[(0)]>=7&&cr.StatBase[(0)]<=8)
		{
			lexems+="$Strength @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+17))+"@";
		}
		else
		{
			lexems+="$Strength @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+18))+"@";
		}
		
		if(cr.StatBase[(1)]<4)
		{
			lexems+="$Perception @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+19))+"@";
		}
		else if(cr.StatBase[(1)]>=4&&cr.StatBase[(1)]<7)
		{
			lexems+="$Perception"+"";
		}
		else if(cr.StatBase[(1)]>=7&&cr.StatBase[(1)]<=8)
		{
			lexems+="$Perception @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+20))+"@";
		}
		else
		{
			lexems+="$Perception @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+21))+"@";
		}
		
		if(cr.StatBase[(2)]<4)
		{
			lexems+="$Endurance @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+22))+"@";
		}
		else if(cr.StatBase[(2)]>=4&&cr.StatBase[(2)]<7)
		{
			lexems+="$Endurance"+"";
		}
		else if(cr.StatBase[(2)]>=7&&cr.StatBase[(2)]<=8)
		{
			lexems+="$Endurance @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+23))+"@";
		}
		else
		{
			lexems+="$Endurance @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+24))+"@";
		}
		
		if(cr.StatBase[(3)]<4)
		{
			lexems+="$Charisma @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+25))+"@";
		}
		else if(cr.StatBase[(3)]>=4&&cr.StatBase[(3)]<7)
		{
			lexems+="$Charisma"+"";
		}
		else if(cr.StatBase[(3)]>=7&&cr.StatBase[(3)]<=8)
		{
			lexems+="$Charisma @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+26))+"@";
		}
		else
		{
			lexems+="$Charisma @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+27))+"@";
		}
		
		if(cr.StatBase[(4)]<4)
		{
			lexems+="$Intellect @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+28))+"@";
		}
		else if(cr.StatBase[(4)]>=4&&cr.StatBase[(4)]<7)
		{
			lexems+="$Intellect"+"";
		}
		else if(cr.StatBase[(4)]>=7&&cr.StatBase[(4)]<=8)
		{
			lexems+="$Intellect @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+29))+"@";
		}
		else
		{
			lexems+="$Intellect @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+30))+"@";
		}
		
		if(cr.StatBase[(5)]<4)
		{
			lexems+="$Agility @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+31))+"@";
		}
		else if(cr.StatBase[(5)]>=4&&cr.StatBase[(5)]<7)
		{
			lexems+="$Agility"+"";
		}
		else if(cr.StatBase[(5)]>=7&&cr.StatBase[(5)]<=8)
		{
			lexems+="$Agility @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+32))+"@";
		}
		else
		{
			lexems+="$Agility @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+33))+"@";
		}
		
		if(cr.StatBase[(6)]<4)
		{
			lexems+="$Luck @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+34))+"@";
		}
		else if(cr.StatBase[(6)]>=4&&cr.StatBase[(6)]<7)
		{
			lexems+="$Luck"+"";
		}
		else if(cr.StatBase[(6)]>=7&&cr.StatBase[(6)]<=8)
		{
			lexems+="$Luck @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+35))+"@";
		}
		else
		{
			lexems+="$Luck @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+36))+"@";
		}
		player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+3)),lexems);
	} 
	
	if(player.Skill[(214)]>=80-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		
		uint[]CombatSkills={(200),(201),(202),(203),(204),(205)};
		uint[]TagSkills={cr.TagSkill[(226)],cr.TagSkill[(227)],cr.TagSkill[(228)],cr.TagSkill[(229)]};
		
		for(uint i=0;i<CombatSkills.length();i++)
		{
			for(uint t=0;t<TagSkills.length();t++)
			{
				if(CombatSkills[i]==TagSkills[t])
				{
					if(cr.Skill[TagSkills[t]]<100)
					{
						lexems="$CmbtSkillTag @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+60+Random(0,1)))+"@";
						switch(TagSkills[t])
						{
							case(200):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+41))+"@";
							break;
							case(201):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+42))+"@";
							break;
							case(202):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+43))+"@";
							break;
							case(203):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+44))+"@";
							break;
							case(204):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+45))+"@";
							break;
							case(205):
							lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+46))+"@";
							break;
							default:
							break;
						}
						player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+6)),lexems);
					}
				}
			}
		}
		
	} 
	
	if(player.Skill[(214)]>=85-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		uint[]Skills={(206),(207),(208),(209),(210),(211),(212),(213),(214),(215),(216),(217)};
		uint[]TagSkills={cr.TagSkill[(226)],cr.TagSkill[(227)],cr.TagSkill[(228)],cr.TagSkill[(229)]};
		for(uint i=0;i<Skills.length();i++)
		{
			for(uint t=0;t<TagSkills.length();t++)
			{
				if(Skills[i]==TagSkills[t])
				{
					if(cr.Skill[TagSkills[t]]<100)
					{
						lexems="$SkillTag @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+62+Random(0,2)))+"@";
						switch(TagSkills[t])
						{
							case(206):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+65))+"@";
							break;
							case(207):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+66))+"@";
							break;
							case(208):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+67))+"@";
							break;
							case(209):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+68))+"@";
							break;
							case(210):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+69))+"@";
							break;
							case(211):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+70))+"@";
							break;
							case(212):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+71))+"@";
							break;
							case(213):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+72))+"@";
							break;
							case(214):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+73))+"@";
							break;
							case(215):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+74))+"@";
							break;
							case(216):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+75))+"@";
							break;
							case(217):
							lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+76))+"@";
							break;
							default:
							break;
						}
						player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+7)),lexems);
					}
				}
			}
		}
		
	} 
	
	if(player.Skill[(214)]>=90-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		
		lexems="";
		int CurSkill=0;
		int MaxSkill=0;
		uint[]CombatSkills={(200),(201),(202),(203),(204),(205)};
		
		for(uint i=0;i<CombatSkills.length();i++)
		{
			if(CurSkill<cr.Skill[CombatSkills[i]])
			{
				CurSkill=cr.Skill[CombatSkills[i]];
				MaxSkill=CombatSkills[i];
			}
		}
		if(CurSkill<90)
		{
			lexems+="$CombatSkillLvl @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+37))+"@";
			lexems+="$CombatSkillMax";
		}
		else
		{
			if(CurSkill>=90&&CurSkill<150)
			lexems+="$CombatSkillLvl @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+38))+"@";
			if(CurSkill>=150&&CurSkill<200)
			lexems+="$CombatSkillLvl @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+39))+"@";
			if(CurSkill>=200)
			lexems+="$CombatSkillLvl @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+40))+"@";
			switch(MaxSkill)
			{
				case(200):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+41))+"@";
				break;
				case(201):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+42))+"@";
				break;
				case(202):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+43))+"@";
				break;
				case(203):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+44))+"@";
				break;
				case(204):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+45))+"@";
				break;
				case(205):
				lexems+="$CombatSkillMax @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+46))+"@";
				break;
				default:
				break;
			}
		}
		player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+4)),lexems);
		
	} 
	
	if(player.Skill[(214)]>=100-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		
		lexems="";
		int CurSkill=0;
		int MaxSkill=0;
		uint[]Skills={(206),(207),(208),(209),(210),(211),(212),(213),(214),(215),(216),(217)};
		
		for(uint i=0;i<Skills.length();i++)
		{
			if(CurSkill<cr.Skill[Skills[i]])
			{
				CurSkill=cr.Skill[Skills[i]];
				MaxSkill=Skills[i];
			}
		}
		if(CurSkill<=90)
		{
			lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+47))+"@";
		}
		else
		{
			switch(MaxSkill)
			{
				case(206):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+48))+"@";
				break;
				case(207):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+49))+"@";
				break;
				case(208):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+50))+"@";
				break;
				case(209):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+51))+"@";
				break;
				case(210):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+52))+"@";
				break;
				case(211):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+53))+"@";
				break;
				case(212):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+54))+"@";
				break;
				case(213):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+55))+"@";
				break;
				case(214):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+56))+"@";
				break;
				case(215):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+57))+"@";
				break;
				case(216):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+58))+"@";
				break;
				case(217):
				lexems+="$AnySkill @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+59))+"@";
				break;
				default:
				break;
			}
		}
		player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+5)),lexems);
		
	} 
	
	if(player.Skill[(214)]>=110-(player.Stat[(3)]+player.Stat[(6)])/2)
	{
		lexems="";
		lexems+="$ReplMoney "+cr.Stat[(82)]+"$ReplCount "+cr.Stat[(83)];
		player.SayMsg((13),(1),(1000000000+(BankerDialog)*100000+(DlgStr+8)),lexems);
	}
}

void dlg_ForSearching(Critter&player,Critter@barman,string@playerName)
{
	if(!(@barman!=null))
	return;
	if(!((@playerName!=null)&&playerName.length()>0)||(not(@playerName!=null)))
	return;
	if(playerName.length()<=1)
	return;
	uint BankerDialog=barman.Stat[(104)];
	uint DlgStr=200;
	
	string lexems="$Victim "+playerName;
	
	if(barman.Stat[(71)]==(1))
	{
		lexems+="$BarmanGen @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+10))+"@";
	}
	else
	{
		lexems+="$BarmanGen @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+9))+"@";
	}
	
	Critter@cr=GetPlayer(playerName);
	if(!(@cr!=null))
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+0)),lexems);
		return;
	}
	
	if(cr.Stat[(71)]==(1))
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+8))+"@";
	}
	else
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+7))+"@";
	}
	player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+11)),lexems);
	return;
}

void dlg_TrySearching(Critter&player,Critter@barman,string@playerName)
{ 
	
	if(!(@barman!=null))
	return;
	if(!((@playerName!=null)&&playerName.length()>0)||(not(@playerName!=null)))
	return;
	if(playerName.length()<=1)
	return;
	uint BankerDialog=barman.Stat[(104)];
	uint DlgStr=200;
	
	string lexems="$Victim "+playerName;
	
	if(barman.Stat[(71)]==(1))
	{
		lexems+="$BarmanGen @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+10))+"@";
	}
	else
	{
		lexems+="$BarmanGen @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+9))+"@";
	}
	
	Critter@cr=GetPlayer(playerName);
	if(!(@cr!=null))
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+0)),lexems);
		return;
	}
	
	if(cr.Stat[(71)]==(1))
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+8))+"@";
	}
	else
	{
		lexems+="$Gender @msg dlg "+(1000000000+(BankerDialog)*100000+(DlgStr+7))+"@";
	}
	
	if(player.Id==cr.Id)
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+1)));
		return;
	}
	
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+2)),lexems);
		return;
	}
	
	if(cr.GetMap().GetLocation().GetProtoId()<50||cr.GetMap().GetLocation().GetProtoId()>=200)
	{
		lexems+="$Place @msg GM "+((cr.GetMap().GetLocation().GetProtoId()+100)*1000)+"@";
		
		if(barman.GetMap().GetLocation().Id==cr.GetMap().GetLocation().Id)
		{
			player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+3)),lexems);
			return;
		}
		
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+4+Random(0,2))),lexems);
	}
	else
	{
		player.SayMsg((12),(1),(1000000000+(BankerDialog)*100000+(DlgStr+2)),lexems);
		return;
	}
}

import void ChangeStatus(Critter&cr,uint16 status,uint8 value,bool set)from"critter_status";

void r_ToHeal(Critter&player,Critter@npc)
{
	ChangeStatus(player,(0x008),0,false);
	ChangeStatus(player,(0x040),0,false);
	ChangeStatus(player,(0x001),0,false);
	ChangeStatus(player,(0x010),0,false);
	HealCritter(player);
}

void r_ShowLocation(Critter&player,Critter@npc,int locNum)
{
	
}

void r_FadeOut(Critter&player,Critter@npc,int time)
{
	if(time==0)
	time=2000;
	FlushScreen(player,false,time);
}

void r_TransitToGlobal(Critter&player,Critter@npc)
{
	player.TransitToGlobal(false);
}

void r_TransitToLocation(Critter&player,Critter@npc,int locPid,int mapIndex)
{
	TransitToLoc(player,locPid,mapIndex,0);
}

void r_InfoMessage(Critter&player,Critter@npc,int strNum)
{
	InfoMessage(player,npc,strNum);
}

void r_TimeoutSet(Critter&player,Critter@npc,int timeoutNumber,int gameHours)
{
	
	int variable=0;
	switch(timeoutNumber)
	{
		case 0:
		variable=(6160);
		case 1:
		variable=(6161);
		case 2:
		variable=(6162);
		case 3:
		variable=(6163);
		case 4:
		variable=(6164);
		case 5:
		variable=(6165);
		case 6:
		variable=(6166);
		case 7:
		variable=(6167);
		case 8:
		variable=(6168);
		default:
	}
	Log("r_Timeoutset: "+variable+" timeout");
	
	TimeoutSet(npc,timeoutNumber,gameHours);
	Log("r_timeoutset: timeoutNumber = "+timeoutNumber+" gameHours = "+gameHours);
}

void r_DoorOpen(Critter&player,Critter@npc,int entireNum)
{
	DoorControl(player,entireNum,true);
}

void r_DoorClose(Critter&player,Critter@npc,int entireNum)
{
	DoorControl(player,entireNum,false);
} 

void r_GiveHolodisk(Critter&player,Critter@npc,int holodiskNum)
{
	Item@holo=player.AddItem((58),1);
	holo.HolodiskNumber=holodiskNum;
	holo.Update();
}

bool d_DuplKey(Critter&player,Critter@npc)
{
	Item@key=player.GetItem(0,(1));
	if(!(@key!=null)||key.GetType()!=(7))
	return false;
	return true;
}

bool d_isOwner(Critter&player,Critter@npc)
{
	return uint(npc.Stat[(81)])==player.Id;
}

void r_isOwner(Critter&player,Critter@npc)
{
	player.ShowContainer(npc,null,(8));
}

import void KeyUseScreen(Critter&player,uint answerI,string&answerS)from"item";

void r_DuplKey(Critter&player,Critter@npc)
{
	Item@key=player.GetItem(0,(1));
	if(!(@key!=null)||key.GetType()!=(7))
	return;
	Item@newKey=player.AddItem((1313),1);
	newKey.LockerId=key.LockerId;
	newKey.SetLexems("$KeyLex"+"some key");
	player.StatBase[(90)]=newKey.Id;
	player.ShowScreen((5),0,"item@KeyUseScreen");
	newKey.Update();
}

void give_dosimetr(Critter&player,Critter@npc)
{
	Item@dosimetr=player.AddItem((1540),1);
	dosimetr.Val1=Random(20,300);
	dosimetr.Val2=Random(20,550);
	
	dosimetr.SetLexems("указанны координаты "+dosimetr.Val1/10+" и "+dosimetr.Val2/10);
}

void get_cow(Critter&player,Critter@npc)
{
	Critter@[]brahmins;
	Map@map=player.GetMap();
	Item@flute=player.GetItem((1494),0);
	if((map.GetCritters((321),(0x03)|(0x20),brahmins)>0)&&map.Id==uint(flute.Val1))
	{
		for(uint i=0,ii=brahmins.length();i<ii;i++)
		{
			uint cuffs_state=brahmins[i].Stat[(182)];
			uint16 master=(cuffs_state)&0xFFFF;
			if(player.Id==master)
			{
				if(brahmins[i].Stat[(95)]>=5)
				{
					player.AddItem((41),100);
					DeleteNpc(brahmins[i]);
					
				}
				else
				DeleteNpc(brahmins[i]);
			}
		}
	}
}

void give_Package(Critter&player,Critter@npc,int destination)
{
	if(player.CountItem((1542))!=0)
	{
		npc.Say((1),"да ты уже с грузом");
		return;
	}
	Item@pack=player.AddItem((1542),1);
	pack.Val1=destination;
	string dest="";
	switch(destination)
	{
		case 1:
		dest="Отнести на склад Модока";
		npc.Say((1),"отнесите это Джо, его магазин недалеко от главных ворот");
		break;
		case 2:
		dest="Отнести на ферму";
		npc.Say((1),"отнесите это Филу, на ферму, сейчас он в отъезде, но может быть вы дождетесь его когда-нибудь");
		break;
		case 3:
		dest="Отнести мутанту на свалку";
		npc.Say((1),"отнесите это Туроку, это мутант на свалке, обычно в палатке сидит");
		break;
		case 4:
		dest="Отнести в Форт Саттер";
		npc.Say((1),"отнесите это Биллу, он в форте, обычно на нижинх этажах, скорее всего с генераторами возится");
		break;
	}
	pack.SetLexems(""+dest);
	if(FactionInGame(player,npc,6,2))
	pack.Val2=1;
	pack.Val3=player.Id;
	PackageAlarm(player,destination); 
	
}

void give_Package_chek(Critter&player,Critter@npc,int destination)
{
	Item@pack=player.GetItem((1542),0);
	if(pack.Val1==destination)
	{
		Item@chek=player.AddItem((1543),1);
		chek.Val1=pack.Val1;
		chek.Val2=pack.Val2;
		chek.Val3=pack.Val3;
		DeleteItem(pack);
		npc.Say((1),"спасибо, держите расписку о получении");
	}
	else
	npc.Say((1),"это не та посылка");
}

void get_Package_chek(Critter&player,Critter@npc,int late)
{
	Item@chek=player.GetItem((1543),0);
	if(@chek is null)return;
	
	int destination=chek.Val1,
	exp=0,payout=0;
	if(uint(chek.Val3)!=player.Id)
	late=1;
	switch(destination)
	{
		case 1:
		exp=20;
		payout=20;
		if(chek.Val2!=0)
		break;
		case 2:
		exp=50;
		payout=50;
		break;
		case 3:
		exp=80;
		payout=80;
		break;
		case 4:
		exp=150;
		payout=100;
		break;
	}
	if(chek.Val2!=0&&destination>=3&&late==0)
	{
		exp*=10;
		payout*=10;
	}
	if(late!=0)
	{
		npc.Say((1),"долго слишком, бери оплату");
		exp/=4;
		payout/=4;
	}
	else
	npc.Say((1),"бери оплату");
	if(uint(chek.Val3)==player.Id)
	player.StatBase[(76)]+=exp;
	player.AddItem((41),payout);
	DeleteItem(chek);
}

void getCure(Critter&player,Critter@npc)
{
	Item@hypo=player.AddItem((1550),1);
	GameVar@strain=GetGlobalVar((9970));
	hypo.Val1=0;
	hypo.Val2=0;
	hypo.Val3=strain.GetValue();
	hypo.SetLexems("$HypoLex"+" вакцина номер "+hypo.Val3);
	hypo.Update();
}

void giveCure(Critter&player,Critter@npc)
{
	Item@hypo=player.GetItem((1550),0);
	GameVar@strain=GetGlobalVar((9970));
	if((hypo.Val3>strain.GetValue())&&hypo.Val2>=50)
	strain.opAddAssign(hypo.Val3);
	npc.Say((1),"я должен сделать несколько тестов");
	DeleteItem(hypo);
}

void r_RadioLeroy2(Critter&player,Critter@npc,int p0,int p1,int p2)
{
	RadioMessage(0,"[Голос Лероя] Желающий в город у ворот");
}

void r_RadioLeroy1(Critter&player,Critter@npc,int p0,int p1,int p2)
{
	RadioMessage(0,"[Голос Лероя] Новое лицо у ворот");
}