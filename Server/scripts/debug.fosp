                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                               

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                        

import void AffectRadiation(Critter&cr,int value)from"radiation";
import void ApplyMutation(Critter&cr)from"morphes";
import void _MobInit(Critter&npc,bool firstTime)from"mob";
import void FlushScreen(Critter&cr,uint fromColor,uint toColor,uint timeMs)from"effects";
import void GM_MobInit(Critter&npc)from"mob";     

void CanabisPatrol(Critter&cr,int p0,int p1,int p2){
	Map@map=cr.GetMap();
	if(!(@map!=null)){
		cr.Say((11),"На глобале нельзя!");
		return;
	}
	
	int[]CanabisPid={1630,1631,1632,1633,1634}; 
	
	int[]count={0,0,0,0,0};
	string[]names={"Пакетов семян","Гектаров полей","Пачек травы"};
	for(int i=0,iEnd=CanabisPid.length();i<iEnd;i++)
	count[i]=WorldItemCount(CanabisPid[i]);
	
	string result="Наркоконтроль сообщает, что всего в мире:\n"+
	names[0]+": "+count[0]+";\n"+
	names[1]+": "+count[1]+"/"+count[2]+"/"+count[3]+";\n"+
	names[2]+": "+count[4]+";\n";
	cr.Say((11),result); 
	
	int[]count2={0,0,0,0,0};
	
	Critter@[]holder;
	map.GetCritters(0,(0x01),holder);
	for(int i=0,iEnd=holder.length();i<iEnd;i++){
		Item@[]item;
		holder[i].GetItems(-1,item);
		for(int j=0,jEnd=item.length();j<jEnd;j++){
			if(!(@item[j]!=null))continue;
			int n=CanabisPid.find(item[j].GetProtoId());
			if(n!=-1){
				count2[n]+=item[j].GetCount();
				DeleteItem(item[j]);
			}
		}
	}
	
	Item@[]drug;
	for(int i=0,iEnd=CanabisPid.length();i<iEnd;i++)
	count2[i]+=map.GetItems(CanabisPid[i],drug);
	
	for(int i=0,iEnd=drug.length();i<iEnd;i++){
		switch(drug[i].Accessory){
			case((2)):
			map.SetText(drug[i].HexX,drug[i].HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"густой дым");
			break;  
			
			default:break;
		}
		if((@drug[i]!=null))
		DeleteItem(drug[i]);
	}
	
	result="На этой локации было уничтожено:\n"+
	names[0]+": "+count2[0]+";\n"+
	names[1]+": "+count2[1]+"/"+count2[2]+"/"+count2[3]+";\n"+
	names[2]+": "+count2[4]+";\n";
	cr.Say((11),result);
}               

void unsafe_ExpToSp(Critter&cr,int value,int cost,int p2,string@message,int[]@p4)
{
	if(cr.StatBase[(76)]-value*cost<66000){
		cr.Say((11),"Отличная попытка, но.. нет.");
		return;
	}
	cr.StatBase[(76)]-=value*cost;
	cr.StatBase[(78)]+=value;
	cr.Say((11),"Вы конвертировали "+(value*cost)+" опыта в "+value+" скиллпоинтов!");
}

void unsafe_ExpToPp(Critter&cr,int value,int cost2,int p2,string@message,int[]@p4)
{
	if(cr.StatBase[(76)]-value*cost2<66000){
		cr.Say((11),"Отличная попытка, но.. нет.");
		return;
	}
	cr.StatBase[(76)]-=value*cost2;
	cr.StatBase[(79)]+=value;
	cr.Say((11),"Вы конвертировали опыт в "+value+" перкпоинтов!");
}

void FastLoot(Critter&player,int param0,int param1,int param2)
{
	Item@[]loot,empty;
	Item@[]container;
	Map@map=player.GetMap();
	if(!(@map!=null)){player.Say((11),"На глобале нельзя!");return;}
	map.GetItemsByType((8),container);
	uint len=container.length();
	
	int locked=0;
	for(uint i=0;i<len;i++)
	{
		if(container[i].LockerCondition!=(0x02))
		{
			container[i].GetItems(uint(-1),loot);
			MoveItems(loot,player);
			loot=empty;
		}
		else locked++;
	}
	player.Say((11),"Вы облутали "+len+" контейнеров, из них "+locked+" были приватными.");
	if(param0!=0&&param1!=0&&param2!=0)
	DifferLoot(player,param0,param1,param2);
}

void CheckLoot(Critter&player,int param0,int param1,int param2)
{
	Item@[]loot;
	if(param0!=0)
	{
		Map@map=player.GetMap();
		if(!(@map!=null)){player.Say((11),"На глобале нельзя!");return;}
		Item@LootBox=map.GetItem(param0);
		if(!(@LootBox!=null)){player.Say((11),"Контейнер не найден!");return;}
		LootBox.GetItems(uint(-1),loot);
	}
	else
	player.GetItems(-1,loot);
	Item@item=null;
	uint count=0,allc=0,allp=0,price=0,pid=0;
	for(uint i=0,iEnd=loot.length();i<iEnd;i++)
	{
		@item=@loot[i];
		pid=item.GetProtoId();
		count=item.Proto.Stackable?item.GetCount():1;
		price=item.GetCost();
		player.Say((11),i+") "+pid+" x"+count+"("+item.Proto.Cost+"$) "+price+"$");
		allc+=count;
		allp+=price;
	}
	player.Say((11),"Всего "+allc+" объектов общей стоимостью "+allp+"$");
}

void DifferLoot(Critter&player,int param0,int param1,int param2)
{
	if(param0==0||param0==1||param2==0)
	{
		player.Say((11),"Укажите id для трёх целевых контейнеров сортировки:\n1) Оружие и броня.\n2) Ключи, наркотики и патроны.\n3) Остальное.");
		return;
	}
	
	Map@map=player.GetMap();
	
	if(!(@map!=null)){player.Say((11),"На глобале нельзя!");return;}
	
	Item@GearBox=map.GetItem(param0);
	Item@DrugBox=map.GetItem(param1);
	Item@StuffBox=map.GetItem(param2);
	
	if(!(@GearBox!=null)||!(@StuffBox!=null)||!(@StuffBox!=null)){player.Say((11),"Отсутствует один из контейнеров!");return;}
	
	Item@item;
	Item@[]items;
	player.GetItems(-1,items);
	
	uint16 count,c1,c2,c3,allc,i,pid;
	uint32 price,p1,p2,p3,allp;
	count=c1=c2=c3=allc=i=pid=price=p1=p2=p3=allp=0;
	for(i=0;i<items.length();i++)
	{
		@item=@items[i];
		pid=item.GetProtoId();
		count=GetProtoItem(pid).Stackable?item.GetCount():1;
		price=item.GetCost();
		switch(items[i].GetType())
		{
			case((1)):
			case((3)):
			c1+=count;
			p1+=price;
			MoveItem(item,count,GearBox,0);
			break;
			case((2)):
			case((4)):
			case((7)):
			c2+=count;
			p2+=price;
			MoveItem(item,count,DrugBox,0);
			break;
			case((5)):
			
			c3+=count;
			p3+=price;
			MoveItem(item,count,StuffBox,0);
			break;
			default:continue;
		}
	}
	allc=c1+c2+c3;
	allp=p1+p2+p3;
	player.Say((11),"Вы распределили "+i+" стэков по категориям:"+
	"\n1) Оружие и броня x"+c1+" на "+p1+"$"+
	"\n2) Ключи, наркотики и патроны x"+c2+" на "+p2+"$"+
	"\n3) Остальное x"+c3+" на "+p3+"$"+
	"\n Итого x"+allc+" объектов на сумму в "+allp+"$");
}

void Radiate(Critter&player,int param0,int param1,int param2)
{
	Critter@target=null;
	if(param0==0)
	@target=player;
	else
	@target=GetCritter(param0);
	AffectRadiation(target,param1);
}

void Mutate(Critter&player,int param0,int param1,int param2)
{
	Critter@target=null;
	if(param0==0)
	@target=player;
	else
	@target=GetCritter(param0);
	ApplyMutation(target);
}

void ViewPlanes(Critter&player,int param0,int param1,int param2)
{
	if(param0==0)
	param0=20;
	
	Map@map=player.GetMap();
	if(not(@map!=null))
	return;
	
	Critter@[]critters;
	uint count=0;
	if(param1==0)
	count=map.GetCrittersHex(player.HexX,player.HexY,param0,(0x0F)|(0x20),critters);
	else
	{
		Critter@cr=GetCritter(param1);
		if(not(@cr!=null))
		return;
		critters.resize(1);
		@critters[0]=cr;
	}
	
	for(uint i=0;i<count;i++)
	{
		NpcPlane@[]p;
		uint pcount=critters[i].GetPlanes(p);
		for(uint j=0;j<pcount;j++)
		{
			uint[]param={critters[i].Id,p[j].Type,p[j].Priority};
			switch(p[j].Type)
			{
				case(0):
				param.resize(5);
				param[3]=p[j].Misc_WaitSecond;
				param[4]=p[j].Misc_ScriptId;
				break;
				case(1):
				param.resize(5);
				param[3]=p[j].Attack_TargId;
				param[4]=p[j].Attack_MinHp;
				break;
				case(2):
				param.resize(8);
				param[3]=p[j].Walk_HexX;
				param[4]=p[j].Walk_HexY;
				param[5]=p[j].Walk_Dir;
				if(p[j].Run)
				param[6]=1;
				else
				param[6]=0;
				param[7]=p[j].Walk_Cut;
				break;
				case(3):
				param.resize(6);
				param[3]=p[j].Pick_HexX;
				param[4]=p[j].Pick_HexY;
				param[5]=p[j].Pick_Pid;
				break;
			}
			CreateTimeEvent(__FullSecond+60+j,"e_ViewPlanes",param,false);
		}
	}
}

uint e_ViewPlanes(uint[]@values)
{
	Critter@crit=GetCritter(values[0]);
	if(not(@crit!=null))
	return 0;
	
	string msg="error";
	switch(values[1])
	{
		case(0):
		msg="<<MISC>> Prior="+values[2];
		msg+=" WaitMinute="+values[3]+" ScriptId="+values[4];
		break;
		case(1):
		msg="<<ATTACK>> Prior="+values[2];
		msg+=" TargId="+values[3]+" MinHp="+values[4];
		break;
		case(2):
		msg="<<WALK>> Prior="+values[2];
		msg+=" HexX="+values[3]+" HexY="+values[4]+" Dir="+values[5];
		msg+=" Run="+values[6]+" Cut="+values[7];
		break;
		case(3):
		msg="<<PICK>> Prior="+values[2];
		msg+=" HexX="+values[3]+" HexY="+values[4]+" Pid="+values[5];
		break;
	}
	
	crit.Say((2),msg);
	return 0;
}   

import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";  

void lvl(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(77)]));
}

void team(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(106)]));
}

void role(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(89)]));
}

void info(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[param0]));
}

void hp(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(72)])+"/"+""+(critters[i].Stat[(7)]));
} 

void planc(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].GetPlanes(null)));
} 

void plans(Critter&player,int param0,int param1,int param2)
{
	NpcPlane@[]planes;
	string str;
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	{
		str="";
		uint count=critters[i].GetPlanes(planes);
		for(uint j=0;j<count;j++)
		{
			switch(planes[j].Type)
			{
				case(0):
				str=str+"M ";
				break;
				case(1):
				str=str+"A ";
				break;
				case(2):
				str=str+"W ";
				break;
				case(3):
				str=str+"P ";
				break;
				case(4):
				str=str+"P ";
				break;
				case(5):
				str=str+"C ";
				break;
			}
		}
		critters[i].Say((2),str);
	}
} 

void lvli(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16)*2,(0x01)|(0x10),critters);
	for(uint i=0;i<count;i++)
	player.Say((11),GetPlayerName(critters[i].Id)+": "+""+(critters[i].Stat[(77)]));
}

void dmg(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	InjureCritter(target,param1,param2,0,player.Id);
}

void kill(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	target.Say((11),"Кара небесная поразила вас!");
	target.ToDead((param1==0?(114):param1),player);
	
}

void body(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	target.ChangeCrType(param1);
}

void anim(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	target.Animate(param1,param2,null,true,true);
}

void testmap(Critter&player,int param0,int param1,int param2)
{
	Critter@[]groups;
	groups.insertLast(@player);
	uint locid=CreateLocation(
	(param1==0?400:param1),player.WorldX,player.WorldY,groups);
	Location@loc=GetLocation(locid);
	
	if(not(@loc!=null))
	{
		player.Say((11),"Location not found");
		return;
	}
	Map@map;
	if(param0!=0)
	@map=loc.GetMap(param0);
	else
	@map=loc.GetMapByIndex(0);
	if(not(@map!=null))
	return;
	player.TransitToMap(map.Id,0);
} 

void _ctd(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	ctd(player,param0,param1,param2);
} 

void ctd(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	
	Critter@daddy=((param2!=0)?target:player);
	Critter@child=((param2==0)?target:player); 
	
	Map@map=daddy.GetMap();
	if(not(@map!=null))
	return;
	
	if(child.Quest[(703)]==(0)&&daddy.GetAccess()<=(2))
	{
		child.Say((11),"Игрок в стартовом режиме, его нельзя телепортировать.");
		return;
	} 
	
	uint8 temp_dir=Random(0,5);
	for(uint i=0;i<6;i++)
	{
		uint16 hexX=daddy.HexX,hexY=daddy.HexY;
		map.MoveHexByDir(hexX,hexY,(temp_dir+i)%6,1+param1);
		if(not map.IsHexPassed(hexX,hexY))
		continue;
		child.TransitToMap(map.Id,hexX,hexY,0);
		break;
	}
	
}

void CalmDown(Critter&player,int crId,int param1,int param2)
{
	Critter@cr=GetCritter(crId);
	if(!(@cr!=null)||cr.IsPlayer())
	{
		player.Say((11),"НПЦ не найдет");
		return;
	}
	else
	cr.ClearEnemyStack();
}

void god(Critter&player,int,int,int)
{
	for(uint i=(0);i<=(6);i++)
	player.StatBase[i]=10;
	for(uint i=(16);i<=(22);i++)
	player.StatBase[i]=100;
	for(uint i=(23);i<=(31);i++)
	player.StatBase[i]=100;
	for(uint i=(200);i<=(217);i++)
	player.SkillBase[i]=300;
	player.StatBase[(10)]=999;
	player.StatBase[(9)]=100;
	player.StatBase[(72)]=9999;
	player.StatBase[(7)]=9999;
}

void GM_god(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	for(uint i=(0);i<=(6);i++)
	player.StatBase[i]=10;
	for(uint i=(200);i<=(217);i++)
	player.SkillBase[i]=300;
	player.PerkBase[(315)]=100;
	player.PerkBase[(314)]=10;
	player.PerkBase[(316)]=1;
	player.PerkBase[(301)]=2;
	player.PerkBase[(344)]=3;
	player.StatBase[(7)]=120;
	player.StatBase[(72)]=9999;
	player.ModeBase[(510)]=1;
	player.ModeBase[(524)]=1;
	player.ModeBase[(527)]=1;
	player.ModeBase[(511)]=1;
}

void mapid(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	player.Say((11),""+(map.GetProtoId()));
}

void GM_tele(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	tele(player,param0,param1,param2);
}

void tele(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	Location@loc=GetLocationByPid((param1==0?player.GetMap().Id:param1),0);
	if(not(@loc!=null))
	{
		player.Say((11),"Location not found");
		return;
	}
	Map@map=loc.GetMapByIndex(param2);
	if(not(@map!=null))
	{
		player.Say((11),"Map index not found");
		@map=loc.GetMapByIndex(0);
		if(not(@map!=null))
		return;
	}
	
	target.SetWorldPos(loc.WorldX,loc.WorldY);
	target.TransitToMap(map.Id,0);
}

void items(Critter&player,int param0,int param1,int param2)
{
	Item@[]items;
	uint count=player.GetMap().GetItems(player.HexX,player.HexY,items);
	for(uint i=0;i<count;i++)
	player.Say((11),""+items[i].GetProtoId());
}

void id(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Id));
}     

void ToMapEntire(Critter&player,int mapPid,int entire,int skip)
{
	Map@map=::GetMapByPid(mapPid,skip);
	if((@map!=null))
	{
		player.TransitToMap(map.Id,entire);
	}
	else
	{
		player.Say((11),"Карта с pid="+mapPid+" не найдена");
	}
}

void ToMap(Critter&player,int mapPid,int X,int Y)
{
	Map@map=GetMapByPid(mapPid,0);
	if((@map!=null))
	{
		player.TransitToMap(map.Id,X,Y,0);
	}
	else
	{
		player.Say((11),"Карта с pid="+mapPid+" не найдена");
	}
} 

void NpcByDialog(Critter&player,int mapPid,int dialog,int)
{
	Map@map=::GetMapByPid(mapPid,0);
	if((@map!=null))
	{
		Critter@[]npc;
		
		if(map.GetCritters(0,(0x0F)|(0x20),npc)==0)
		{
			
			player.Say((11),"не найдено нпц с таким диалогом");
			
		}
		else
		{
			uint idF=0;
			uint l=0;
			for(uint i=0;i<npc.length();i++)
			{
				if(npc[i].Stat[(104)]==dialog)
				{
					l++;
					idF=(idF==0?npc[i].Id:idF);
				}
			}
			player.Say((11),"Найдено нпц, в штуках:"+l+" Id первого:"+idF);
		}
	}
	
}

void SetReputation(Critter&cr,int crId,int num,int val)
{
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	toCr.ReputationBase[num]=val;
}

void Siren(Critter&cr,int,int,int)
{
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		cr.Say((11),"Невозможно проиграть звук на глобальной карте");
		return;
	}
	map.PlaySound("AIRSIREN.OGG");
}

void Mirelurk(Critter&cr,int,int,int)
{
	cr.GetMap().AddNpc(487,cr.HexX-3,cr.HexY-3,0,null,null,null);
	
}         

void SetMode(Critter&cr,int id,int mode,int value)
{
	Critter@crit=GetCritter(id);
	crit.ModeBase[mode]=value;
}

void RunMapLoop(Critter&player,int ms,int param1,int param2)
{
	Map@map=player.GetMap();
	map.SetLoopTime(0,ms);
	map.SetLoopTime(1,ms+500);
	map.SetEvent((1),"e_Map_Loop_0_Run");
	map.SetEvent((2),"e_Map_Loop_1_Run"); 
	
}

void e_Map_Loop_0_Run(Map&map)
{
	map.SetLoopTime(0,3000);
	Display_Ms_Msg(map);
}

void e_Map_Loop_1_Run(Map&map)
{
	map.SetLoopTime(1,3000);
	Display_Ms_Msg(map);
}

void Display_Ms_Msg(Map&map)
{
	uint16 year=0,month=0,week=0,day=0,hour=0,minute=0,sec=0,ms=0;
	Critter@[]critArr(1);
	map.GetCritters(0,(0x0F),critArr);
	
	if(critArr.length()==0)
	Log("Не найдено криттеров");
	else
	{
		
		Critter@crt=critArr[critArr.length()-1];
		GetTime(year,month,week,day,hour,minute,sec,ms);
		crt.Say((3),"Current local second "+sec+","+ms);
	}
}

void Check_Dict_Element(Critter&player,int,int,int)
{
	dictionary dict;
	dict.set(player.Id+"|"+1,1);
	dict.set(player.Id+"|"+2,2);
	dict.set(player.Id+"|"+3,3);
	if(dict.exists(player.Id+"|*"))
	player.Say((1),"Словарь обрабатывает звездочку в ключе");
	else
	player.Say((1),"Хуй вам, словарь не обрабатывает звездочку в ключе");
}

void SetRain(Critter&player,int capacity,int param1,int param2)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	return;
	map.SetRain(capacity);
} 

void GetCapacityRain(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	return;
	player.Say((11),"Rain power: "+map.GetRain());
}

void GetParam(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.Param[num]);
}

void GetParamBase(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.ParamBase[num]);
}

void SetParam(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	{
		toCr.ParamBase[num]=val;
		player.Say((11),"Done.");
	}
}

void GetId(Critter&player,int playerId,int param1,int param2)
{
	player.ShowScreen((0),0,"");
	player.ShowScreen((5),0,"answer_GetId");
	player.Say((39),"Введите логин персонажа.");
}

void answer_GetId(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()<3)
	return;
	
	Critter@cr=GetPlayer(answerS);
	
	if(!(@cr!=null))
	{
		player.Say((11),"Нет такого персонажа.");
		return;
	}
	
	player.Say((11),"Login: "+answerS+" Id: "+cr.Id);
}

void NetId(Critter&player,int searchRadius,int,int)
{
	Critter@[]crits;
	player.GetMap().GetCrittersHex(player.HexX,player.HexY,searchRadius,(0x0F),crits);
	player.Say((11),"my info: HexX="+player.HexX+"; HexY="+player.HexY+"; SearchRadius="+searchRadius);
	for(uint i=0;i<crits.length();i++)
	{
		player.Say((11),"Critter Pid:"+crits[i].GetProtoId()+"; Dialog:"+crits[i].Stat[(104)]+"; Id:"+crits[i].Id);
	}
	player.Say((11),"Total: "+crits.length());
}

void SetCritParam(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		cr.ParamBase[param]=value;
	}
}

void GetCritParam(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		player.Say((11),"Param #"+param+" val= "+cr.Param[param]);
	}
}

void ShowLocation(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	if((@map!=null))
	{
		Location@loc=map.GetLocation();
		if((@loc!=null)&&!loc.Visible)
		loc.Visible=true;
	}
}  

void GetMap(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	string str=map.Id;
	player.Say((11),"КАРТА - "+str);
	str=player.HexX+" "+player.HexY;
	player.Say((11),"Координаты - "+str);
	str=player.Dir;
	player.Say((11),"Направление - "+str);
}

void GetEnemyStack(Critter&player,int crId,int param1,int param2)
{
	uint[]enemyStack;
	uint x=0;
	string str;
	Critter@cr=GetCritter(crId);
	if(!(@cr!=null))
	player.Say((11),"Криттер не найдет");
	else if(cr.IsPlayer())
	player.Say((11),"Криттер не является НПЦ");
	else
	{
		cr.GetEnemyStack(enemyStack);
		player.Say((11),"Список врагов:");
		while(x<enemyStack.length())
		{
			str="";
			str+=x;
			str+=": ";
			str+=enemyStack[x];
			player.Say((11),str);
			x++;
		}
	}
	
}                                        

void deleteCritter(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	DeleteNpc(cr);
}

void rotateCritter(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		cr.SetHomePos(cr.HexX,cr.HexY,param);
		cr.SetDir(param);
	}
}

void changeHome(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	cr.SetHomePos(x,y,0);
}

void GM_tel(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if((@cr!=null))
	cr.TransitToHex(param1,param2,cr.Dir);
}

void teleportCritter(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	cr.TransitToHex(x,y,0);
}

void getCoords(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	player.Say((11),"X = "+cr.HexX+" Y = "+cr.HexY);
}

void GM_lock(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(param0);
	if((@item!=null))
	lock(player,param0,param1,param2);
}

void lock(Critter&player,int itemId,int complexity,int lockId)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(itemId);
	if((@item!=null))
	{
		item.LockerCondition=(0x02);
		item.LockerComplexity=complexity;
		item.LockerId=lockId;
		item.Update();
		Item@key=player.AddItem((82),1);
		if((@key!=null))
		key.LockerId=lockId;
		key.Update();
	}
}

void unlock(Critter&player,int itemId,int param,int param2)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(itemId);
	
	if((@item!=null))
	{
		item.LockerCondition=(0x01);
		item.LockerComplexity=0;
		item.LockerId=0;
		item.Update();
	}
}

void cleanEnemyStacks(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	Critter@[]crits;
	uint crCount=map.GetCritters(0,(0x01),crits);
	for(uint i=0;i<crCount;++i)
	{
		if(crits[i].IsNpc())
		{
			crits[i].ClearEnemyStack();
			crits[i].DropPlanes();
		}
	}
} 

void SetSkin(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	if(target.ChangeCrType(param1))
	target.StatBase[(112)]=param1;
}

void CreateLoc(Critter&player,int param0,int param1,int param2)
{
	CreateLocation(param0,param1,param2,null);
}

void DeleteLoc(Critter&player,int param0,int param1,int param2)
{
	Location@loc=GetLocationByPid(param0,0);
	DeleteLocation(loc.Id);
}

void getMapId(Critter&cr,int param0,int param1,int param2)
{
	Map@map=cr.GetMap();
	if(!(@map!=null))
	return;
	string msg=map.Id;
	
	Location@loc=map.GetLocation();
	if(!(@loc!=null))
	{
		msg+="loc err";
	}
	else
	{
		msg+=" "+loc.Id;
	}
	cr.Say((11),msg);
	
}

void setcoolarmor(Critter&cr,int p0,int p1,int p2)
{
	if(p1==0)
	{
		cr.Say((11),"invalid armor pid (second parameter)");
		return;
	}
	;
	Critter@target=GetCritter((p0==0?cr.Id:p0));
	Item@armor=target.GetItem(p1,(0));
	if(!(@armor!=null))
	{
		cr.Say((11),"armor !valid");
		return;
	}
	armor.Val1=target.Id;
	armor.Val2=target.StatBase[(112)];
	cr.Say((11),"BaseCrTypeTarget "+armor.Val2);
	armor.SetScript("debug@_CoolArmor");
	armor.Update();
} 

void _CoolArmor(Item&armor,bool firstTime)
{
	if(firstTime)
	{
		armor.SetEvent((6),"e_ArmorMove");
	}
}

void e_ArmorMove(Item&item,Critter&cr,uint8 fromSlot)
{
	string msg=fromSlot+" "+item.CritSlot;
	cr.Say((11),msg);
	if(uint(item.Val1)!=cr.Id)return;
	
	if((item.CritSlot==(1)||item.CritSlot==(1))&&fromSlot==(0))
	{
		cr.ChangeCrType(3);
		cr.MoveItem(item.Id,item.GetCount(),(3));
		cr.Action((2),(3),item);
		cr.Action((23),0,null);
		item.Update();
	}
}

import uint GetAllPlayers(Critter@[]&crs)from"manager";

void GetAllPl(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	string msg;
	GetAllPlayers(crs);
	if(crs.length()>0)
	{
		msg=crs.length();
		cr.Say((11),msg);
	}
}

void delItem(Critter&cr,int p0,int p1,int p2)
{
	if(p0!=1)
	{
		Item@item=cr.GetMap().GetItem(p1);
		if(!(@item!=null))
		return;
		DeleteItem(item);
	}
	else
	{
		Item@[]items;
		cr.GetMap().GetItems(p1,items);
		if(items.length()>0)
		{
			DeleteItems(items);
		}
	}
}

void ChangeProtoItems(Critter&cr,int new,int,int)
{
	Item@[]items;
	cr.GetItems((0),items);
	for(uint i=0,iEnd=items.length();i<iEnd;i++)
	{
		if(@GetProtoItem(new)!is null)
		items[i].ChangeProto(new);
	}
}

void setblankscript(Critter&cr,int p0,int p1,int p2)
{
	Item@item=GetItem(p0);
	if(!(@item!=null))
	return;
	item.SetScript("");
}

void spawnmob(Critter&cr,int p0,int p1,int p2)
{
	uint16 hexX=0,hexY=0;
	Critter@[]crs;
	Critter@mob;
	Map@map=cr.GetMap();
	map.GetEntireCoords(p2,0,hexX,hexY);
	map.GetCritters(0,(0x01),crs);
	for(uint8 i=0;i<p1;i++)
	{
		@mob=map.AddNpc(p0,hexX+Random(-5,5),hexY+Random(-5,5),Random(0,5),null,null,null);
		mob.AddEnemyInStack(cr.Id);
	}
}

void delmob(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	Map@map=cr.GetMap();
	p1=(p1==0?(0x04):(0x0F));
	map.GetCritters(p0,p1,crs);
	for(uint16 i=0;i<crs.length();i++)
	{
		DeleteNpc(crs[i]);
	}
}

void getadmin(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	string msg;
	GetAllPlayers(crs);
	for(uint8 i=0;i<crs.length();i++)
	{
		if(crs[i].GetAccess()>=(1))
		{
			msg+="player "+GetPlayerName(crs[i].Id)+" id "+crs[i].Id+" access "+crs[i].GetAccess()+"\n";
		}
	}
	cr.Say((11),msg);
}

void getAllPls(Critter&cr,int p1,int p2,int p3)
{               
	
	Critter@[]crs;
	GetAllPlayers(crs);
	for(uint i=0;i<crs.length();i++)
	{
		if(crs[i]is null)
		continue;
		cr.Say((11)," i "+i+" id= "+crs[i].Id+" access "+crs[i].GetAccess());
	}    
	
} 

void openDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	item.LockerOpen();
}

void closeDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	item.LockerClose();
}

void BlockHex(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	map.BlockHex(cr.HexX+p1,cr.HexY+p2,p3!=0);
}

void UnblockHex(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	map.UnblockHex(cr.HexX+p1,cr.HexY+p2);
}

void noopenDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@door=GetItem(uint(p1));
	if(door is null)
	return;
	if(p2==0)
	(door.LockerCondition=(door.LockerCondition)|((0x10)));
	else
	(door.LockerCondition=((door.LockerCondition)&(~((0x10)))));
}

void clearDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@door=GetItem(uint(p1));
	if(door is null)
	return;
	
	door.LockerClose();
	
	door.LockerCondition=0;
	door.LockerId=0;
	door.LockerComplexity=0;
	door.Val0=0;
	door.Val1=0;
}

void di(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	DeleteItem(item);
}

void setScale(Critter&cr,int p1,int p2,int p3)
{
	cr.StatBase[(116)]=p1;
}

void knock(Critter&player,int id,int param1,int param2)
{
	Critter@cr=GetCritter(id);
	cr.Say((6),"теряет сознание");
	cr.ToKnockout(((true)?(82):(83)),((true)?(86):(87)),((true)?(88):(89)),100,cr.HexX,cr.HexY);
}

import void ApplyGhoul(Critter&cr)from"morphes";

void makeGhoul(Critter&cr,int p1,int p2,int p3)
{
	Critter@target=GetCritter(p1!=0?p1:cr.Id);
	if(@target==null)
	{
		cr.Say((11),"something wrong");
		return;
	}
	ApplyGhoul(target);
}

void AddMine(Critter&cr,int,int,int)
{
	Item@item=cr.GetMap().AddItem(cr.HexX+1,cr.HexY+1,(545),1);
	item.SetScript("_MineInit");
}

void _MineInit(Item&item,bool firstTime)
{
	item.TrapValue=150;
	(item.Flags=(item.Flags)|((0x00020000)));
	item.SetEvent((7),"explode@_MineWalk");
	item.Update();
}       

void liststats(Critter&cr,int p0,int p1,int)
{
	Critter@target=GetCritter((p0==0?cr.Id:p0));
	for(uint16 i=(0);i<(199);i++)
	{
		cr.Say((11),"id "+target.Id+" stat "+i+" "+target.Stat[i]);
	}
	
	for(uint16 i=(__SkillBegin);i<(__SkillEnd);i++)
	{
		cr.Say((11),"id "+target.Id+" skill "+i+" "+target.Skill[i]);
	}
}

void HideAllMaps(Critter&cr,int,int,int)
{
	Critter@[]crs;
	uint crLen=GetAllPlayers(crs);
	
	Location@[]locations;
	uint len=GetAllLocations(0,locations);
	
	for(uint i=0;i<len;i++)
	{
		Location@loc=locations[i];
		if(loc is null)
		continue;
		
		if(loc.Visible)
		{
			loc.Visible=false;
			Log("Скрыта локация "+loc.Id);
		}
		
		loc.GeckVisible=false;
		
		for(uint k=0;k<crLen;k++)
		{
			if(crs[k].UnsetKnownLoc(true,loc.Id))
			Log("Стерта для "+crs[k].Id);
		}
	}
}

void GM_setcodedoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	setcodedoor(player,param0,param1,param2);
}

void setcodedoor(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	
	cr.Say((11),"Просто предупреждаю, что интерфейс электронного замка НЕ СПОСОБЕН принимать комбинации большие чем 65536, т.е. максимальное количество разрядов у нормального пароля равно 4!");
	item.Val0=4;
	item.Val1=p1+1;
	item.Val4=p3!=0?p3:Random(pow(10,item.Val1),pow(10,(item.Val1+1))-1);
	cr.Say((11),"code "+item.Val4);
	item.LockerComplexity=Random(50,200);
	(item.LockerCondition=(item.LockerCondition)|((0x20)));
	item.Update();
}

void Flushblack(Critter&player,int p0,int p1,int p3,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(p0);
	FlushScreen(cr,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),p1);
}

void GiveItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	cr.AddItem(param1,1);
}

void GM_mobinit(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	cr.StatBase[(106)]=33;
	GM_MobInit(cr);
}

void GM_GetParam(Critter&player,int crId,int param1,int param2,string@param3,int[]@param4)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.Param[param1]);
}

void GM_SetParam(Critter&player,int crId,int param1,int param2,string@param3,int[]@param4)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	{
		toCr.ParamBase[param1]=param2;
		player.Say((11),"Done.");
	}
}

void GM_liststats(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@target=GetCritter(param0);
	for(uint16 i=(0);i<(199);i++)
	{
		player.Say((11),"id "+target.Id+" stat "+i+" "+target.Stat[i]);
	}
	
	for(uint16 i=(__SkillBegin);i<(__SkillEnd);i++)
	{
		player.Say((11),"id "+target.Id+" skill "+i+" "+target.Skill[i]);
	}
}

void GM_openDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(uint(param0));
	if(item is null)
	return;
	
	item.LockerOpen();
}

void GM_closeDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(uint(param0));
	if(item is null)
	return;
	
	item.LockerClose();
}

void GM_noopenDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(uint(param0));
	if(door is null)
	return;
	if(param1==0)
	(door.LockerCondition=(door.LockerCondition)|((0x10)));
	else
	(door.LockerCondition=((door.LockerCondition)&(~((0x10)))));
}

void GM_clearDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(uint(param0));
	if(door is null)
	return;
	
	door.LockerClose();
	
	door.LockerCondition=0;
	door.LockerId=0;
	door.LockerComplexity=0;
	door.Val0=0;
	door.Val1=0;
}

funcdef void GM_deleteCritterdef(Critter&critter);

void DeleteCritter_all(Critter&critter)
{
	DeleteNpc(critter);
}

void DeleteCritter_default(Critter&critter)
{
	if(critter.KindIndex!=0)
	DeleteNpc(critter);
}

void DeleteCritter_deads(Critter&critter)
{
	if(critter.IsDead())
	DeleteNpc(critter);
}

void GM_deleteCritter(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	if(param1==0)
	{
		Critter@critter=GetCritter(param0);
		if(!(@critter!=null))return;
		DeleteNpc(critter);
	}
	else
	{
		GM_deleteCritterdef@delete=@DeleteCritter_default;
		if(@param3!is null)
		{
			if(param3=="all")
			@delete=@DeleteCritter_all;
			else if(param3=="dead")
			@delete=@DeleteCritter_deads;
		}
		Critter@[]critters(0);
		Map@map=player.GetMap();
		for(uint i=0,iEnd=map.GetCrittersHex(param1,param2,param0,(0x0F)|(0x20),critters);i<iEnd;i++)
		if(@critters[i]!is null)
		delete(critters[i]);
	}
}

void GM_delItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	if(param1==0)
	{
		Item@item=player.GetMap().GetItem(param0);
		if(!(@item!=null))
		return;
		DeleteItem(item);
	}
	else
	{
		Item@[]items(0);
		Map@map=player.GetMap();
		for(uint16 x=param1-param0,xMax=param1+param0;x<xMax;x++)
		for(uint16 y=param2-param0,yMax=param2+param0;y<yMax;y++)
		map.GetItems(x,y,items);
		DeleteItems(items);
	}
}

void GM_brokeItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(param0);
	if(!(@item!=null))
	return;
	item.Deterioration=param1;
	player.Say((11),"предмет "+item.Id+" сломан на "+param1);
	item.Update();
}

void viewarcadepop(Critter&cr,int clear,int,int)
{
	GameVar@firegeckoNow=GetGlobalVar((9952));
	GameVar@alienNow=GetGlobalVar((9951));
	GameVar@deathclawNow=GetGlobalVar((9950));
	GameVar@flocentNow=GetGlobalVar((9953));
	GameVar@clawNow=GetGlobalVar((9955));
	GameVar@clawKidNow=GetGlobalVar((9954));
	
	GameVar@firegecko=GetGlobalVar((9941));
	GameVar@alien=GetGlobalVar((9940));
	GameVar@deathclaw=GetGlobalVar((9939));
	GameVar@flocent=GetGlobalVar((9942));
	
	if(clear>0)
	{
		firegeckoNow.opAssign(0);
		alienNow.opAssign(0);
		deathclawNow.opAssign(0);
		clawNow.opAssign(0);
		clawKidNow.opAssign(0);
		flocentNow.opAssign(0);
	}
	
	cr.Say((11),"firegecko : "+firegeckoNow.GetValue()+"\nalien : "+alienNow.GetValue()+"\ndeathclaw : "+deathclawNow.GetValue()+"\nclaw : "+clawNow.GetValue()+"\nclawkid :"+clawKidNow.GetValue()+"\nflocent : "+flocentNow.GetValue());
	cr.Say((11),"\neggs\nfiregecko : "+firegecko.GetValue()+"\nalien : "+alien.GetValue()+"\ndeathclaw : "+deathclaw.GetValue()+"\nflocent : "+flocent.GetValue());
}

void testcte(Critter&cr,int p0,int p1,int)
{
	for(uint8 i=0;i<=p1;i++)
	{
		cr.AddTimeEvent("cte_test",p0+Random(p0,p0*3),(39),i);
	}
}

uint cte_test(Critter&cr,int identifier,uint&rate)
{
	cr.Say((11),"test cte "+rate);
	return 0;
}

void itemsetval(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	switch(p1)
	{
		case 0:
		item.Val0=p3;
		break;
		case 1:
		item.Val1=p3;
		break;
		case 3:
		item.Val2=p3;
		break;
		case 4:
		item.Val4=p3;
		break;
		case 5:
		item.Val5=p3;
		break;
		case 6:
		item.Val6=p3;
		break;
		case 7:
		item.Val7=p3;
		break;
		
		default:
		break;
	}
	
}

void itemgetval(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	string msg=""+item.Val0+"\n"+
	item.Val1+"\n"+
	item.Val2+"\n"+
	item.Val3+"\n"+
	item.Val4+"\n"+
	item.Val5+"\n"+
	item.Val6+"\n"+
	item.Val7+"\n"+
	item.Val8+"\n"+
	item.Val9;
	
	cr.Say((11),msg);
	
}             

void GM_GiveAll(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	Item@[]items;
	if(param1==0)
	{
		cr.GetItems((0),items);
		cr.GetItems((1),items);
		cr.GetItems((2),items);
		MoveItems(items,player);
		cr.Say((11),"Вещи переданы вам от криттера "+cr.Id);
	}
	else if(param1==1)
	{
		player.GetItems((0),items);
		player.GetItems((1),items);
		player.GetItems((2),items);
		MoveItems(items,cr);
		cr.Say((11),"Вещи переданы криттеру "+player.Id);
	}
	else if(param1==2)
	{
		cr.GetItems((0),items);
		cr.GetItems((1),items);
		cr.GetItems((2),items);
		DeleteItems(items);
		cr.Say((11),"Удалены вещи у криттера "+player.Id);
	}
}

void Clone(Critter&player,int param0,int param1,int param2)
{
	Critter@cr=GetCritter(param0);
	if(!(@cr!=null))
	return;
	if(param1==1)
	{
		for(uint i=0;i<=565;i++)
		{
			cr.ParamBase[i]=player.ParamBase[i];
		}
		player.Say((11),"Вы присвоили свои параметры персонажу "+cr.Id);
	}
	else if(param1==0)
	{
		for(uint i=0;i<=565;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		player.Say((11),"Вам присвоенны параметры персонажа "+cr.Id);
	}
}

void GM_Clone(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if((@cr!=null))
	{
		for(uint i=0;i<=80;i++)
		{
			player.StatBase[i]=cr.StatBase[i];
		}
		for(uint i=200;i<=207;i++)
		{
			player.SkillBase[i]=cr.SkillBase[i];
		}
		for(uint i=209;i<=217;i++)
		{
			player.SkillBase[i]=cr.SkillBase[i];
		}
		
		for(uint i=260;i<=278;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		for(uint i=300;i<=439;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		for(uint i=470;i<=476;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		for(uint i=480;i<=498;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		for(uint i=550;i<=565;i++)
		{
			player.ParamBase[i]=cr.ParamBase[i];
		}
		player.ParamBase[208]=cr.Param[208];
		player.Say((11),"Вам присвоенны параметры персонажа "+cr.Id+".");
	}
}

import void _TraderInit(Critter&trader,bool firstTime)from"trader";

void GM_TraderInit(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if(!(@cr!=null))
	return;
	_TraderInit(cr,true);
}     

void SetRad(Critter&player,int HexX,int HexY,int PID,string@param_string,int[]@param_array)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	{
		player.Say((11),"На глобале нельзя!");
		return;
	}
	if((((player.HexX-HexX)>0)?(player.HexX-HexX):-(player.HexX-HexX))>(16)||
	(((player.HexY-HexY)>0)?(player.HexY-HexY):-(player.HexY-HexY))>(16))
	{
		player.Say((11),"Предмет можно спаунить не дальше чем на "+(16)+" гексов от себя!");
		return;
	}
	map.SetLoopTime(0,((5)*__TimeMultiplier)*(250));
	Item@item=map.AddItem(HexX,HexY,PID,1);
	item.Val1=(50);
	map.SetData((24),0);
	map.SetData((10),PID);
	map.SetEvent((1),"_RadiationLoop0");
}

void _RadiationLoop0(Map&map)
{
	
	Critter@[]critters;
	map.GetCritters(0,(0x0F),critters);
	
	uint16 PID=map.GetData((10));
	
	Item@[]items;
	map.GetItems(PID,items);
	
	for(uint j=0;j<critters.length();j++)
	{
		if(critters[j].CountItem((52))==0)continue;
		string result="";
		for(uint i=0;i<items.length();i++)
		{
			if(!(@items[i]!=null))continue;
			if(items[i].Val1<=0)
			{
				DeleteItem(items[i]);
				@items[i]=null;
				continue;
			}
			int distance=GetDistantion(critters[j].HexX,critters[j].HexY,items[i].HexX,items[i].HexY);
			int power=(((items[i].Val1-distance)>((50)))?((50)):(((items[i].Val1-distance)<(0))?(0):(items[i].Val1-distance)));
			if(power>0)
			result+="\nИсточник №"+items[i].Id+": "+distance+" метров, "+power+" рад.";
			items[i].Val1-=(3);
		}
		critters[j].Say((11),"Дозиметр показывает:"+(result==""?" тут безопасно!":result));
	}
	
	uint16 loop_number=map.GetData((24));
	if(loop_number>=(16))
	{
		map.SetData((24),0);
		map.SetEvent((1),"");
	}
	else
	map.SetData((24),loop_number+1);
}

void setautodoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(param0);
	if(door is null)
	return;
	uint16 x=0;
	uint16 y=0;
	Map@map=door.GetMapPosition(x,y);
	uint16 x0=x;
	uint16 y0=y;
	for(uint8 i=0;i<6;i++)
	{
		map.MoveHexByDir(x,y,i,1);
		if(param1!=2)
		{
			map.AddItem(x,y,(19),1);
			Item@pedal=map.AddItem(x,y,(1544),1);
			pedal.Val1=door.Id;
			pedal.Val2=param1;
		}
		else
		{
			Item@pedal=map.GetItem(x,y,(1544));
			if((@pedal!=null))
			DeleteItem(pedal);
		}
		x=x0;
		y=y0;
	}
}

void TestJukebox(Critter&cr,int pid,int hx,int hy)
{
	Item@item=@cr.GetMap().AddItem(hx,hy,pid,1);
	if(@item!is null)
	item.SetScript("jukebox@_JukeboxInit");
}

void setjukebox(Critter&cr,int id,int,int)
{
	Item@item=GetItem(id);
	if(@item==null||item.GetType()!=(8))
	return;
	item.SetScript("jukebox@_JukeboxInit");
}

void GM_GetItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(param0);
	if(!(@item!=null))
	return;
	MoveItem(item,0,player);
}       

void chagecell(Critter&cr,int x,int y,int)
{
	cr.StatBase[(720)]=x;
	cr.StatBase[(721)]=y;
}

import void arcadehiveinsert(Critter&cr,uint16 x,uint16 y,uint8 type)from"arcade_menu";
import void arcadehivelist(Critter&cr)from"arcade_menu";
import void arcadehiveclear(Critter&cr)from"arcade_menu";
import void arcadehivedelone(Critter&cr,uint8 index)from"arcade_menu";

void arcadehiveadd(Critter&cr,int x,int y,int type)
{
	arcadehiveinsert(cr,x,y,type);
}

void arcadehivelist(Critter&cr,int,int,int)
{
	arcadehivelist(cr);
}

void arcadehiveclear(Critter&cr,int,int,int)
{
	arcadehiveclear(cr);
}

void arcadehivedel(Critter&cr,int index,int,int)
{
	arcadehivedelone(cr,index);
}

import void ShowInputBoxScreen(Critter&cr,string funcName,uint16 textLength,uint8 flags)from"main";

void testbox(Critter&cr,int p0,int,int)
{
	uint8 flags=0;
	(flags=(flags)|((0x00000001)));
	ShowInputBoxScreen(cr,"debug@unsafe_test_inputbox#mywindow",p0,flags);
}

void unsafe_test_inputbox(Critter&cr,int skill,int p1,int p2,string@message,int[]@p4)
{
	cr.Say((1),"message "+message);
}

void setworld(Critter&cr,int id,int x,int y)
{
	Critter@target=GetCritter(id>0?id:cr.Id);
	if(target is null)
	return;
	
	target.SetWorldPos(x,y);
}

void additemsrndpic(Critter&cr,int id,int x,int y)
{
	Map@map=cr.GetMap();
	if(map is null)
	{
		cr.Say((11),"map");
		return;
	}
	
	for(uint8 i=0;i<x;++i)
	{
		Item@item=map.AddItem(cr.HexX+(Random(-10,10)),cr.HexY+(Random(-10,10)),2004,1);
		if(item is null)
		continue;                    
		
		uint hash=GetStrHash("art\\scenery\\corpse1.png"); 
		
		item.SetMapPic(hash);
		
		cr.Say((11),"add "+hash);
	}
	
}

void delsatmobs(Critter&cr,int id,int x,int y)
{
	for(uint8 i=id;i<x;++i)
	{
		Location@loc=GetLocationByPid(i,0);
		if(loc is null)
		continue;
		
		Map@map=loc.GetMapByIndex(0);
		if(map is null)
		continue;
		
		Critter@[]crs;
		map.GetCritters(0,(0x0F)|(0x20),crs);
		Log("delete len "+crs.length());
		for(uint16 ii=0,jj=crs.length();ii<jj;++ii)
		{
			if(crs[ii]is null)
			continue;
			
			Log("delete "+ii);
			DeleteNpc(crs[ii]);
		}
	}
}

void itemrndpic(Critter&cr,int id,int x,int y)
{
	Item@item=GetItem(id);
	if(item is null)
	return;
	
	uint hash=GetStrHash("art\\scenery\\corpse1.png");
	item.SetMapPic(hash);
}

void addplant(Critter&cr,int id,int x,int y)
{
	Item@item=cr.AddItem(id,1);
	if(item is null)
	return;
	
	item.Val3=x;
	item.SetScript("plant@_InitPlant");
	
}

void evilplant(Critter&cr,int id,int,int)
{
	cr.GetMap().AddNpc(id,cr.HexX-3,cr.HexY-3,0,null,null,"mob@_MobInit");
	
}

void droptime(Critter&cr,int id,int,int)
{
	for(uint i=(__TimeoutBegin);i<(__TimeoutEnd);i++)
	{
		cr.TimeoutBase[i]=0;
	}
}

void addtime(Critter&cr,int id,int,int)
{
	uint time=cr.TimeoutBase[(241)];
	if(time>__FullSecond)
	{
		time+=((10)*__TimeMultiplier);
	}
	else
	{
		time=__FullSecond+((1)*__TimeMultiplier*60);
	}
	
	cr.TimeoutBase[(241)]=time;
}
import uint GetTile(Map&map,uint16 hexX,uint16 hexY,uint8 layer)from"qmap";
void gettile(Critter&cr,int id,int,int)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	uint hash=map.GetTile(((cr.HexX)>>1),((cr.HexY)>>1));
	cr.Say((11),"tile hash\n* "+hash);
	
}

void gettiles(Critter&cr,int id,int,int)
{
	uint hash0=GetStrHash("art/tiles/road02.frm"),
	hash1=GetStrHash("road02.frm");
	cr.Say((11),"tile hash\n* "+hash0+"\ntile hash\n* "+hash1);
}

void varset(Critter&cr,int id,int x,int)
{
	GameVar@isStored=GetLocalVar((10000),id);
	
	int val=isStored.GetValue();
	
	cr.Say((11),""+val);
	
	if(x>0)
	{
		uint8 temp=Random(1,100);
		
		isStored.opAssign(temp);
	}
}               

import void ActivateMobScript(Map&map)from"mob";

void testmob(Critter&cr,int id,int val,int)
{
	ActivateMobScript(cr.GetMap());
}  

void spawnsateng(Critter&cr,int id,int val,int)
{
	Location@loc;
	Item@item;
	for(uint8 i=13;i<25;++i)
	{
		@loc=GetLocation(i);
		if(loc is null)
		continue;
		
		Map@map=loc.GetMapByIndex(0);
		if(map is null)
		continue;
		
		Item@[]conts;
		map.GetItemsByType((8),conts);
		
		uint16 len=conts.length(); 
		
		for(uint16 ii=0;ii<2;++ii)
		{
			
			@item=conts[Random(0,len-1)];
			
			if(!(item is null))
			{
				item.AddItem((39),Random(1,3),0);
				Log("SPAWN "+item.HexX+":"+item.HexY);
			}
		}
	}
}

void testscreen(Critter&cr,int,int,int){
	cr.ShowScreen((2),2,"answer_test");
	cr.Say((18),"Вас устраивает ваша зарплата?");
	cr.Say((19+(0)),"Да");
	cr.Say((19+(1)),"Нет");
}

void answer_test(Critter&cr,uint answerI,string&answerS)
{
	string msg="";
	if(answerI>0){
		msg="Правда чтоли?";
	}else{
		msg="ВРешь!";
	}
	
	cr.Say((11),msg);
}

void test_npc(Critter&cr,int,int,int){
	cr.GetMap().AddNpc(5,cr.HexX-3,cr.HexY-3,0,null,null,"map_start@_InitAdventureGM");
} 

