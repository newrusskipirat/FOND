                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                               

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                                                                   

const uint16[]npc_group_raiders={(337),(338),(339),(340),(341)};
const uint16[]npc_group_mirelurk={(330)};
const uint16[]npc_group_radscorp={(319),(320)};
const uint16[]npc_group_gecko={(316),(317),(327)};
const uint16[]npc_group_rats={(310),(313),(314),(315)};                                                                                                                                                                                     

import void AffectPoison(Critter&cr,int value)from"poison";
import void AffectRadiation(Critter&cr,int value)from"radiation";  

import void ShowInputBoxScreen(Critter&cr,string funcName,uint16 textLength,uint8 flags)from"main";  

void _DeleteItemInit(Item&item,bool){DeleteItem(item);}

void _DoorAutoCloseInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"e_UseAutoCloseDoor");
}

bool e_UseAutoCloseDoor(Item&door,Critter&cr,int skill)
{
	CreateTimeEvent(__FullSecond+((door.Val3==0?2:door.Val3)*__TimeMultiplier*60),"e_AutoCloseDoor",door.Id,true);
	return false;
}

uint e_AutoCloseDoor(uint[]@val)
{
	Item@door=GetItem(val[0]);
	if(not(@door!=null))
	{
		return 0;
	}
	if(!(((door.LockerCondition)&((0x01)))!=0))
	return 0;
	uint16 x=0;
	uint16 y=0;
	Map@map=door.GetMapPosition(x,y);
	if(not(@map!=null))
	{
		return 0;
	}
	
	Critter@cr=map.GetCritter(x,y);
	if((@cr!=null))
	{
		if(cr.IsLife())
		{
			return((3)*__TimeMultiplier*60);
		}
		else
		{
			
			cr.TransitToMap(map.Id,x-1,y,cr.Dir);
		}
	}
	
	if(door.LockerClose())
	return 0;
	
	return((3)*__TimeMultiplier*60);
} 

void _ClosedDoorInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"_UseDoor");
}

bool _UseDoor(Item&door,Critter&cr,int skill)
{
	return true;
} 

void _DialogDoorInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"_UseDialogDoor");
}

bool _UseDialogDoor(Item&door,Critter&cr,int skill)
{
	RunDialog(cr,door.Val3,door.HexX,door.HexY,false);
	return true;
} 

void _HoloInit(Item&item,bool firstTime)
{
	if(item.GetProtoId()!=(58))
	return;
	item.HolodiskNumber=item.Val0;
	item.SetScript("");
	item.Update();
	
}   

void _RndAnim(Item&item,bool firstTime)
{
	int rndFrm=Random(0,item.Val1);
	
	item.AnimStayBegin=rndFrm;
	item.AnimStayEnd=rndFrm;
	item.AnimShowBegin=rndFrm;
	item.AnimShowEnd=rndFrm;
	item.AnimHideBegin=rndFrm;
	item.AnimHideEnd=rndFrm;
	
	return;
}

void _ItemBagInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ItemBagPick");
	item.SetEvent((3),"e_ItemBagUseItem");
	
}

bool e_ItemBagPick(Item&item,Critter&crit,int skill)
{      
	
	if(skill==(-1)&&item.Accessory==(2))
	{
		
		MoveItem(item,item.GetCount(),crit);
		crit.Say((11),"pick grnd");
		
	}
	return true;
}

import void SwitchState(Item&locker)from"lockers";

bool e_ItemBagUseItem(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetProtoId()==(289))
	{
		Map@map=crit.GetMap();
		if(map.IsHexPassed(item.HexX+2,item.HexY+2))
		{
			string logMsg;
			Item@hole=map.AddItem(item.HexX+2,item.HexY+2,(900),1);
			(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			logMsg="Init = "+(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			crit.Say((11),logMsg);
			
			hole.Val4=hole.HexX;
			hole.Val5=hole.HexY;
			hole.Val7=crit.WorldX;
			hole.Val8=crit.WorldY;
			Item@treasureMap=crit.AddItem((901),1);
			treasureMap.Val7=crit.WorldX;
			treasureMap.Val8=crit.WorldY;
			treasureMap.SetLexems("$hexX"+treasureMap.Val7+"$hexY"+treasureMap.Val8);
			
			return true;
		}
	}
	else if(item.Accessory==(2))
	{
		
		crit.ShowScreen((0),0,"");
		crit.ShowContainer(null,item,item.Proto.GroundLevel?(2):(1));
		return true;
	}
	return false;
}                                      

void _ShovelInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ShovelUse");
}

bool e_ShovelUse(Item&item,Critter&cr,int skill)
{
	if(skill==(211)&&item.Accessory==(1))
	{
		Map@map=cr.GetMap();
		if(map.IsHexPassed(cr.HexX+2,cr.HexY+2))
		{
			string logMsg;
			Item@hole=map.AddItem(cr.HexX+2,cr.HexY+2,(900),1);
			(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			hole.Val4=hole.HexX;
			hole.Val5=hole.HexY;
			hole.Val7=cr.WorldX;
			hole.Val8=cr.WorldY;
			Item@treasureMap=cr.AddItem((901),1);
			treasureMap.SetLexems("$hexX"+treasureMap.Val7+"$hexY"+treasureMap.Val8);
			return true;
		}
	}
	return false;
}     

void _KeyBunchInit(Item&item,bool firstTime)

{
	
	item.SetEvent((3),"e_KeyBunchAdd");
	
	item.SetEvent((2),"e_KeyBunchUse");
	
	item.SetEvent((4),"e_KeyBunchSkill");
	
}  

bool e_KeyBunchTest(Item&item,Critter&cr,int skill)

{
	
	if(skill==(-2))
	
	{
		
		cr.Say((11),"dude great!");
		
		return true;
		
	}
	
	return false;
	
}            

bool e_KeyBunchSkill(Item&item,Critter&cr,int skill)

{
	
	string msg;
	
	switch(skill)
	
	{
		
		case(213):
		{
			Item@temp=cr.AddItem(82,1);
			msg=Random(0,51);
			temp.SetLexems("$KeyLex"+Random(0,51));
		}
		
		case(-1):
		if(item.Accessory==(2))
		{
			MoveItem(item,item.GetCount(),cr);
			return true;
		}
		
		if(item.ContainerId==cr.Id)
		{
			cr.Say((11),"that's work");
			key=item.Id;
			cr.ShowScreen((0),0,"@");return true;
		}  
		
		case(211):
		
		{ 
			
			Item@[]keys;
			item.GetItems(0,keys);
			if(keys.length()>0)
			{
				cr.Action((10),0,null);
				for(uint8 i=0;i<keys.length();i++)
				{
					MoveItem(keys[i],keys[i].GetCount(),cr);
				}
				cr.Say((11),"SUCK MY BALLS BITCH!!! "+item.Accessory);
				return true;
			}
		}
		case(212):
		{
			Item@[]keys;
			item.GetItems(0,keys);
			int[]keysId;
			if(keys.length()>0)
			{
				for(uint8 i=0;i<keys.length();i++)
				{
					keysId[i]=keys[i].Id; 
					
				}
				cr.RunClientScript("_ItemLexRtn",0,0,0,null,keysId);
			}
			return true;
		}
	}
	return false;
}                                                

bool e_KeyBunchAdd(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem.GetType()==(7))
	{
		MoveItem(usedItem,usedItem.GetCount(),item,0);
		cr.Say((11),"You're added some key to brunch");
		return true;
	}
	return false;
}

uint key;

bool e_KeyBunchUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null)&&onItem.GetType()==(9))
	{
		Item@[]keys;
		item.GetItems(0,keys);
		if(onItem.LockerCondition==(0x02))
		{
			for(uint8 i=0;i<keys.length();i++)
			{
				if(keys[i].LockerId==onItem.LockerId)
				{
					onItem.LockerId=0;
					onItem.LockerComplexity=0;
					cr.Say((11),"You're ulock the door");
				}
			}
		}
	}
	return false;
}  

void KeyUseScreen(Critter&player,uint answerI,string&answerS)
{   
	
	if(answerS.length()!=0)
	{     
		
		Item@key=GetItem(player.StatBase[(90)]);
		key.SetLexems("$KeyLex"+answerS);
		key.Update();
		
	}       
	
}                                

void _LockerInit(Item&item,bool firstTime)
{  
	
	item.SetEvent((2),"e_LockerKeyUse");
	
}      

bool ItemLockedCont(Item&item)
{
	if(item.GetType()==(8))
	{
		uint16 proto=item.GetProtoId();
		if(41<proto&&proto<46)
		{
			return true;
		}
		if(127<proto&&proto<140)
		{
			return true;
		}
		if(180<proto&&proto<190)
		{
			return true;
		}
		if(366<proto&&proto<371)
		{
			return true;
		}
		switch(proto)
		{
			case 245:
			return true;
			case 501:
			return true;
			case 502:
			return true;
			case 521:
			return true;
		}
	}
	return false;
} 

bool e_LockerKeyUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null))
	{
		if((onItem.GetType()==(9)||ItemLockedCont(onItem))&&onItem.Val1==0&&onItem.Val0==0)
		{
			if((not((onItem.LockerCondition&(0x01))!=0)))
			{
				if(onItem.LockerCondition!=(0x02)&&onItem.LockerComplexity==0)
				{   
					
					switch(item.GetProtoId())
					{
						case(1317):
						onItem.Val0=1;
						break;
						case(1318):
						onItem.Val0=2;
						break;
						case(1319):
						onItem.Val0=3;
						break;
					}
					
					Item@key=cr.AddItem((1313),1);
					uint keyNumber=Random(0,65534);
					onItem.LockerCondition=(0x02);
					onItem.LockerComplexity=item.Val0;
					Log("Locked, LockerCompl = "+onItem.LockerComplexity);
					onItem.LockerId=keyNumber;
					key.LockerId=keyNumber;
					item.SetLexems("$KeyLex"+"unnamed key");
					cr.StatBase[(90)]=key.Id;
					cr.ShowScreen((5),0,"item@KeyUseScreen");
					key.Update();
					DeleteItem(item);
					return true;
				}
				else
				{
					cr.Say((11),"Дверь уже заперта, сначала взломайте замок.");
					return true;
				}
			}
			else
			{
				cr.Say((11),"Сначала закройте объект");
				return true;
			}
		}
		else
		{
			cr.Say((11),"Этот объект нельзя запереть");
			return true;
		}
		
	}  
	
	return false;
}

void _LightEnvInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_LightEnvSkill");
}

bool e_LightEnvSkill(Item&item,Critter&cr,int skill)
{ 
	
	cr.Say((11),"Don't steal the light!");
	return true; 
	
}   

void _EmptyDisk(Item&item,bool firstTime)
{
	if(firstTime)
	item.HolodiskNumber=0;
}

bool e_FillRegistrationDocs(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.Val1==0)
	{
		cr.Say((11),"Вы вписали своё имя в документ, теперь он действительный");
		string@name=GetPlayerName(cr.Id);
		item.SetLexems("$ModocRegistrationName"+name);
		item.Val1=cr.Id;
		return true;
	}
	else
	{
		string@name=GetPlayerName(item.Val1);
		cr.Say((11),"Документ заполнен на имя: "+name);
		return true;
	}
}      

import uint GetPlayers(Critter&cr,uint16 radius,bool square,Critter@[]&crs)from"manager";

string dataName; 

bool ShowFlare(Critter@[]crs)
{
	uint8 length=crs.length();
	Map@map=crs[length-1].GetMap();
	if(!(@map!=null))
	return false;
	Location@loc=map.GetLocation();
	if(!(@loc!=null)||loc.AutoGarbage==false)
	{
		crs[crs.length()-1].Say((11),"Запускать ракету здесь - бессмыслеца. Найдите более подходящее место.");
		return false;
	}           
	
	uint flareLocId=loc.Id;
	CreateTimeEvent(__FullSecond+(1000),"e_ShowFlare",flareLocId,false);
	return true;
}

uint e_ShowFlare(uint[]@values)
{
	Location@loc=GetLocation(values[0]);
	if(!(@loc!=null))
	return 0;             
	
	return 0;
}        

void _FlareGun(Item&item,bool firstTime)
{ 
	
	item.SetEvent((4),"e_FlareGunSkill");
	
}

bool e_FlareGunSkill(Item&item,Critter&cr,int skill)
{
	if(skill!=(211))
	return false;
	return FlareGunUse(cr,item);
}

bool FlareGunUse(Critter&cr,Item&item)
{
	if(item.AmmoCount>0)
	{
		Critter@[]crs;
		GetGlobalMapCritters(cr.WorldX,cr.WorldY,200,(0x01)|(0x10),crs);
		crs.insertLast(cr);
		if(!ShowFlare(crs))
		return false;
		item.AmmoCount-=1;
		item.Update();
		cr.Say((11),"Вы запустили сигнальную ракету.");
	}
	return true;
}           

uint expBook;

void _ExpBookInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ExpBookSkill");
	if(firstTime)
	{
		
		item.SetEvent((2),"e_ExpBookUse");
	}
}

bool e_ExpBookSkill(Item&item,Critter&cr,int skill)
{
	switch(skill)
	{
		case(211):
		expBook=item.Id;
		cr.ShowScreen((5),1,"ExpBookScreen");
		break;
		case(213):
		item.Val1=(item.Val1==0?1:0);
		break;
		case(212):
		cr.Say((11),"item state = "+item.Val1);
		break;
	}
	return true;
}

void ExpBookScreen(Critter&cr,uint answerI,string&answerS)
{
	Item@expBook0=GetItem(expBook);
	expBook0.SetEvent((4),"");
	if(answerS.length()>0)
	StrToInt(answerS,expBook0.Val0);
	cr.Say((11),""+expBook0.Val0+" "+answerI+" "+answerS);
}

bool e_ExpBookUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((11),""+item.Val0);
	if(item.Val0!=0)
	{
		if(item.Val1==0)
		{
			cr.StatBase[(76)]+=item.Val0;
		}
		else
		{
			cr.StatBase[(78)]+=item.Val0;
			cr.Say((11),"U recive "+item.Val0+" skill points");
		}
		DeleteItem(item);
		return true;
	}
	return false;
} 

void _InitMasterKey(Item&key,bool firstTime)
{ 
	
	key.SetEvent((2),"e_MasterKeyUse");
	
}

bool e_MasterKeyUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null)&&(onItem.GetType()==(9)||onItem.GetType()==(8)))
	{
		onItem.LockerOpen();
		onItem.LockerComplexity=0;
		
		onItem.LockerId=0;
		
		SwitchState(item);
		item.Update();
	}
	return false;
}

import bool SlotMachineWork(Critter&cr,Item&onehanded,int skill,Item@item)from"casino";

void _InitSlotMachine(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_SlotMachineUse");
	item.SetEvent((3),"e_SlotMachineOnMe");
}

bool e_SlotMachineUse(Item&item,Critter&cr,int skill)
{
	Item@key1=cr.GetItem((833),(1));
	switch(skill)
	{
		case(213):
		if(item.LockerComplexity!=0)
		{
			cr.Say((11),"not repair needed");
			return true;
		}
		else if(@key1!=null)
		{
			item.LockerId=key1.LockerId;
			item.LockerComplexity=100;
			item.Update();
			cr.Say((11),"U are repair slot machine");
		}
		else
		{
			Item@key=cr.AddItem((833),1);
			uint16 rnd=Random(1,65534);
			key.LockerId=rnd;
			item.LockerId=rnd;
			item.LockerComplexity=100;
			item.Update();
			key.Update();
			cr.Say((11),"U are repair slot machine");
			return true;
		}
		case(209):
		if(cr.StatBase[(5)]*2>Random(15,25-(cr.StatBase[(6)]/2)))
		{
			return false;
		}
		else
		{
			cr.Say((6),"do something with machine");
			return true;
		}
		case(-1):
		if(item.LockerComplexity==0||(@key1!=null&&key1.LockerId==item.LockerId))
		cr.ShowContainer(null,item,item.Proto.GroundLevel?(2):(1));
		else if(cr.CountItem((41))>=5)
		{
			SlotMachineWork(cr,item,skill,null);
			return true;
		}
		else
		{
			cr.Say((11),"need money");
			return true;
		}
		
	}
	
	return false;
}

bool e_SlotMachineOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(@usedItem==null)
	return false;
	SlotMachineWork(cr,item,(-1),usedItem);
	return true;
}     

funcdef uint PROCESS(Critter@,int&,int&,int&);                

import bool RegisterProcess(uint8 type,any func)from"ltp";

import bool StartProcess(Critter&cr,uint8 type,int param0,int param1,int param2,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,int param0,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,uint time)from"ltp";

import bool StopProcess(Critter&cr)from"ltp";

import bool checkTDH(Critter&cr)from"ltp";
import bool checkTDH(Critter&cr,uint8 type)from"ltp";                       

bool ltp_roul_inited=false;
void ltp_roul_init()
{
	PROCESS@___pfunc=@process_russ_roul;any ___pany;___pany.store(@___pfunc);RegisterProcess((30),___pany);
	ltp_roul_inited=true;
}

uint process_russ_roul(Critter@cr,int&param0,int&param1,int&param2)
{
	if(param0==-1&&(cr is null)){param0=int((30));return(0xF035BCF3);}
	
	if(param0==0)
	{
		Item@item=GetItem(uint(param1));
		if((@item!=null))
		{
			item.AmmoCount--;
			item.Update();
		}   
		
		cr.SayMsg((6),(0),(9000));
		cr.ToDead((110),null);
	}
	else
	{
		cr.SayMsg((6),(0),(9001));
	}
	
	return 0;
}

void _RevolverInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_RevolverSkill");
}

void StartRussRull(Critter&cr,uint16 item_id){
	if(!ltp_roul_inited)
	ltp_roul_init();
	uint8 russianRoll=Random(10,70)-(cr.StatBase[(6)]/2);
	uint rndTime=Random(3,5)*1000;
	bool roll=(russianRoll>=10)&&(russianRoll<=20);
	
	StartProcess(cr,(30),roll?0:1,item_id,0,rndTime);
	cr.Say((6),"Взводит курок");
}

bool e_RevolverSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(211))
	{
		if(item.AmmoCount<=0)
		return false;
		StartRussRull(cr,item.Id);
		return true;
	}
	return false;
}  

void _InitPoliceStuff(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PoliceStuffUse");
	item.SetEvent((4),"e_PoliceStuffPick");
	item.SetEvent((3),"e_PoliceStuffHammer");
} 

bool e_PoliceStuffPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		Map@map=cr.GetMap();
		Location@loc=map.GetLocation();
		if(item.Val1==0)
		{
			return false;
		}
		cr.Say((11),"Вы не можете перенести табличку, она закреплена.");
		return true;
	}
	return true;
}

bool e_PoliceStuffHammer(Item&item,Critter&cr,Item@usedItem)
{
	int HammerTime=(11-cr.Stat[(0)])*60;
	if(item.GetProtoId()==(1458))
	{
		if((cr.Timeout[(232)]==0)&&(cr.StatBase[(77)]>=6))
		{
			if((@usedItem!=null)&&(usedItem.GetProtoId()==(6)))
			{
				if(cr.CountItem((1423))>=1)
				{
					item.Val1+=1;
					cr.DeleteItem((1423),1);
					cr.Say((11),"вы забиваете кувалдой крепежные штыри");
					cr.TimeoutBase[(232)]=__FullSecond+HammerTime;
				}
				else
				cr.Say((11),"нет крепежных штырей");
				return true;
			}
			if((@usedItem!=null)&&(usedItem.GetProtoId()==(20)))
			{
				if(item.Val1>=1)
				{
					item.Val1-=1;
					cr.Say((11),"вы выдергиваете ломиком крепежные штыри");
					cr.TimeoutBase[(232)]=__FullSecond+HammerTime;
				}
				else
				cr.Say((11),"табличка не закреплена");
				return true;
			}
		}
		cr.Say((11),"у вас недостаточно сил");
	}
	return false;
}

bool e_PoliceStuffUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1458))
	{
		if(item.Val2!=0)
		{
			cr.Say((11),"Вы убрали текст с таблички.");
			item.SetLexems(null);
			item.Update();
			return true;
		}
		if(item.Val0==0)
		{
			cr.StatBase[(131)]=item.Id;
			cr.StatBase[(130)]=item.Accessory;
			ShowInputBoxScreen(cr,"main@unsafe_MakeDescLex#Текст таблички:",0,(0x00000001));
		}
		else
		cr.Say((11),"Табличка уже заполнена.");
	}
	return true;
}

void SignUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		item.SetLexems(""+answerS);
		item.Val0=1;
		item.Update();
	}
} 

import bool SetTrapOnItem(Critter&cr,Item&trap,Item&onItem)from"trap";
import bool UseSkillOnTrappedItem(Item&trappedItem,Critter&cr,int skill)from"trap";

void _TestTrapInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_TestTrapUse");
}

bool e_TestTrapUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	
	if(@cr==null||@item==null||@onItem==null)
	return false;
	
	if(SetTrapOnItem(cr,item,onItem))
	{
		onItem.SetEvent((4),"trap@UseSkillOnTrappedItem");
		return true;
	}
	return false;
	
}

void _WhistInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_WhistUse");
}

bool e_WhistUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	map.PlaySound("whist.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	cr.Say((6),"Свестит в свисток.");
	return true;
}

void _InitRpNamer(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_RpNamerUse");
}

bool e_RpNamerUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1460))
	{
		ShowInputBoxScreen(cr,"item@unsafe_RpNamerUseScreen#Ваше описание:",0,(0x00000001));
		cr.StatBase[(90)]=item.Id;
	}
	return true;
}

void unsafe_RpNamerUseScreen(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	RpNamerUseScreen(player,0,param3);
} 

void RpNamerUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		player.SetLexems(answerS);
		if((@item!=null))do{if(item.GetCount()>(1))
			item.SetCount(item.GetCount()-(1));else
			DeleteItem(item);}while(false);
	}
}

void _music_fleita(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_fleitaUse");
}

bool e_fleitaUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	if(Random(1,5)>4)
	map.PlaySound("flute.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>3)
	map.PlaySound("flute2.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>2)
	map.PlaySound("flute3.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>1)
	map.PlaySound("flute4.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>0)
	map.PlaySound("flute5.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	cr.Say((6),"Играет на флейте.");
	Location@loc=map.GetLocation();
	if((loc.WorldX<=50)||(loc.WorldX>=150)||(loc.WorldY<=50)||(loc.WorldY>=150))
	{
		cr.Say((11),"Вы слишком далеко от фермы.");
		return true;
	}
	if((loc.WorldX>=item.Val2-20)&&(loc.WorldX<=item.Val2+20)&&(loc.WorldY>=item.Val3-20)&&(loc.WorldY<=item.Val3+20))
	{
		cr.Say((11),"Тут брамины уже паслись.");
		return true;
	}
	if(loc.Id>=100&&loc.Id<=139)
	{
		cr.Say((11),"Начинаете пасти стадо.");
		item.Val1=map.Id;
		item.Val2=loc.WorldX;
		item.Val3=loc.WorldY;
		cr.AddTimeEvent("cte_BrahminEat",(60*3)*__TimeMultiplier,(43),0);
	}
	return true;
}

uint cte_BrahminEat(Critter&cr,int identifier,uint&rate)
{
	Critter@[]brahmins;
	Item@flute=cr.GetItem((1494),(1));
	Map@map=cr.GetMap();
	if(!(@flute!=null)||!(@map!=null))
	return 0;
	if((map.GetCritters((321),(0x03)|(0x20),brahmins)>0)&&map.Id==uint(flute.Val1))
	{
		for(uint i=0,ii=brahmins.length();i<ii;i++)
		{
			brahmins[i].StatBase[(95)]+=1;
		}
		cr.Say((11),"Брамины кажется насытились тут");
	}
	return 0;
}

void _dosimetr(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_dosimetrUse");
}

bool e_dosimetrUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	cr.Say((6),"Производит замер.");
	Location@loc=map.GetLocation();
	if((loc.WorldX>=item.Val1-20)&&(loc.WorldX<=item.Val1+20)&&(loc.WorldY>=item.Val2-20)&&(loc.WorldY<=item.Val2+20))
	{
		cr.Say((11),"Кажется место правильное, остается только подождать несколько минут.");
		item.Val3=map.Id;
		cr.AddTimeEvent("cte_dosimetrUse",60*3,(43),0);
	}
	return true;
}

uint cte_dosimetrUse(Critter&cr,int identifier,uint&rate)
{
	Item@dosimetr=cr.GetItem((1540),(1));
	Map@map=cr.GetMap();
	if(!(@dosimetr!=null)||!(@map!=null))
	return 0;
	if(map.Id==uint(dosimetr.Val3))
	{
		cr.Say((11),"Индикатор изменил цвет на желтый, можно возвращаться.");
		DeleteItem(dosimetr);
		cr.AddItem((1541),1);
	}
	else
	cr.Say((11),"Время прошло, но индикатор не сменил цвет, кажется мы сделали что-то неправильно.");
	return 0;
}

void _TraderBadge(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_traderbadgeUse");
}

bool e_traderbadgeUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"Показывает значек торговца");
	return true;
}

void _PochtaBadge(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PochtaBadgeUse");
}

bool e_PochtaBadgeUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"Показывает значек почтальона");
	return true;
}

void _kosakInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_kosakUse");
}

bool e_kosakUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	if(Random(0,1)>0)
	map.PlaySound("drugs1.wav",cr.HexX,cr.HexY,1);
	else
	map.PlaySound("drugs2.wav",cr.HexX,cr.HexY,1);
	cr.Say((6),"Раскуривает косяк");
	cr.StatBase[(76)]+=Random(500,1000);
	cr.StatBase[(74)]+=Random(0,2);
	AffectPoison(cr,Random(10,20));
	cr.StatBase[(128)]-=Random(4,8);
	cr.StatBase[(127)]-=Random(4,8);
	cr.DeleteItem((1490),1);
	return true;
}

import void Warn(Critter&admin,int param0,int param1,int param2)from"warning";
import void say(Critter&player,int param0,int param1,int param2)from"gm";

void _InitGmPistol(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_GmPistolUse");
	item.SetEvent((4),"e_GmPistolPick");
	item.SetEvent((1),"e_GmPistolAttack");
}

bool e_GmPistolUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1523)&&cr.GetAccess()>=(2))
	{
		cr.ShowScreen((2),3,"answer_GmPistol_GM_menu");
		cr.Say((18),"Что желаешь хозяин?");
		cr.Say((19+(0)),"скачать help");
		cr.Say((19+(1)),"скачать warn");
		cr.Say((19+(2)),"очистить help");
		cr.Say((19+(3)),"очистить warn");
	}
	return true;
}

void answer_GmPistol_GM_menu(Critter&cr,uint answerI,string&answerS)
{
	if(!(@cr!=null))
	return;
	if(answerI==0)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","r")>=0)
		{
			string word="";
			uint pos=0;
			f.setPos(0);
			while(!f.isEndOfFile())
			{
				pos=f.getPos();
				if(pos==0)
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",0,0,0,word,null);
				}
				else
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",1,0,0,word,null);
				}
			}
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==1)
	{
		file f;
		if(f.open("logs\\warnings.txt","r")>=0)
		{
			string word="";
			uint pos=0;
			f.setPos(0);
			while(!f.isEndOfFile())
			{
				pos=f.getPos();
				if(pos==0)
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",0,1,0,word,null);
				}
				else
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",1,1,0,word,null);
				}
			}
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==2)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","w")>=0)
		{
			
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==3)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","w")>=0)
		{
			
			f.close();
		}
		else
		Log("can't open!");
	}
}

bool e_GmPistolPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		DeleteItem(item);
	}
	return false;
}

bool e_GmPistolAttack(Item&item,Critter&cr,Critter&target)
{
	if(cr.IsPlayer())
	{
		if(cr.GetAccess()>=(2))
		{
			cr.StatBase[(90)]=target.Id;
			cr.ShowScreen((2),5,"answer_GmPistolAttack_GM");
			cr.Say((18),"Что желаешь хозяин?");
			cr.Say((19+(0)),"предупреждение");
			cr.Say((19+(1)),"+ опыт");
			cr.Say((19+(2)),"+ скиллпоинты");
			cr.Say((19+(3)),"+ деньги");
			cr.Say((19+(4)),"+ нокаут");
			return true;
		}
		else
		{
			cr.StatBase[(90)]=target.Id;
			cr.ShowScreen((2),7,"answer_GmPistolAttack_player");
			cr.Say((18),"Выберите предупреждение");
			cr.Say((19+(0)),"сленг");
			cr.Say((19+(1)),"повергейминг");
			cr.Say((19+(2)),"выход из роли");
			cr.Say((19+(3)),"мародерство");
			cr.Say((19+(4)),"клептомания");
			cr.Say((19+(5)),"метагейм");
			cr.Say((19+(6)),"мультоводство");
			return true;
		}
	}
	return true;
}

import uint GetAllPlayers(Critter@[]&crs)from"manager";

void answer_GmPistolAttack_player(Critter&cr,uint answerI,string&answerS)
{
	Critter@target=GetCritter(cr.Stat[(90)]);
	if(target is null or target.IsNpc())
	{
		cr.Say((11),"Игрок не найден.");
		return;
	}
	if(cr.Stat[(95)]>3)
	return;
	cr.StatBase[(95)]+=1;
	string plead;
	if(answerI==0)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НА СЕРВЕРЕ ЗАПЕРЩЕН СЛЕНГ И НЕИГРОВОЕ ОБЩЕНИЕ");
		plead=" - сленг";
	}
	else if(answerI==1)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НЕ СТРОЙТЕ ИЗ СЕБЯ РЕМБО, ПОМНИТЕ ОБ ИНСТИНКТЕ САМОСОХРАНЕНИЯ");
		plead=" - рембо";
	}
	else if(answerI==2)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ПРИДЕРЖИВАЙТЕСЬ СВОЕЙ ИГРОВОЙ РОЛИ");
		plead=" - несоответствие роли";
	}
	else if(answerI==3)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"БЕЗСИСТЕМНОЕ ЛУТАНИЕ ТРУПОВ ЭТО МАРОДЕРСТВО, ОСТАНОВИТЕСЬ");
		plead=" - мародерство";
	}
	else if(answerI==4)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НЕ ШАРЬТЕСЬ ГДЕ ПОПАЛО, ПРИСТРЕЛЯТ ЗА ВОРОВСТВО");
		plead=" - клептомания";
	}
	else if(answerI==5)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ИСПОЛЬЗОВАНИЕ ИНФОРМАЦИИ ПОЛУЧЕННОЙ НЕИГРОВЫМ ПУТЕМ ЗАПРЕЩЕНО");
		plead=" - метагейм";
	}
	else if(answerI==6)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ЗАПРЕЩЕНО ВЗАИМОДЕЙСТВИЕ МЕЖДУ СВОИМИ ПЕРСОНАЖАМИ");
		plead=" - мультоводство";
	}
	if(plead!="")
	{
		cr.Say((11),"предупреждение выдано");
		Critter@[]crs;
		GetAllPlayers(crs);
		string str="жалоба от |0xFFFF0000 <|0xFFFFFF00 "+GetPlayerName(cr.Id)+"("+cr.Id+") на "+GetPlayerName(target.Id)+"("+target.Id+")|0xFFFF0000 > |0xFFBB33CC "+plead;
		for(uint i=0,j=crs.length();i<j;i++)
		{
			if(crs[i]is null or crs[i].GetAccess()<(2))
			continue;
			crs[i].Say((11),str);
		}
		file f;
		if(f.open("logs\\warnings.txt","a")>=0)
		{
			f.writeString("жалоба от "+GetPlayerName(cr.Id)+"\t "+cr.Id+"\t на "+GetPlayerName(target.Id)+"\t"+target.Id+"\t"+plead+"\n");
			f.close();
		}
	}
}

void answer_NULL(Critter&cr,uint answerI,string&answerS)
{
	return;
}

void answer_GmPistolAttack_GM(Critter&cr,uint answerI,string&answerS)
{
	Critter@target=GetCritter(cr.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerI==0)
	{
		Warn(cr,target.Id,0,0);
	}
	else if(answerI==1)
	{
		cr.ShowScreen((5),0,"item@GmPistol_exp");
	}
	else if(answerI==2)
	{
		cr.ShowScreen((5),0,"item@GmPistol_skill");
	}
	else if(answerI==3)
	{
		cr.ShowScreen((5),0,"item@GmPistol_money");
	}
	else if(answerI==4)
	{
		cr.ShowScreen((5),0,"item@GmPistol_knockdown");
	}
}

void GmPistol_exp(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.StatBase[(76)]+=number;
		player.Say((11),"вы выдали "+number+" опыта игроку "+target.Id);
	}
}

void GmPistol_skill(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.StatBase[(78)]+=number;
		player.Say((11),"вы выдали "+number+" скиллпоинтов игроку "+target.Id);
	}
}

void GmPistol_money(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.AddItem((41),number);
		player.Say((11),"вы выдали "+number+" монет, персонажу "+target.Id);
	}
}

void GmPistol_knockdown(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.ToKnockout(((Random(0,1)==0?true:false)?(82):(83)),((Random(0,1)==0?true:false)?(86):(87)),((Random(0,1)==0?true:false)?(88):(89)),number,target.HexX,target.HexY);
		player.Say((11),"вы уронили игрока "+target.Id+" на "+number);
	}
}

void _InitRPStuff(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_RPStuffUse");
}

bool e_RPStuffUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery){
	if(item.Val0==0){
		item.Val0=1;
		if(cr.Stat[(4)]<=3){
			cr.Say((11),"Вы без понятия, что делать с этим предметом.");
			return true;
		}
		if(cr.Stat[(4)]<=5){
			cr.StatBase[(90)]=item.Id;
			cr.ShowScreen((5),0,"item@RPStuffUseScreen");
			return true;
		}
		cr.StatBase[(131)]=item.Id;
		cr.StatBase[(130)]=item.Accessory;
		ShowInputBoxScreen(cr,"main@unsafe_MakeDescLex#Описание:",0,(0x00000001));
	}else{
		cr.Say((11),"Прийдётся пораскинуть мозгами, что бы найти способ изменить этот предмет.");
	}
	return true;
}

void RPStuffUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		uint16 itemPid=item.GetProtoId();
		
		switch(itemPid)
		{
			case(1527):
			item.SetLexems(""+answerS);
			break;
			case(1528):
			item.SetLexems(""+answerS);
			break;
			case(1529):
			item.SetLexems(""+answerS);
			break;
			case(1530):
			item.SetLexems(""+answerS);
			break;
			case(1531):
			item.SetLexems(""+answerS);
			break;
			case(1532):
			item.SetLexems(""+answerS);
			break;
			case(1533):
			item.SetLexems(""+answerS);
			break;
		}
		
		item.Val0=1;
		item.Update();
	}
}

void _InitPuti(Item&item,bool firstTime)
{
	item.SetEvent((5),"e_PutiDrop");
}

void e_PutiDrop(Item&item,Critter&cr)
{
	if(cr.CountItem((694))!=0||cr.CountItem((692))!=0)
	{
		cr.AddItem((1534),1);
		cr.Say((11),"Вы не можете снять путы");
	}
	DeleteItem(item);
} 

void _InitCodeDoor(Item&item,bool firstTime)
{
	Log("Depracated function item@_InitCodeDoor at item.Id "+item.Id); 
	
}              

void _InitAidKit(Item&item,bool firstTime)
{
	item.SetLexems("Медикаментов там "+SetupAidLeX(item.Indicator)+".");
}

string SetupAidLeX(uint8 aidValue)
{
	string resultTemp="";
	
	if(aidValue==100)
	resultTemp="полная сумка";
	else if(aidValue>80)
	resultTemp="достаточно";
	else if(aidValue>60)
	resultTemp="чуть больше половины";
	else if(aidValue>40)
	resultTemp="немного меньше половины";
	else if(aidValue>20)
	resultTemp="совсем не много";
	else if(aidValue>10)
	resultTemp="на дне";
	else if(aidValue>0)
	resultTemp="практически нет";
	else if(aidValue==0)
	resultTemp="нет";
	
	return resultTemp;
}

void _AutoDoorInit(Item&item,bool firstTime)
{
	if(item.GetProtoId()==(1544))
	item.SetEvent((7),"e_AutoDoorWalk");
}

void e_AutoDoorWalk(Item&item,Critter&cr,bool entered,uint8 dir)
{
	Item@door=GetItem(item.Val1);
	if(!(@door!=null))
	{
		DeleteItem(item);
		return;
	}
	
	Map@map=cr.GetMap();
	if(entered)
	{
		if(!(((door.LockerCondition)&((0x01)))!=0)&&
		!(((door.LockerCondition)&((0x02)))!=0)&&
		!(door.LockerCondition==(0x20)))
		{
			if(map.GetData(24)>0)
			door.LockerOpen();
			else
			if(cr.GetAccess()>(0))
			map.SetText(item.HexX,item.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),":щёлк:");
		}
	}
	else
	{
		if(map.GetData(24)>0)
		{
			uint16 x=0;
			uint16 y=0;
			@map=door.GetMapPosition(x,y);
			if(map.GetCrittersHex(x,y,1,(0x01),null)==0)door.LockerClose();
		}
		else
		if(cr.GetAccess()>(0))
		map.SetText(item.HexX,item.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),":клац:");
	}
}

void _PillsInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PillsUse");
}

bool e_PillsUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"принимает таблетки");
	if(item.GetProtoId()==(333))
	{
		cr.AddTimeEvent("cte_ClearOverDose",((1)*__TimeMultiplier*60),(15),0);
		do{if(item.GetCount()>(1))
			item.SetCount(item.GetCount()-(1));else
			DeleteItem(item);}while(false);
		return true;
	}
	else if(item.GetProtoId()==(1548))
	{
		cr.AddTimeEvent("cte_ClearingBlood",((1)*__TimeMultiplier*60),(15),59);
		do{if(item.GetCount()>(1))
			item.SetCount(item.GetCount()-(1));else
			DeleteItem(item);}while(false);
		return true;
	}
	return true;
}

uint cte_ClearOverDose(Critter&cr,int identifier,uint&rate)
{
	string[]text={"ша голова проясняется","ше сердце перестаёт колоть","м стало намного легче","с уже не так сильно колотит от передоза лекарствами"};
	cr.Say((11),"Ва"+text[Random(0,text.length()-1)]+".");
	
	AffectPoison(cr,cr.StatBase[(148)]*Random(2,6));
	
	cr.StatBase[(148)]/=3;
	return 0;
}

uint cte_ClearingBlood(Critter&cr,int identifier,uint&rate)
{
	if(cr.StatBase[(147)]>0){
		
		string[]text={"а температура снижается","е дыхание облегчилось","и внутренности меньше болят","а голова слегка проясняется","е тело стало не так сильно потеть"};
		cr.Say((11),"Ваш"+text[Random(0,text.length()-1)]+".");
		
		AffectPoison(cr,Random(4,8));
		
		cr.StatBase[(147)]-=Random(0,1);  
		
	}else{
		if((((cr.StatBase[(146)])&((0x008)))!=0)){
			cr.Say((11),"Заражение крови вылечено.");
			(cr.StatBase[(146)]=((cr.StatBase[(146)])&(~((0x008)))));
		}
	}
	
	rate--;
	return rate>0?((1)*__TimeMultiplier*60):0;
}

void _MercsSignInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_MercsSign");
}

bool e_MercsSign(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"показывает плакат");
	return true;
}

void _MercsSign2Init(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_MercsSign2");
}

bool e_MercsSign2(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"показывает нашивку Черной Стаи");
	return true;
}

void _InitEmptyHypo(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_EmptyHypoUse");
}

bool e_EmptyHypoUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	bool onSelf=(!(@onCritter!=null)&&!(@onItem!=null)&&!(@onScenery!=null));
	if(onSelf)
	{
		Item@hypo=cr.AddItem((1550),1);
		hypo.Val1=cr.Id;
		hypo.Val2=cr.Stat[(64)];
		hypo.Val3=cr.Stat[(187)];
		hypo.Val4=cr.Stat[(67)];
		hypo.Val5=cr.Stat[(73)];
		hypo.Val6=cr.Stat[(74)];
		cr.StatBase[(90)]=hypo.Id;
		cr.ShowScreen((5),0,"item@HypoUseScreen");
		hypo.Update();
		cr.DeleteItem((318),1);
		cr.Say((11),"Вы взяли у себя образец крови.");
		cr.Say((6),"Берет образец крови");
		return true;
	}
	else if(cr.IsPlayer()&&(@cr!=null)&&(@onCritter!=null))
	{
		if(cr.Timeout[(238)]>0||onCritter.Timeout[(238)]>0)
		{
			cr.Say((11),"Это неуместно");
			return true;
		}
		Item@hypo=cr.AddItem((1550),1);
		hypo.Val1=onCritter.Id;
		hypo.Val2=onCritter.Stat[(64)];
		hypo.Val3=onCritter.Stat[(187)];
		hypo.Val4=onCritter.Stat[(67)];
		hypo.Val5=onCritter.Stat[(73)];
		hypo.Val6=onCritter.Stat[(74)];
		cr.StatBase[(90)]=hypo.Id;
		cr.ShowScreen((5),0,"item@HypoUseScreen");
		hypo.Update();
		cr.DeleteItem((318),1);
		cr.Say((11),"Вы взяли образец крови.");
		cr.Say((6),"Берет образец крови");
		return true;
	}
	else
	cr.Say((11),"Это неуместно");
	return true;
}

void HypoUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@Hypo=GetItem(player.StatBase[(90)]);
		Hypo.SetLexems("$HypoLex"+answerS);
		Hypo.Update();
	}
}

void _InitBloodHypo(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_BloodHypoUse");
	item.SetEvent((4),"e_BloodHypoSkill");
}

import void ApplyDesease(Critter&player,int param0,int param1)from"morphes";

bool e_BloodHypoUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	bool onSelf=(!(@onCritter!=null)&&!(@onItem!=null)&&!(@onScenery!=null));
	if(onSelf)
	{
		if(item.Val3!=0)
		{
			if(item.Val1==0&&cr.StatBase[(187)]<=item.Val3)
			{
				if(cr.GetTimeEvents(7,null,null,null)>0&&cr.Stat[(64)]>0)
				{
					cr.EraseTimeEvents(7);
					cr.StatBase[(64)]=0;
				}
				cr.StatBase[(187)]=item.Val3;
			}
			else if(item.Val2!=0||Random(0,1)>0)
			ApplyDesease(cr,cr.Id,item.Val3);
			else if(cr.StatBase[(187)]<item.Val3)
			cr.StatBase[(187)]=item.Val3;
		}
		cr.Say((11),"Вы вкололи шприц себе.");
		cr.Say((6),"Вкалывает шприц");
		DeleteItem(item);
		cr.AddItem((318),1);
		return true;
	}
	else if(cr.IsPlayer()&&(@cr!=null)&&(@onCritter!=null))
	{
		if(cr.Timeout[(238)]>0||onCritter.Timeout[(238)]>0)
		{
			cr.Say((11),"Это неуместно");
			return true;
		}
		if(item.Val3!=0&&onCritter.IsPlayer())
		{
			if(item.Val1==0&&onCritter.StatBase[(187)]<=item.Val3)
			{
				if(onCritter.GetTimeEvents(7,null,null,null)>0&&onCritter.Stat[(64)]>0)
				{
					onCritter.EraseTimeEvents(7);
					onCritter.StatBase[(64)]=0;
				}
				onCritter.StatBase[(187)]=item.Val3;
			}
			else if(item.Val2!=0||Random(0,1)>0)
			ApplyDesease(cr,onCritter.Id,item.Val3);
			else if(onCritter.StatBase[(187)]<item.Val3)
			onCritter.StatBase[(187)]=item.Val3;
		}
		cr.Say((11),"Вы вкололи шприц.");
		cr.Say((6),"Вкалывает шприц");
		DeleteItem(item);
		cr.AddItem((318),1);
		return true;
	}
	else
	cr.Say((11),"Это неуместно");
	return true;
}

bool e_BloodHypoSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(212))
	{
		int body=item.Val4;
		if(cr.CountItem((91))==0)
		{
			cr.Say((11),"Вам нужны соответствующие инструменты для анализа крови.");
			return true;
		}
		else if(cr.Skill[(212)]>50||cr.Skill[(212)]>50)
		{
			switch(body)
			{
				case 0:
				cr.Say((11),"Это кровь человека.");
				break;
				case 1:
				cr.Say((11),"Это кровь человека.");
				break;
				case 2:
				cr.Say((11),"Это кровь человека.");
				break;
				case 3:
				cr.Say((11),"Это кровь супермутанта.");
				break;
				case 4:
				cr.Say((11),"Это кровь гуля.");
				break;
				case 5:
				cr.Say((11),"Это кровь брамина.");
				break;
				case 6:
				cr.Say((11),"Это кровь скорпиона");
				break;
				case 7:
				cr.Say((11),"Это кровь крысы");
				break;
				case 8:
				cr.Say((11),"Это кровь летуна");
				break;
				case 9:
				cr.Say((11),"Это кровь кентавра");
				break;
				case 10:
				cr.Say((11),"Это гидравлическая жидкость, непонятно как она попала в шприц.");
				break;
				case 11:
				cr.Say((11),"Это кровь собаки");
				break;
				case 12:
				cr.Say((11),"Это жидкость мантиса");
				break;
				case 13:
				cr.Say((11),"Это кровь смертокогтя");
				break;
				case 14:
				cr.Say((11),"Это жидкость из растения");
				break;
				case 15:
				cr.Say((11),"Это кровь гекко");
				break;
				case 16:
				cr.Say((11),"Это кровь чужого");
				break;
			}
			if(cr.Skill[(212)]>100&&body<=4)
			{
				if(item.Val2==0)
				cr.Say((11),"Уровень лейкоцитов в норме.");
				else if(item.Val2<=50)
				cr.Say((11),"В крови присутствуют следы воздействия какого-то вируса.");
				else
				cr.Say((11),"Заметны образования в крови, видимо воздействие вируса было довольно продолжительным.");
			}
		}
		return true;
	}
	return false;
}

void _InitPackage(Item&item,bool firstTime)
{
	item.SetEvent((5),"e_PackageDrop");
	item.SetEvent((6),"e_PackageMove");
	item.SetEvent((4),"e_PackagePick");
}

void e_PackageDrop(Item&item,Critter&cr)
{
	cr.ModeBase[(539)]=0;
	cr.ModeBase[(540)]=0;
}

void e_PackageMove(Item&item,Critter&crit,uint8 fromSlot)
{
	if(item.CritSlot==(1))
	{
		crit.ModeBase[(539)]=0;
		crit.ModeBase[(540)]=1;
	}
	if(fromSlot==(1))
	{
		crit.ModeBase[(539)]=1;
		crit.ModeBase[(540)]=1;
		crit.Say((11),"Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести.");
	}
}

bool e_PackagePick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		if(cr.CountItem((1542))==0)
		{
			cr.ModeBase[(539)]=1;
			cr.ModeBase[(540)]=1;
			cr.Say((11),"Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести.");
			return false;
		}
		return true;
	}
	return true;
}

void _InitCompas(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_CompasUse");
}

bool e_CompasUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	string output="";
	
	Location@loc=GetLocation(5);
	if(loc!is null)
	{
		int x=cr.WorldX*0.1-loc.WorldX*0.1,y=cr.WorldY*0.1-loc.WorldY*0.1;
		if(cr.Skill[(217)]<100)
		{
			output+="Модок находиться : ";
			
			if(y>0)
			output+="Северо-";
			else if(y<0)
			output+="Юго-";
			if(x>0)
			output+="Западней";
			else if(x<0)
			output+="Восточней";
			else if(y>0)
			output="Модок находиться : Севернее";
			else if(y<0)
			output="Модок находиться : Южнее";
			else
			output="Стрелка постоянно крутится";
		}
		if(cr.Skill[(217)]>=100)
		{
			output="Координаты : x="+x+", y="+y;
		}
	}
	else
	output="Компас заклинило.";
	
	cr.Say((11),output);
	
	return false;
}

void Item_SetFrame(Item&item,uint8 frame)
{
	item.AnimStayBegin=frame;
	item.AnimStayEnd=frame;
	item.AnimShowBegin=frame;
	item.AnimShowEnd=frame;
	item.AnimHideBegin=frame;
	item.AnimHideEnd=frame;
	
	return;
}

void _InitScanner(Item&item,bool firstTime)
{
	(item.Flags=(item.Flags)|((0x10000000)));
	item.SetEvent((2),"UseScanner");
}

uint[]rad={10,25,50,100,200};

bool UseScanner(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(@onCritter is null&&@onItem is null&&@onScenery is null&&@cr.GetMap()!is null)
	{
		uint16 count=0;
		if(cr.Skill[(212)]<20)
		cr.Say((11),"Вы не умеете пользоваться этим предметом");
		if(cr.Skill[(212)]>=20)
		++count;
		if(cr.Skill[(212)]>=35)
		++count;
		if(cr.Skill[(212)]>=50)
		++count;
		if(cr.Skill[(212)]>=60)
		++count;
		if(cr.Skill[(212)]>=75)
		++count;
		
		cr.ShowScreen((2),count,"item@answer_SCANNER");
		cr.Say((18),"Выберите радиус сканируемой зоны");
		
		for(uint8 i=0;i<count;i++)
		{
			cr.Say((19+(i)),""+rad[i]);
		}
		return true;
	}
	else return true;
}

void Find(uint rad,Critter&cr,Map&map)
{
	cr.Wait(rad*50);
	cr.Say((11),"В радиусе "+rad+" метров обнаружено "+map.GetCrittersHex(cr.HexX,cr.HexY,rad,(0x01),null)+" живых организмов");
}

void answer_SCANNER(Critter&cr,uint answerI,string&answerS)
{
	Map@map=cr.GetMap();
	if(@map!is null)
	Find(rad[answerI],cr,map);
}

void ProccessFood(Critter&cr,Item&item)
{
	uint8 hungerBonus=item.Proto.Food_Restore;
	uint8 thristBonus=item.Proto.Food_Thrist;
	
	int Hb=cr.StatBase[(128)];
	int Tb=cr.StatBase[(127)];
	
	cr.StatBase[(128)]+=hungerBonus;
	cr.StatBase[(127)]+=thristBonus;
	
	int Ha=(((cr.StatBase[(128)])>(100))?(100):(((cr.StatBase[(128)])<(0))?(0):(cr.StatBase[(128)])));
	int Ta=(((cr.StatBase[(127)])>(100))?(100):(((cr.StatBase[(127)])<(0))?(0):(cr.StatBase[(127)])));
	
	uint flag=item.Proto.Food_Flags;
	
	bool isPoison=((((0x00000004))&(flag))!=0);
	bool isRad=((((0x00000002))&(flag))!=0);
	
	if(!isPoison&&cr.StatBase[(73)]>0)
	cr.StatBase[(73)]-=(thristBonus+hungerBonus)*0.25;
	if(!isRad&&cr.StatBase[(74)]>0)
	cr.StatBase[(74)]-=(thristBonus+hungerBonus)*0.1;
	
	int Hd=Ha-Hb;
	int Td=Ta-Tb;   
	
	cr.StatBase[(127)]+=thristBonus; 
	
	uint PID=item.GetProtoId();
	
	if(PID==(533))cr.AddItem((532),1);
	if(
	PID==(49)||
	PID==(1627)||
	PID==(106)||
	PID==(124)||
	PID==(125)||
	PID==(310)||
	PID==(311)||
	PID==(469)
	)
	cr.AddItem((542),1);
	
	if(
	PID==(40)||
	PID==(48)||
	PID==(110)||
	PID==(144)||
	PID==(525)
	)
	cr.AddItem((318),1);
	
	if(PID==(259))
	cr.StatBase[(76)]+=3000; 
	
	if(flag!=0)
	{
		if(((((0x00000001))&(flag))!=0))
		{
			cr.ToKnockout(((true)?(82):(83)),((true)?(86):(87)),((true)?(88):(89)),25,cr.HexX,cr.HexY);
		}
		if(((((0x00000004))&(flag))!=0))
		{
			AffectPoison(cr,Random(25,55));
		}
		if(((((0x00000002))&(flag))!=0))
		{
			AffectRadiation(cr,Random(20,55)*10);
		}
	}
}

void _GasMask(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_GasMaskUse");
	item.SetEvent((6),"e_GasMaskMove");
}

void e_GasMaskMove(Item&item,Critter&crit,uint8 fromSlot)
{
	if(item.CritSlot==(2))
	{
		crit.Say((11),"Вы одели респиратор.");
	}
	if(fromSlot==(2))
	{
		crit.Say((11),"Вы сняли респиратор.");
	}
}

bool e_GasMaskUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(cr.GetItems((2),null)!=0)
	{
		cr.Say((11),"Уберите из рук все лишнее, чтобы нормально одеть респиратор.");
	}
	else
	{
		cr.MoveItem(item.Id,1,(2));
	}
	return true;
}

void _FireFood(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_FireFoodUse");
}

bool e_FireFoodUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((11),"Пока нет функционала.");
	return false;
}

void _BonesInit(Item&item,bool firstTime)
{
	item.SetEvent((3),"e_BonesUseItem");
}

bool e_BonesUseItem(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetProtoId()==(289))
	{
		DeleteItem(item);
		crit.Say((11),"Вы закопали тело.");
		return true;
	}
	return false;
} 

void _InitToken(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_TokenPick");
	item.SetEvent((5),"e_TokenDrop");
	item.SetEvent((6),"e_TokenMove");
}

bool e_TokenPick(Item&item,Critter&cr,int skill)
{
	DeleteItem(item);
	return false;
}

void e_TokenDrop(Item&item,Critter&crit)
{
	DeleteItem(item);
}

void e_TokenMove(Item&item,Critter&crit,uint8 fromSlot)
{
	DeleteItem(item);
}

void SetWorkbench(Critter&cr,int item_id,int item_type,int p2)
{
	Item@item=GetItem(item_id);
	if(!(@item!=null))return;
	string[]type_names={"_InitWorkBench","_InitFurnace","_InitCoinPress","_InitSawmill","_InitLathe"};
	if(uint(item_type)>=type_names.length()){
		cr.Say((11),"Не так.");
		return;
	}
	item.SetScript(type_names[item_type]);
	item.Update();
}

void _InitWorkBench(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_WorkBenchPick");
	item.SetEvent((3),"e_WorkBenchCloneKey");
}

bool e_WorkBenchCloneKey(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetType()==(7))
	{
		if(crit.CountItem((475))<=0)
		{
			crit.Say((11),"Вам нужна железная болванка.");
			return true;
		}
		Item@newKey=crit.AddItem((1313),1);
		newKey.LockerId=usedItem.LockerId;
		newKey.SetLexems("$KeyLex"+"some key");
		crit.StatBase[(90)]=newKey.Id;
		crit.ShowScreen((5),0,"item@KeyUseScreen");
		newKey.Update();
		crit.DeleteItem((475),1);
		return true;
	}
	return false;
}

bool e_WorkBenchPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		Item@Workplace;
		@Workplace=cr.GetMap().GetItem(cr.HexX,cr.HexY,(1524));
		if(!(@Workplace!=null)){
			@Workplace=cr.GetMap().AddItem(cr.HexX,cr.HexY,(1524),1);
			Workplace.SetScript("_WorkplaceInit");
		}
		
		if(cr.CountItem((3978))==0)cr.AddItem((3978),1);
		cr.ShowScreen((9),0,"");
	}
	return true;
}

void _InitFurnace(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_FurnaceUseSkill");
	item.SetEvent((3),"e_FurnaceUseItem");
}

bool e_FurnaceUseItem(Item&item,Critter&crit,Item@usedItem){
	if(!(@usedItem!=null))return false;
	uint pid=usedItem.GetProtoId();
	
	uint[][]fuel={
		{(286),1},
		{(1425),2},
		{(1488),3}
	};
	for(uint i=0,iEnd=fuel.length();i<iEnd;i++){
		if(fuel[i][0]==pid){
			crit.Say((11),"Вы добавили топливо.");
			item.Val0+=fuel[i][1];
			return true;
		}
	}
	
	uint[][]junk={
		{(1507),1,2},
		{(1508),1,2},
		{(1510),1,0},
		{(1505),1,1}
	};
	for(uint i=0,iEnd=junk.length();i<iEnd;i++){
		if(junk[i][0]==pid){
			do{if(usedItem.GetCount()>(1))
				usedItem.SetCount(usedItem.GetCount()-(1));else
				DeleteItem(usedItem);}while(false);
			crit.Say((11),"Вы добавили метал для переплавки.");
			item.Val1+=junk[i][1];
			item.Val2+=junk[i][2];
			return true;
		}
	}
	return false;
}

bool e_FurnaceUseSkill(Item&item,Critter&cr,int skill){
	if((skill!=(-1))||(item.Accessory!=(2))){
		cr.Say((11),"Предмет должен стоять на земле. Работайте руками.");
		return false;
	}
	Item@Workplace;
	@Workplace=cr.GetMap().GetItem(cr.HexX,cr.HexY,(1524));
	if(!(@Workplace!=null)){
		@Workplace=cr.GetMap().AddItem(cr.HexX,cr.HexY,(1524),1);
		Workplace.SetScript("_WorkplaceInit");
	}
	if(cr.CountItem((3978))==0)cr.AddItem((3978),1);
	cr.StatBase[(90)]=item.Id;
	answer_FurnaceSkill(cr,0,"");
	return true;
}

void answer_FurnaceSkill(Critter&player,uint answerI,string&answerS){
	Item@furnace=GetItem(player.StatBase[(90)]);
	if(!(@furnace!=null))return;
	if(answerI==0)player.Say((6),"смотрит на огонь");
	if(answerI==1){
		if(player.CountItem((20))==0){
			player.Say((11),"Вам нужен лом для этого.");
			return;
		}
		if(furnace.Val2<=0){
			player.Say((5),"шерудит ломом");
			player.Say((11),"Из этого ничего не вышло.");
			return;
		}
		player.Say((5),"выгребает шлак");
		player.AddItem((98),1);
		furnace.Val2--;
	}
	if(answerI==2){
		if(furnace.Val1<=0){
			player.Say((5),"проверяет слив металла");
			player.Say((11),"Из этого ничего не вышло.");
			return;
		}
		player.Say((5),"отливает слитки");
		player.AddItem((1474),1);
		furnace.Val1--;
	}
	if(answerI==3){
		if(player.CountItem((20))==0){
			player.Say((11),"Вам нужен лом для этого.");
			return;
		}
		if(furnace.Val0<=0){
			player.Say((5),"шерудит ломом");
			player.Say((11),"Из этого ничего не вышло.");
			return;
		}
		player.Say((5),"выгребает угли");
		player.AddItem((1438),Random(0,10));
		furnace.Val0--;
	}
	player.ShowScreen((2),4,"answer_FurnaceSkill");
	player.Say((18),
	"Топливо: "+furnace.Val0+
	". Металл: "+furnace.Val1+
	". Шлак: "+furnace.Val2+
	". Выберите действие:");
	player.Say((19+(0)),"смотреть на огонь");
	player.Say((19+(1)),"выгрести шлак");
	player.Say((19+(2)),"слить металл");
	player.Say((19+(3)),"потушить");
}

void _InitCoinPress(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_WorkBenchPick");
	item.SetEvent((3),"e_WorkBenchCloneKey");
}

void _InitSawmill(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_WorkBenchPick");
	item.SetEvent((3),"e_WorkBenchCloneKey");
}

void _InitLathe(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_WorkBenchPick");
	item.SetEvent((3),"e_WorkBenchCloneKey");
}

void _WorkplaceInit(Item&item,bool firstTime)
{
	item.SetEvent((7),"_WorkplaceWalk");
}
void _WorkplaceWalk(Item&item,Critter&crit,bool entered,uint8 dir)
{
	if(!entered)
	{
		Item@Token=crit.GetItem((3978),-1);
		if((@Token!=null))DeleteItem(Token);
		Item@Token2=crit.GetItem((3979),-1);
		if((@Token2!=null))DeleteItem(Token2);
	}
}