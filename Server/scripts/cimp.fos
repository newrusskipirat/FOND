// CIMP - Class Interactive Map P - wtf?! Y P?
// powermagic

#include "_macros.fos"
#include "_defines.fos"
#include "_itempid.fos"

// #include "_global_events.fos"

// import uint GetTile(Map& map, uint16 hexX, uint16 hexY, uint8 layer) from "qmap";

#define MAX_LO_COUNT           ( 100 )
#define MAX_RECH_LEVEL         ( 1000 )

#define GROUP_LENGTH           ( 14 )
#define GROUP_ROCK             ( 0 )
#define GROUP_ANIMAL_CORPSE    ( 1 )
#define GROUP_SMALL_TRASH      ( 2 )
#define GROUP_TRASH            ( 3 )
#define GROUP_SLEEPER          ( 4 )
#define GROUP_BOX              ( 5 )
#define GROUP_METAL_TRASH      ( 6 )
#define GROUP_NEWSP_MACHINE    ( 7 )
#define GROUP_BOTTLE_BOX       ( 8 )
#define GROUP_PLANT            ( 9 )
#define GROUP_CORPSE           ( 10 )
#define GROUP_ROAD              (11)
#define GROUP_PPL_ON_ROAD       (12)
#define GROUP_JUNKYARD          (13)
#define GROUP_EVILMINDS        ( 100 )

#define TILE_PATH              ( "art/tiles/" )
#define TILE_FRM               ( ".frm" )
#define TILE_PNG               ( ".png" )
// use it TileGroup
#define TILE_GROUP_ROAD        ( 1 ) // 0x00000001
#define TILE_GROUP_SAND        ( 2 ) // 0x00000002
#define TILE_GROUP_SIDEWALK    ( 3 ) // 0x00000004
#define TILE_GROUP_BRICK       ( 4 ) // 0x00000008
#define TILE_GROUP_CAVE        ( 5 ) // 0x00000010
#define TILE_GROUP_GROUND      ( 6 ) // 0x00000020
#define TILE_GROUP_GRID        ( 7 ) // 0x00000040
#define TILE_GROUP_COUNT       ( 8 )


uint[] MAPS_ROAD = {750, 751, 752, 755, 756, 757, 760, 761, 762, 765, 766, 767, 770, 771, 772, 775, 776, 777, 780, 781, 782, 785, 786, 787, 790, 791, 792, 795, 796, 797};
uint[] MAPS_WASTELAND = {500, 501, 502, 503, 504, 505, 506, 507, 508, 509};
/*img
 * shit!
 *              mstr49.frm
 *              mstr48.frm
 *              mstr50.frm
 * *            mstr51.frm
 * bigshiiit!
 *              mstr42.frm
 * *            mstr43.frm
 * *            mstr45.frm
 * oh shit!!!
 * *            mstr40.frm
 * *            mstr41.frm
 */
// #define

class CIMP
{
    bool   Destroible;

    uint16 TileGroup;

    uint16 HexX;
    uint16 HexY;
    uint   Hash;

    Item@  object;

    CIMP()
    {
        @object = null;

        HexX = 0;
        HexY = 0;
        Hash = 0;

        Destroible = false;
    }

    CIMP( uint hash, Item & item, bool destroible )
    {
        Hash = hash;
        @object = item;

        Destroible = destroible;

        if( SetPic() )
        {
            HexX = object.HexX;
            HexY = object.HexY;
        }
    }

    CIMP( uint hash, Map & map )
    {
        Spawn( map );
        SetPic( hash );
    }

    bool Spawn( Map& map )
    {
        uint16 hexX = 0, hexY = 0, beginX = 0, beginY = 0, endX = 0, endY = 0;
        uint   hash = 0;
		@object = null;
		
        if( map.GetEntireCoords( 255, 0, beginX, beginY ) && map.GetEntireCoords( 0, 0, endX, endY ) )
		{
			uint count = 0;

			if( !tileInited )
				InitTiles();
			do
			{
				hexX = Random( beginX + 1, endX - 1 );
				hexY = Random( beginY + 1, endY - 1 );

				hash = map.GetTile( THX( hexX ), THX( hexY ) );
				
				for( uint i = 1; i <= 32; ++i )
					if( FLAG( TileGroup, pow( 2, i ) ) && IsTileAvalible( hash, i ) )
						break;

				if( count++ >= 50 )
					return false;
			}
			while( !map.IsHexPassed( hexX, hexY ) );

			@object = map.AddItem( hexX, hexY, PID_LO_CONTAINER, 1 );

			if( @object !is null )
				object.SetEvent( ITEM_EVENT_SKILL, "cimp@e_SkillImp" );

			HexX = hexX;
			HexY = hexY;
		}
        return ( @object !is null );
    }

    private bool SetMapPic( uint hash )
    {
        if( object is null )
            return false;

        object.SetMapPic( hash );
        object.Update();
        return true;
    }

    bool SetPic(){return SetPic( Hash );}
    bool SetPic( uint hash ){ return SetMapPic( hash ); }
    Item@ get_Object(){ return @object; }
}

bool e_SkillImp( Item& item, Critter& cr, int skill )
{
    // temprorary
    if( skill == SKILL_TAKE_CONT && item.GetItems( uint( -1 ), null ) == 1 )
    {
        DeleteItem( item );
        return true;
    }
    return false;
}

class CLO : CIMP
{

    int                 RechLevel;
    uint16              GroupType;

    RespawnedItemGroup@ Group;

    CLO()
    {
        Destroible = false;
        RechLevel = 0;
        GroupType = uint16( -1 );
        @Group = null;
    }

    CLO( uint16 groupType, int rechLvl, bool destroible )
    {
        Destroible = false;
        RechLevel = rechLvl;
        GroupType = groupType;

        @Group = GetItemGroup( GroupType );
        TileGroup = Group.TileGroup;
        Destroible = destroible;



        if( Group is null )
            Log( "NULL!!" );


    }

    CLO( uint mapPid, int rechLvl )
    {
        Destroible = false;
        RechLevel = rechLvl;
        GroupType = 0;

        for(;GroupType < GROUP_LENGTH; ++GroupType){
            @Group = GetItemGroup( GroupType );
            if(Group.MapProtos.find( mapPid ) == -1)
                continue;

            TileGroup = Group.TileGroup;
            Destroible = true;
        }

        if( Group is null )
            Log( "NULL!!" );

    }

    bool SpawnInto()
    {
        if( Group is null || object is null )
        {
            Log( "NULL!!" );
            return false;
        }

        Map @ map = GetMap( object.MapId );
        if( map is null )
        {
            return false;
        }
        else
        {
            if( Group.MapProtos.find( map.GetProtoId() ) == -1 )
            {
                //Log( "карта не подходит " + map.GetProtoId() );
                DeleteItem( object );
                return false;
            }
        }

        int len = Group.Length()-1;

        //if( RechLevel == -1 )
        //    len = Group.Length();

        for( uint16 i = 0 /*, j = Group.Length()*/; i < len; ++i )
        {
            uint8  chance = Random( 0, 95 );
            uint16 index = Random( 0, len );
            //uint16 index = ( RechLevel != -1 ? Random( 0, Group.Length() - 1 ) : i );
            // Log("chance : "+Group.RespItems[i].Chance+"/"+chance);

            uint8  count = /*Group.RespItems[i].Count*/ 0;
            uint16 pid = /*Group.RespItems[i].Pid*/ 0;

            Group.GetItem( index, pid, count );

            while( Group.RespItems[ index ].Chance > chance && --count > 0)
			{
                if( @Object is null )
                {
                    Log( "NULL!!OBJ" );
                    return false;
                }
				
                chance = Random(chance, 95);
                object.AddItem( pid, 1, 0 );
            }
        }
        return true;
    }

    bool SpawnMap( Map& map )
    {
        return Spawn( map );

    }

    bool Add( Map& map )
    {
		if( !Spawn( map ) )
			return false;
			
		if( !SetPic( GetLOHash( GroupType ) ) )
			return false;
			
		if( !SpawnInto( ) )
			return false;
		return true;
    }
}

class RespawnedItem
{
    uint8  Chance;
    uint8  Count;
    uint16 Pid;

    RespawnedItem()
    {
        Chance = 0;
        Count = 0;
        Pid = 0;
    }

    RespawnedItem( uint16 pid, uint8 chance, uint8 count )
    {
        Chance = chance;
        Count = count;
        Pid = pid;
    }


}

class RespawnedItemGroup
{
    RespawnedItem[] RespItems;
    uint[] MapProtos;
    uint TileGroup;

    RespawnedItemGroup()
    {
        RespItems.resize( 0 );
    }

    uint16 Length()
    {
        return RespItems.length();
    }

    bool GetItem( uint16 index, uint16& pid, uint8& count )
    {
        if( index >= RespItems.length() )
            return false;

        pid = RespItems[ index ].Pid;
        count = RespItems[ index ].Count;

        return true;
    }
}
/* old
   class GroupTrash	: RespawnedItemGroup
   {
        GroupTrash(){
                RespItems.insertLast(RespawnedItem(PID_NUKA_COLA, 1, 1));
                RespItems.insertLast(RespawnedItem(PID_BEER, 1,3));
                RespItems.insertLast(RespawnedItem(PID_BOOZE,1,3));
                RespItems.insertLast(RespawnedItem(PID_CRAFT_M_JUNK,50,1));
                RespItems.insertLast(RespawnedItem(PID_CRAFT_L_LINT,15,2));

                RespItems.insertLast(RespawnedItem(1610,5,2));
                RespItems.insertLast(RespawnedItem(1620,5,2));

                uint[] tempPids = {60,63,65,67,69,71,73,75,77,79,81,83}; //all ground satter maps without center
                MapProtos = tempPids;

        }
   }

   class GroupBoxes	: RespawnedItemGroup
   {
        GroupBoxes(){
                RespItems.insertLast(RespawnedItem(PID_REAL_BOTTLE_CAPS, 20, 3));
                RespItems.insertLast(RespawnedItem(PID_TUBE, 20, 1));
                RespItems.insertLast(RespawnedItem(PID_CRAFT_M_BARS, 20, 2));
                RespItems.insertLast(RespawnedItem(PID_CRAFT_M_BARS, 20, 2));
                RespItems.insertLast(RespawnedItem(PID_BOTTLE_FULL, 10, 1));
                RespItems.insertLast(RespawnedItem(PID_LIGHTER, 5, 1));
                RespItems.insertLast(RespawnedItem(PID_CATS_PAW, 5, 1));
                RespItems.insertLast(RespawnedItem(PID_CRAFT_L_LINT,15,2));

                RespItems.insertLast(RespawnedItem(1610,5,2));
                RespItems.insertLast(RespawnedItem(1620,5,2));

                uint[] tempPids = {60,63,65,67,69,71,73,75,77,79,81,83}; //all ground satter maps without center
                MapProtos = tempPids;
        }
   }


   class GroupRocks     :RespawnedItemGroup
   {
        GroupRocks(){
                RespItems.insertLast(RespawnedItem(PID_ROCK, 100, 10));

                uint[] tempPids = {60,63,65,67,69,71,73,75,77,79,81,83}; //all ground satter maps without center
                MapProtos = tempPids;
        }
   }

   class GroupBones     :RespawnedItemGroup
   {
        GroupBones(){
                //medicine
                RespItems.insertLast(RespawnedItem(PID_STIMPAK, 1, 1));
                RespItems.insertLast(RespawnedItem(PID_RADAWAY,1,1));
                RespItems.insertLast(RespawnedItem(PID_ANTIDOTE,5,1));
                RespItems.insertLast(RespawnedItem(PID_MEDCLIP, 1, 1));
                RespItems.insertLast(RespawnedItem(PID_MEDSPLINT, 1, 1));
                RespItems.insertLast(RespawnedItem(PID_MEDTHREAD, 1,1));
                RespItems.insertLast(RespawnedItem(PID_MEDNEEDLE, 1,1));
                RespItems.insertLast(RespawnedItem(PID_ANESTETIC, 1,1));
                RespItems.insertLast(RespawnedItem(PID_BANDAGE, 5,1));
                RespItems.insertLast(RespawnedItem(PID_ANTISEPTIC, 1,1));

                RespItems.insertLast(RespawnedItem(1610,5,2));
                RespItems.insertLast(RespawnedItem(1620,5,2));

                //food
                RespItems.insertLast(RespawnedItem(PID_NUKA_COLA, 4, 1));
                RespItems.insertLast(RespawnedItem(PID_BEER, 4,2));
                RespItems.insertLast(RespawnedItem(PID_BOOZE,4,3));
                RespItems.insertLast(RespawnedItem(PID_GAMMA_GULP_BEER,1,1));
                RespItems.insertLast(RespawnedItem(PID_ROENTGEN_RUM,1,1));
                RespItems.insertLast(RespawnedItem(PID_ROT_GUT,1,1));

                RespItems.insertLast(RespawnedItem(PID_MUTATED_FRUIT,5,3));
                RespItems.insertLast(RespawnedItem(PID_IGUANA_ON_A_STICK,2,1));
                RespItems.insertLast(RespawnedItem(PID_MEAT_ON_A_STICK,3,1));

                //money
                RespItems.insertLast(RespawnedItem(PID_REAL_BOTTLE_CAPS,1,10));

                uint[] tempPids = {60,63,65,67,69,71,73,75,77,79,81,83}; //all ground satter maps without center
                MapProtos = tempPids;
        }
   }

 */


class GroupRock : RespawnedItemGroup
{
    GroupRock()
    {

        RespItems.insertLast( RespawnedItem( PID_ROCK, 50, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_METAL_ORE, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_MINERAL, 3, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 2;
    }
}


class GroupAnimalCorpse : RespawnedItemGroup
{
    GroupAnimalCorpse()
    {

        RespItems.insertLast( RespawnedItem( PID_MEAT, 1, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_RAD_MEAT, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_BRAHMIN_SKIN, 1, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;
    }
}


class GroupSmallTrash   : RespawnedItemGroup
{
    GroupSmallTrash()
    {

        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_LINT, 3, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_JUNK, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_EMPTY, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_GLASS, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_REAL_BOTTLE_CAPS, 15, 10 ) );
        RespItems.insertLast( RespawnedItem( PID_PART_OF_ROPE, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 1, 2 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;

    }
}

class GroupTrash        : RespawnedItemGroup
{
    GroupTrash()
    {

        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_LINT, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_JUNK, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_EMPTY, 5, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_GLASS, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_REAL_BOTTLE_CAPS, 15, 10 ) );
        RespItems.insertLast( RespawnedItem( PID_PART_OF_ROPE, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_FROZEN_DINNER, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOX_OF_NOODLES, 1, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;

    }
}


class GroupSleeper      : RespawnedItemGroup
{
    GroupSleeper()
    {

        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_RAGS, 5, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_STIMPAK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_RADAWAY, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_JET, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_KNIFE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BLUE_CONDOM, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_GREEN_CONDOM, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_RED_CONDOM, 1, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 2;

    }
}

class GroupBox  : RespawnedItemGroup
{
    GroupBox()
    {

        RespItems.insertLast( RespawnedItem( PID_FROZEN_DINNER, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOX_OF_NOODLES, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_FLARE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_JUNK, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 1, 2 ) );


        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 2;

    }
}



class GroupMetalTrash   : RespawnedItemGroup
{
    GroupMetalTrash()
    {


        RespItems.insertLast( RespawnedItem( PID_PLANK, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_IRON_DETALS, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_TUBE, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_STEL, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_HLAM2_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_PERED_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_OHLAD_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_DETAL_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BANKA_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SPIKE_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_HLAM_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_EMKOCT_MEH, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SOED_MEH, 3, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;

    }
}

class GroupNewspMachine : RespawnedItemGroup
{
    GroupNewspMachine()
    {

        RespItems.insertLast( RespawnedItem( PID_BOTTLE_CAPS, 3, 2 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 4;
    }
}

class GroupBottleBox    : RespawnedItemGroup
{
    GroupBottleBox()
    {

        RespItems.insertLast( RespawnedItem( PID_BOTTLE_EMPTY, 10, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_GLASS, 15, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_BEER, 2, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_BOOZE, 2, 3 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;

    }
}

class GroupPlant        : RespawnedItemGroup
{
    GroupPlant()
    {


        RespItems.insertLast( RespawnedItem( PID_BROC_FLOWER, 100, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_XANDER_ROOT, 100, 3 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 2;

    }
}

class GroupCorpse       : RespawnedItemGroup
{
    GroupCorpse()
    {

        RespItems.insertLast( RespawnedItem( PID_KNIFE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_EMPTY, 3, 1 ) );

        uint[] tempPids = { 60, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83 }; // all ground satter maps without center
        MapProtos = tempPids;

        TileGroup = 7;

    }
}

class GroupEvilMinds    : RespawnedItemGroup
{
    GroupEvilMinds()
    {
        RespItems.insertLast( RespawnedItem( PID_ADVANCED_POWER_ARMOR_MK2, 100, 1 ) );

        RespItems.insertLast( RespawnedItem( PID_LASER_RIFLE_EXT_CAP, 100, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_GRENADELAUNCHER, 100, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_ASSAULT_RIFLE_EXT_MAG, 100, 1 ) );

        RespItems.insertLast( RespawnedItem( PID_5MM_JHP, 100, 10 ) );
        RespItems.insertLast( RespawnedItem( PID_GRENADELAUNCHER_AMMO, 100, 24 ) );
        RespItems.insertLast( RespawnedItem( PID_MICRO_FUSION_CELL, 100, 100 ) );

    }
}

class GroupRoad : RespawnedItemGroup
{
    GroupRoad()
    {

        RespItems.insertLast( RespawnedItem( PID_BOTTLE_EMPTY, 5, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_GLASS, 5, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SMITTY_MEAL, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BOX_OF_NOODLES, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_FROZEN_DINNER, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CHEEZY_POOFS, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_LINT, 25, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_RAGS, 27, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_HIDE, 5, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BRAHMIN_SKIN, 4, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_MOUSE_SKIN, 10, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_PART_OF_ROPE, 15, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_ROCK, 10, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_GUNPOWDER, 2, 2 ) );

        //uint[] tempPids = MAPS_ROAD; //
        MapProtos = MAPS_ROAD;

        TileGroup = TILE_GROUP_ROAD;  //биом дорога. Хорошо бы разместить там какие-нибудь контейнеры/либо придать свойство контейнера кучкам мусора
    }
}

//road
//750, 751, 752, 755, 756, 757, 760, 761, 762, 765, 766, 767, 770, 771, 772, 775, 776, 777, 780, 781, 782, 785, 786, 787, 790, 791, 792, 795, 796, 797


class GroupPeopleontheroad : RespawnedItemGroup
{
    GroupPeopleontheroad()
    {

        RespItems.insertLast( RespawnedItem( PID_COSMETIC_CASE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SKIN_CHANGER, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_RUBBER_BOOTS, 4, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CATS_PAW, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BECKY_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_HUBOLOGIST_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_ACCOUNT_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SHOVEL, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_PLANK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_AXE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SPEARTHROWER1, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SPEARTHROWER2, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_COOKED_GECKO_MEAT, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_COOKED_FISH, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_GUNPOWDER, 1, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_RAD_MEAT, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_BRAHMIN_SKIN, 1, 1 ) );

        //uint[] tempPids = {  }; //
        MapProtos = MAPS_WASTELAND;

        TileGroup = TILE_GROUP_SAND;  //Случайные путники по дороге. Могут разнообразить геймплей. Если будет одобрено напишу диалоги
    }
}


class GroupRuins   : RespawnedItemGroup
{
    GroupRuins()
    {

        RespItems.insertLast( RespawnedItem( PID_WATER_FLASK, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_VIC_WATER_FLASK, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_VIC_RADIO, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BLUE_CONDOM, 2, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_GREEN_CONDOM, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_RED_CONDOM, 4, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_FLOWER, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_COSMETIC_CASE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SKIN_CHANGER, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_RUBBER_BOOTS, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CATS_PAW, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BECKY_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_HUBOLOGIST_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_ACCOUNT_BOOK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SHOVEL, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_PLANK, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_AXE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SPEARTHROWER1, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SPEARTHROWER2, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SMITTY_MEAL, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_BOX_OF_NOODLES, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_RAGS, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_HIDE, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_HIDE, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_GUNPOWDER, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_BOTTLE_GLASS, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_REAL_BOTTLE_CAPS, 15, 27 ) );
        RespItems.insertLast( RespawnedItem( PID_PART_OF_ROPE, 2, 5 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 1, 2 ) );

        uint[] tempPids = {600, 601, 602 }; //
        MapProtos = tempPids;

        TileGroup = 2; //Для контейнеров в руинах фермы, леса, чего-то ещё

    }
}

class GroupJunkyard        : RespawnedItemGroup
{
    GroupJunkyard()
    {

        RespItems.insertLast( RespawnedItem( PID_VIC_WATER_FLASK, 2, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_VIC_RADIO, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SHOVEL, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_PLANK, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_MUSH_GREEN, 10, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_RAGS, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_FLOWER, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_METAL_ORE, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_MINERAL, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_GUNPOWDER, 3, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_TUBE, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_WATER_TUBE, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_IRON_PLATE, 7, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_IRON_BAR, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_IRON_DETALS, 5, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_PB_PLATE, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_PB_FOR_AMMO, 1, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_PERED_MEH, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_SOED_MEH, 6, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_OHLAD_MEH, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_DETAL_MEH, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_EMKOCT_MEH, 5, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_HLAM_MEH, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_HLAM2_MEH, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_BANKA_MEH, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_SPIKE_MEH, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_ELECTO_MEH, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_MAG_LENTA, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_DVIGAT_MEH, 1, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_DVIGAT_MEH, 7, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_REVOLVER_PART, 4, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_SHORT_TUBE, 4, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_TRIGGER, 3, 1 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_E_LAMP, 6, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_E_PART, 2, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_E_CHIP, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_JUNK, 6, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_BARS, 7, 3 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_M_STEL, 4, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_CRAFT_L_LINT, 3, 2 ) );
        RespItems.insertLast( RespawnedItem( PID_REAL_BOTTLE_CAPS, 15, 10 ) );
        RespItems.insertLast( RespawnedItem( PID_PART_OF_ROPE, 2, 5 ) );

        uint[] tempPids = {43}; //
        MapProtos = tempPids;

        TileGroup = 2;//пещеры
    }
}

uint GetLOHash( uint16 groupType )
{
    string temp = "art\\scenery\\";
    string[] tempAdd;
    switch( groupType )
    {
    /*case GROUP_BOXES :	tempAdd.insertLast("boxes3.frm"); //old
                            tempAdd.insertLast("boxes1.frm");
                            tempAdd.insertLast("boxes4.frm");
                            break;

       case GROUP_ROCKS:	tempAdd.insertLast("rock01.frm");
                            tempAdd.insertLast("rock02.frm");
                            tempAdd.insertLast("rock03.frm");
                            tempAdd.insertLast("rock04.frm");
                            tempAdd.insertLast("rock05.frm");
                            tempAdd.insertLast("rock06.frm");
                            break;

       case GROUP_BONES :	tempAdd.insertLast("bone01.frm");
                            tempAdd.insertLast("bone02.frm");
                            tempAdd.insertLast("bone03.frm");
                            break;

       case GROUP_TRASH :	tempAdd.insertLast("trash1.frm");
                            tempAdd.insertLast("trash2.frm");
                            tempAdd.insertLast("trash3.frm");
                            break;

       case GROUP_TRATA :	tempAdd.insertLast("trash1.frm");
                            tempAdd.insertLast("trash2.frm");
                            tempAdd.insertLast("trash3.frm");
                            break;

     */
    case GROUP_EVILMINDS:
        tempAdd.insertLast( "locker5.frm" );
        break;

    case GROUP_CORPSE:
        tempAdd.insertLast( "dead01.frm" );
        tempAdd.insertLast( "dead02.frm" );
        tempAdd.insertLast( "dead03.frm" );
        tempAdd.insertLast( "dead04.frm" );
        tempAdd.insertLast( "v13bones.frm" );
        tempAdd.insertLast( "bone01.frm" );
        tempAdd.insertLast( "bone03.frm" );
        break;

    case GROUP_PLANT:
        //tempAdd.insertLast( "xander.frm" );
        //tempAdd.insertLast( "brocflw.frm" );
        tempAdd.insertLast( "weed06.frm" );
        tempAdd.insertLast( "weed07.frm" );
        break;

    case GROUP_BOTTLE_BOX:
        tempAdd.insertLast( "crate01.frm" );
        tempAdd.insertLast( "crate02.frm" );
        tempAdd.insertLast( "crate03.frm" );
        break;

    case GROUP_NEWSP_MACHINE:
        tempAdd.insertLast( "mailbx.frm" );
        tempAdd.insertLast( "newsp1.frm" );
        tempAdd.insertLast( "newsp2.frm" );
        tempAdd.insertLast( "newsp3.frm" );
        tempAdd.insertLast( "newsp4.frm" );
        tempAdd.insertLast( "newsp5.frm" );
        tempAdd.insertLast( "newsp6.frm" );
        tempAdd.insertLast( "novbud1.frm" );
        tempAdd.insertLast( "novbud2.frm" );
        break;

    case GROUP_METAL_TRASH:
        tempAdd.insertLast( "junk1.frm" );
        tempAdd.insertLast( "junk2.frm" );
        tempAdd.insertLast( "junk3.frm" );
        tempAdd.insertLast( "junk4.frm" );
        tempAdd.insertLast( "junk5.frm" );
        break;

    case GROUP_BOX:
        tempAdd.insertLast( "boxes1.frm" );
        tempAdd.insertLast( "boxes2.frm" );
        tempAdd.insertLast( "boxes3.frm" );
        tempAdd.insertLast( "boxes4.frm" );
        tempAdd.insertLast( "njunk5.frm" );
        tempAdd.insertLast( "njunk6.frm" );
        tempAdd.insertLast( "boxes02.frm" );
        tempAdd.insertLast( "boxes03.frm" );
        tempAdd.insertLast( "boxes04.frm" );
        break;

    case GROUP_SLEEPER:
        tempAdd.insertLast( "bed1.frm" );
        tempAdd.insertLast( "bed2.frm" );
        tempAdd.insertLast( "bed3.frm" );
        tempAdd.insertLast( "bed4.frm" );
        tempAdd.insertLast( "bed5.frm" );
        tempAdd.insertLast( "bed6.frm" );
        tempAdd.insertLast( "bed7.frm" );
        tempAdd.insertLast( "bed8.frm" );
        break;

    case GROUP_TRASH:
        tempAdd.insertLast( "trashcn.frm" );
        tempAdd.insertLast( "kont1.frm" );
        tempAdd.insertLast( "kontsmet.frm" );
        tempAdd.insertLast( "weed05.frm" );
        break;

    case GROUP_SMALL_TRASH:
        tempAdd.insertLast( "weed06.frm" );
        tempAdd.insertLast( "weed07.frm" );
        tempAdd.insertLast( "weed08.frm" );
        tempAdd.insertLast( "weed09.frm" );
        tempAdd.insertLast( "weed15.frm" );
        tempAdd.insertLast( "weed16.frm" );
        tempAdd.insertLast( "weed17.frm" );
        tempAdd.insertLast( "trash1.frm" );
        tempAdd.insertLast( "trash2.frm" );
        tempAdd.insertLast( "trash3.frm" );
        break;

    case GROUP_ANIMAL_CORPSE:
        tempAdd.insertLast( "bone05.frm" );
        tempAdd.insertLast( "bone04.frm" );
        tempAdd.insertLast( "bone02.frm" );
        break;

    case GROUP_ROCK:
        tempAdd.insertLast( "rock01.frm" );
        tempAdd.insertLast( "rock02.frm" );
        tempAdd.insertLast( "rock04.frm" );
        tempAdd.insertLast( "rock05.frm" );
        tempAdd.insertLast( "rock09.frm" );
        tempAdd.insertLast( "rock10.frm" );
        tempAdd.insertLast( "rubble1.frm" );
        tempAdd.insertLast( "drock1.frm" );
        tempAdd.insertLast( "drock2.frm" );
        tempAdd.insertLast( "drock3.frm" );
        tempAdd.insertLast( "drock4.frm" );
        tempAdd.insertLast( "drock8.frm" );
        break;

    case GROUP_ROAD:
        tempAdd.insertLast( "weed17.frm" );
        break;

    case GROUP_PPL_ON_ROAD:
        tempAdd.insertLast( "weed17.frm" );
        break;

    case GROUP_JUNKYARD :
        tempAdd.insertLast( "weed17.frm" );
        break;

    default:
        tempAdd.insertLast( "bone04.frm" );
        break;
    }

    uint rnd = Random( 0, tempAdd.length() - 1 );
    ///Log("LENGHTHTH!"+tempAdd.length());
    temp += tempAdd[rnd];

    // Log("hash "+temp);
    return GetStrHash( temp );
}


RespawnedItemGroup@ GetItemGroup( uint16 groupType )
{
    RespawnedItemGroup@ temp;
    switch( groupType )
    {
    /*	case GROUP_TRASH : @temp = GroupTrash(); break;
            case GROUP_TRATA : @temp = GroupTrash(); break;
            case GROUP_BOXES : @temp = GroupBoxes(); break;
            case GROUP_BONES : @temp = GroupBones(); break;
            case GROUP_ROCKS : @temp = GroupRocks(); break;*/                                                                                                                                                                                                                                            // old
    case GROUP_EVILMINDS:
        @temp = GroupEvilMinds();
        break;

    case GROUP_CORPSE:
        @temp = GroupCorpse();
        break;
    case GROUP_PLANT:
        @temp = GroupPlant();
        break;
    case GROUP_BOTTLE_BOX:
        @temp = GroupBottleBox();
        break;
    case GROUP_NEWSP_MACHINE:
        @temp = GroupNewspMachine();
        break;
    case GROUP_METAL_TRASH:
        @temp = GroupMetalTrash();
        break;
    case GROUP_BOX:
        @temp = GroupBox();
        break;
    case GROUP_SLEEPER:
        @temp = GroupSleeper();
        break;
    case GROUP_TRASH:
        @temp = GroupTrash();
        break;
    case GROUP_SMALL_TRASH:
        @temp = GroupSmallTrash();
        break;
    case GROUP_ANIMAL_CORPSE:
        @temp = GroupAnimalCorpse();
        break;
    case GROUP_ROCK:
        @temp = GroupRock();
        break;
    case GROUP_ROAD:
        @temp = GroupRoad();
        break;
    case GROUP_PPL_ON_ROAD:
        @temp = GroupPeopleontheroad();
        break;
    case GROUP_JUNKYARD:
        @temp = GroupJunkyard();
        break;
    default:
        @temp = null;
        break;
    }

    if( temp is null )
        Log( "NULL!!!" );

    return @temp;
}

bool tileInited = false;

uint[][] tileGroups( TILE_GROUP_COUNT );

void InitTiles()
{
//	tileGroups.resize(TILE_GROUP_COUNT);

    uint[] @ data = tileGroups[ TILE_GROUP_ROAD ];
    data.resize( 0 );
    /*
       for(uint8 i = 1; i <= 9; ++i){
            string temp = TILE_PATH+"road0"+i+TILE_FRM;
            data.insertLast(GetStrHash(temp));
       }

       for(uint8 i = 10; i <= 43; ++i){
            string temp = TILE_PATH+"road"+i+TILE_FRM;
            data.insertLast(GetStrHash(temp));
       }
     */


    for( uint8 i = 1; i <= 9; ++i )
    {
        string temp = TILE_PATH + "road0" + i + TILE_FRM;
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 10; i <= 43; ++i )             // i=10?
    {
        string temp = TILE_PATH + "road" + i + TILE_FRM;
        data.insertLast( GetStrHash( temp ) );
    }

    @data = tileGroups[ TILE_GROUP_SIDEWALK ];           // тротуар
    data.resize( 0 );

    for( uint8 i = 1; i <= 9; ++i )
    {
        string temp = TILE_PATH + "curb0" + i + TILE_FRM;
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 1; i <= 5; ++i )
    {
        string temp = TILE_PATH + "road0" + i + TILE_FRM;
        data.insertLast( GetStrHash( temp ) );
    }

    @data = tileGroups[ TILE_GROUP_SAND ];
    data.resize( 0 );

    for( uint8 i = 0; i <= 3; ++i )
    {
        string temp = TILE_PATH + "edg100" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 3; ++i )
    {
        string temp = TILE_PATH + "edg200" + i + TILE_FRM;              // edg2**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 1; ++i )
    {
        string temp = TILE_PATH + "edg300" + i + TILE_FRM;              // edg3**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 8; ++i )
    {
        string temp = TILE_PATH + "edg400" + i + TILE_FRM;              // edg4**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 8; ++i )
    {
        string temp = TILE_PATH + "edg500" + i + TILE_FRM;              // edg5**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 9; ++i )
    {
        string temp = TILE_PATH + "edg600" + i + TILE_FRM;              // edg6**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 1; ++i )
    {
        string temp = TILE_PATH + "edg601" + i + TILE_FRM;              // edg6** continue
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 3; ++i )
    {
        string temp = TILE_PATH + "edg700" + i + TILE_FRM;              // edg7**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 4; ++i )
    {
        string temp = TILE_PATH + "eds00" + i + TILE_FRM;                       // eds
        data.insertLast( GetStrHash( temp ) );
    }

    @data = tileGroups[ TILE_GROUP_GROUND ];
    data.resize( 0 );

    // for(uint8 i = 8; i <= 11; ++i){
    //	string temp = TILE_PATH+"cav400"+i+TILE_FRM;		//eds
    data.insertLast( GetStrHash( TILE_PATH + "cav4008" + TILE_FRM ) );
    data.insertLast( GetStrHash( TILE_PATH + "cav4009" + TILE_FRM ) );
    data.insertLast( GetStrHash( TILE_PATH + "cav4010" + TILE_FRM ) );
    data.insertLast( GetStrHash( TILE_PATH + "cav4011" + TILE_FRM ) );
    // }

    @data = tileGroups[ TILE_GROUP_GRID ];
    data.resize( 0 );

    for( uint8 i = 1; i <= 6; ++i )
    {
        for( uint8 j = 1; j <= 7; ++j )
        {
            string temp = TILE_PATH + "bld_floor_" + i + "_" + j + TILE_PNG;                    // eds
            data.insertLast( GetStrHash( temp ) );
        }
    }

    for( uint8 i = 1; i <= 5; ++i )
    {
        string temp = TILE_PATH + "bld_floor_7_" + i + TILE_PNG;
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 3; i <= 5; ++i )
    {
        string temp = TILE_PATH + "bld_floor_8_" + i + TILE_PNG;
        data.insertLast( GetStrHash( temp ) );
    }

    @data = tileGroups[ TILE_GROUP_CAVE ];
    data.resize( 0 );

    for( uint8 i = 0; i <= 9; ++i )
    {
        string temp = TILE_PATH + "cav100" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 3; ++i )
    {
        string temp = TILE_PATH + "cav200" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 5; ++i )
    {
        string temp = TILE_PATH + "cav300" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 0; i <= 7; ++i )
    {
        string temp = TILE_PATH + "cav400" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    @data = tileGroups[ TILE_GROUP_BRICK ];
    data.resize( 0 );

    for( uint8 i = 1; i <= 9; ++i )
    {
        string temp = TILE_PATH + "brick0" + i + TILE_FRM;              // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    for( uint8 i = 10; i <= 13; ++i )
    {
        string temp = TILE_PATH + "brick" + i + TILE_FRM;               // edg1**
        data.insertLast( GetStrHash( temp ) );
    }

    tileInited = true;
    /*
       @ data = tileGroups[TILE_GROUP_ROAD];

       for(uint8 i = 1; i < data.length(); ++i){
            Log("init "+data[i]);
       }*/
}

/*

void ModuleInit( string&in, Handle@ )
{
    EventRoot.SetCallback( "Start", start );
}
   class InitTileGroups : iManagerModule
   {
        InitTileGroups(){
        }

        bool manager_init()
		{
			return true;
		}
		
		bool manager_start(){
                InitTiles();
                return true;
        }

        void InitTiles(){
   //	tileGroups.resize(TILE_GROUP_COUNT);

                uint[]@ data = tileGroups[TILE_GROUP_ROAD];

                for(uint8 i = 1; i <= 43; ++i){
                        data.insertLast(GetStrHash("road"+i));
                }

                @ data = tileGroups[TILE_GROUP_ROAD];

                for(uint8 i = 1; i <= data.length(); ++i){
                        Log("init "+data[i]);
                }
        }
   }

   InitTileGroups TileGroups;*/

bool IsTileAvalible( uint hash, uint8 group )
{
    uint[] @data = tileGroups[ group ];
    // Log("tileGroups "+group+" len "+data.length());
    for( uint16 i = 0, j = data.length(); i < j; ++i )
    {

        if( data[ i ] == hash )
        {
            //Log( "hash " + data[ i ] + ":" + hash );
            return true;
        }
    }

    return false;
}

bool IsTileGround( uint hash )
{
    return IsTileAvalible( hash, TILE_GROUP_GROUND );
}

bool SpawnLoMapPid( Map@ map )
{
    if(@map is null) {Log("cimp null map");return false;}

    uint mapPid = map.GetProtoId();
    RespawnedItemGroup@ group = null;

    for(uint8 i = 0; i < GROUP_LENGTH; ++i){
        @group =  GetItemGroup( i );

        if(group.MapProtos.find( mapPid ) == -1){
                Log("no map type"+i);
            continue;
        }

        int rechLvl = MAX_RECH_LEVEL;

        for( uint16 ii = 0; ii < MAX_LO_COUNT; ++ii )
        {
            uint8 temp = Random( 1, 99 );
            rechLvl -= temp;
            if( rechLvl > 0 )
            {
                CLO @ clo = CLO( i, temp, false );

                if( clo is null )
                {
                    Log( "clo null" );
                    continue;
                }

                clo.Add( map );

                Log("clo add "+clo.HexX+":"+clo.HexY);
            }else{break;}

        }

    }
    return true;
}

////////////////////DEBUG//////////////////////

//CIMP( uint hash, Item & item, bool destroible )
//CIMP( uint hash, Map& map )

void tc(Critter& cr, int, int, int){
    //Item @ item = cr.GetMap().AddItem(PID_LO_CONTAINER, 1, cr.HexX-1, cr.HexY-1);
    CLO @ clo = CLO(GROUP_ROAD, 10000, true);
    clo.Spawn(cr.GetMap());
}

void spawnlomap(Critter& cr, int id, int, int){
    Map @ map = cr.GetMap();
    if(id > 0){
        @map = GetMap(id);
    }

    if(map is null){cr.Say(SAY_NETMSG, "no map");return;}

    bool r = SpawnLoMapPid( map );

    cr.Say(SAY_NETMSG, ""+(r ? "" : "не")+"успех");
}
