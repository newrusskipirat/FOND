                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                       

import void Log_Lockpick(Critter&player,int lock,int force,int succes,string@param3,int[]@param4)from"gm";
import bool IsDoorAutomatic(Item&door,bool&isPower)from"interactive_obj";
import bool IsDoorAutomatic(uint pid)from"interactive_obj";

bool UseItemOnLocker(Critter&cr,Item&locker,Item&item)
{
	if(item.GetType()==(7))
	{
		if(item.LockerId==locker.LockerId)
		{
			if(!(((locker.LockerCondition)&((0x01)))!=0))
			{
				if((((locker.LockerCondition)&((0x02)))!=0))
				{
					(locker.LockerCondition=((locker.LockerCondition)&(~((0x02)))));
					cr.Say((11),"Вы отперли дверь.");
				}
				else
				{
					(locker.LockerCondition=(locker.LockerCondition)|((0x02)));
					cr.Say((11),"Вы заперли дверь.");
				}
				return true;
			}
			cr.Say((11),"Дверь должна быть закрыта.");
			return true;
		}
		else
		{
			cr.Say((11),"Ключ не подходит.");
			return true;
		}
	}
	
	return true;
}

import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";

bool UseSkillOnLocker(Critter&cr,Item&locker,int skill)
{
	Map@map=cr.GetMap();
	if(not(@map!=null))
	{
		cr.SayMsg((11),(3),(10202));
		return true;
	}
	
	if(cr.StatBase[(67)]>=(5)&&cr.StatBase[(67)]!=(10))
	{
		if(cr.IsNpc())
		{
			cr.DropPlanes();
			cr.ErasePlane((1),true);
			uint16 NpcX=cr.HexX;
			uint16 NpcY=cr.HexY;
			uint8 revDir=cr.Dir+3;
			if(revDir>5)revDir=revDir-6;
			
			map.MoveHexByDir(NpcX,NpcY,revDir,Random(5,10));
			AddWalkPlane(cr,0,cr.HexX,cr.HexY,revDir,false,0);
		}
		else
		cr.Say((11),"Это Вам не под силу.");
		return true;
	}
	
	if(skill==(-1))
	{
		if((((locker.LockerCondition)&((0x20)))!=0)&&!(((locker.LockerCondition)&((0x01)))!=0)
		&&(locker.GetType()==(9)||locker.GetType()==(8)))
		{
			cr.RunClientScript("client_screen_codedoor@ShowScreen",locker.Id,locker.Val1,0,"Введите код",null);
			return true;
		}
		if(locker.GetType()==(9))
		{
			
			if((((locker.LockerCondition)&((0x10)))!=0))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if((((locker.LockerCondition)&((0x01)))!=0)&&(@map.GetCritter(locker.HexX,locker.HexY)!=null))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
			!(((locker.LockerCondition)&((0x08)))!=0)&&(((locker.LockerCondition)&((0x02)))!=0))
			{
				cr.SayMsg((11),(3),(10100));
				return true;
			}
			
			bool power=false;
			if(IsDoorAutomatic(locker,power)&&!power)
			{
				cr.Say((11),"Энергоснабжение отключено. Дверь заблокированна.");
				return true;
			} 
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			locker.LockerClose();
			else
			locker.LockerOpen();
		}
		else if(locker.GetType()==(8))
		{
			if((((locker.Flags)&((0x08000000)))!=0))
			{
				
				int freeWeight=cr.Stat[(11)]-cr.ItemsWeight(),
				contWeight=0;
				Item@[]items;
				for(uint i=0,iEnd=locker.GetItems(uint(-1),items);i<iEnd;i++)
				{
					if(@items[i]is null)
					continue;
					
					contWeight+=int(items[i].Proto.Weight*items[i].GetCount());
				}
				
				if(freeWeight>=(contWeight+int(locker.Proto.Weight)))
				{
					MoveItem(locker,0,cr);
					
					return true;
				}
				
			}
			
			if((((locker.LockerCondition)&((0x10)))!=0))
			{
				cr.SayMsg((11),(3),(10202));
				return true;
			} 
			
			if(!(((locker.LockerCondition)&((0x01)))!=0)&&locker.LockerId!=0&&
			!(((locker.LockerCondition)&((0x08)))!=0)&&!IsKeyAviable(cr,locker.LockerId))
			{
				cr.SayMsg((11),(3),(10100));
				return true;
			} 
			
			if(locker.Proto.Container_Changeble)
			{
				
				if((((locker.LockerCondition)&((0x01)))!=0))
				locker.LockerClose();
				else
				{
					locker.LockerOpen();
					cr.StatBase[(130)]=locker.Id;
					cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
				}
			}
			else
			{
				cr.StatBase[(130)]=locker.Id;
				cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
			}
		}
	}
	else if(skill==(210))
	{
		if(locker.GetType()==(8)&&
		((!locker.Proto.Container_Changeble&&(((locker.Flags)&((0x08000000)))!=0)&&locker.Accessory==(2))||
		(((locker.LockerCondition)&((0x01)))!=0)))
		{
			cr.StatBase[(130)]=locker.Id;
			cr.ShowContainer(null,locker,locker.Proto.GroundLevel?(2):(1));
		}
		else
		cr.SayMsg((11),(3),(10202));
	}
	else if(skill==(209))
	{ 
		
		if((((locker.LockerCondition)&((0x10)))!=0))
		{
			cr.SayMsg((11),(3),(10202));
			return true;
		}
		
		if(cr.Timeout[(234)]>0)
		{
			cr.SayMsg((11),(3),(3401));
			return true;
		}
		
		int base=cr.Skill[(209)]-locker.LockerComplexity;
		Item@lockpick=cr.GetItem(0,(1));
		if(locker.Val0==4&&(@lockpick!=null)&&lockpick.GetProtoId()!=(77))
		{
			cr.Say((11),"Нужна электроная отмычка.");
			return false;
		}  
		
		if(cr.GetAccess()!=(3))
		base=(((base)>(95))?(95):(((base)<(0))?(0):(base)));
		
		if(locker.LockerComplexity==300&&cr.GetAccess()!=(3))
		cr.SayMsg((11),(3),(3440));
		else if(locker.LockerCondition==(0x20))
		{
			uint16 complex=locker.LockerComplexity;
			uint16 exp=complex*2;
			
			string tempCode=locker.Val4;
			uint8 codeLength=tempCode.length();
			uint16 skillLock=cr.Skill[(209)];
			uint8 count=complex/codeLength;
			
			bool changeCode=true;
			
			for(uint8 i=0;i<codeLength;i++)
			{ 
				
				skillLock=(skillLock>=count?(skillLock-count):0);
				if(complex>=skillLock)
				{
					tempCode[i]=42;
					exp=(exp>=count*4?exp-(count*4):0);
					
					changeCode=false;
				}
			}
			
			cr.Say((11),"Код двери : "+tempCode);
			
			if(changeCode&&int(complex*0.5)<=cr.Skill[(212)])
			{
				exp+=complex;
				cr.RunClientScript("client_screen_codedoor@ShowScreen",locker.Id,locker.Val1,1,"Введите новый код.\nДлинна "+(locker.Val1-1),null);
			}  
			
		}
		else
		{
			cr.StatBase[(90)]=locker.Id;
			cr.ShowScreen((2),3,"answer_LOCKPICK");
			cr.Say((18),"Выберите действие");
			cr.Say((19+(0)),"постучать");
			cr.Say((19+(1)),"выбить");
			cr.Say((19+(2)),"начать взлом");
			return true;
		}
		
		cr.TimeoutBase[(234)]=(__FullSecond+((30)*__TimeMultiplier));
		cr.EraseTimeEvents((14));
		cr.AddTimeEvent("cte_Focused",((30)*__TimeMultiplier),(14),0);
	}
	else if(skill==(-4))
	{
		return false;
	}
	else
	{
		cr.SayMsg((11),(3),(10202));
	}
	return true;
}

void answer_LOCKPICK(Critter&player,uint answerI,string&answerS)
{
	Item@lock=GetItem(player.Stat[(90)]);
	if(lock is null)
	return;
	Item@lockpick=player.GetItem(0,(1));
	
	if(answerI==0)
	{
		Map@map=player.GetMap();
		map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"тук-тук");
		player.Say((11),"Вы постучали в дверь.");
	}
	if(answerI==1)
	{
		Map@map=player.GetMap();
		map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0xC8)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),"УДАР");
		
		if(!(((lock.LockerCondition)&((0x01)))!=0)&&lock.Val0==0&&!IsDoorAutomatic(lock.GetProtoId())){
			if(Random(lock.LockerComplexity+50,350)<player.Stat[(0)]*player.Skill[(203)]/10){
				lock.LockerOpen();
			}else{
				player.Say((11),"Вы сильно врезали по замку, но без какого либо эфекта.");
			}
		}else{
			player.Say((11),"Здесь это не поможет.");
		}       
		
		Log_Lockpick(player,player.Stat[(90)],1,0,null,null);
		
		return;
	}
	if(answerI==2)
	{
		if((((lock.LockerCondition)&((0x01)))!=0))
		{
			player.Say((11),"Дверь и так открыта.");
			return;
		}
		if(lock.Val0==0)
		{
			player.Say((11),"Нет замка.");
			return;
		}
		if(lock.Val0==1)
		{
			lock.Val5=Random(10,99);
			lock.Val4=10;
		}
		if(lock.Val0==2)
		{
			if(!(@lockpick!=null)||(lockpick.GetProtoId()!=(410)&&lockpick.GetProtoId()!=(84)))
			{
				player.Say((11),"Нужны отмычки.");
				return;
			}
			lock.Val5=Random(100,999);
			lock.Val4=100;
		}
		if(lock.Val0==3)
		{
			if(!(@lockpick!=null)||lockpick.GetProtoId()!=(410))
			{
				player.Say((11),"Нужен большой набор отмычек.");
				return;
			}
			lock.Val5=Random(1000,9999);
			lock.Val4=1000;
		}
		if((@lockpick!=null)&&lockpick.Val0!=0&&(lockpick.GetProtoId()==(410)||lockpick.GetProtoId()==(84)))
		{
			lockpick.Val0=0;
			do{if(lockpick.GetCount()>(1))
				lockpick.SetCount(lockpick.GetCount()-(1));else
				DeleteItem(lockpick);}while(false);
			player.Say((11),"Отмычка сломалась, видимо ее неудачно вытащили ее из замка в прошлый раз.");
			return;
		}
		else if((@lockpick!=null)&&Random(0,1)==0)
		lockpick.Val0=10;
		player.StatBase[(91)]=1;
		player.StatBase[(92)]=0;
		
		player.ShowScreen((2),7,"answer_LOCKPICK_lock");
		player.Say((18),"Состояние замка неизвестно");
		player.Say((19+(0)),"Осмотреть замок");
		player.Say((19+(1)),"Щуп дальше");
		player.Say((19+(2)),"Щуп назад");
		player.Say((19+(3)),"Щуп вверх");
		player.Say((19+(4)),"Щуп вниз");
		player.Say((19+(5)),"Повернуть");
		player.Say((19+(6)),"Вынуть отмычку");
		Log_Lockpick(player,player.Stat[(90)],0,0,null,null);
		player.TimeoutBase[(234)]=(__FullSecond+((30)*__TimeMultiplier));
		player.EraseTimeEvents((14));
		player.AddTimeEvent("cte_Focused",((30)*__TimeMultiplier),(14),0);
	}
}

void answer_LOCKPICK_lock(Critter&player,uint answerI,string&answerS)
{
	Item@lock=GetItem(player.Stat[(90)]);
	if(lock is null)
	return;
	Map@map=player.GetMap();
	int base=player.Skill[(209)]-lock.LockerComplexity;
	int minChance=5;
	if(player.Skill[(209)]>100)
	minChance=((((player.Skill[(209)]-100)/2)>(95))?(95):((((player.Skill[(209)]-100)/2)<(5))?(5):((player.Skill[(209)]-100)/2)));
	base=(((base)>(95))?(95):(((base)<(minChance))?(minChance):(base)));
	Item@lockpick=player.GetItem(0,(1));
	
	string state="";
	string comb=lock.Val4;
	int curPos=0,curComb=0;
	
	if(answerI==0)
	{
		if(lock.Val0<2)
		state="Замок так себе, ";
		if(lock.Val0==2)
		state="Замок в хорошем состоянии, ";
		if(lock.Val0==3)
		state="Очень хороший замок, ";
	}
	if(answerI==1)
	{
		if(player.Timeout[(234)]>0)
		state="Щуп застрял, нужно чуть ослабить зажим и попробовать еще раз, ";
		else if(player.StatBase[(91)]<lock.Val0+1)
		{
			player.StatBase[(91)]++;
			state="Вы продвинули щуп дальше, ";
			if(Random(0,2)==0)
			player.TimeoutBase[(234)]=__FullSecond+((2)*__TimeMultiplier);
			player.EraseTimeEvents((14));
			player.AddTimeEvent("cte_Focused",((2)*__TimeMultiplier),(14),0);
		}
		else
		state="Щуп уперся и дальше в замок не продвигается, ";
	}
	if(answerI==2)
	{
		if(player.Timeout[(234)]>0)
		state="Щуп застрял, нужно чуть ослабить зажим и попробовать еще раз, ";
		else if(player.StatBase[(91)]>1)
		{
			player.StatBase[(91)]--;
			state="Вы отодвинули щуп назад, ";
			if(Random(0,2)==0)
			player.TimeoutBase[(234)]=__FullSecond+((2)*__TimeMultiplier);
			player.EraseTimeEvents((14));
			player.AddTimeEvent("cte_Focused",((2)*__TimeMultiplier),(14),0);
		}
		else
		state="Щуп уже в крайнем положении, остается только вытащить его, ";
	}
	if(answerI==3)
	{
		curPos=(lock.Val4%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
		if(curPos<9)
		{
			curComb=(lock.Val5%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
			lock.Val4+=pow(10,player.StatBase[(91)]-1);
			curPos++;
			state="Вы подвинули щупом язычок замка вверх, ";
			if(player.Timeout[(234)]>0&&Random(0,2)==0)
			{
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы поторопились и неловко дернули щупом, ";
				if(Random(0,1)==0)
				{
					int bar=Random(1,lock.Val0+1);
					curComb=(lock.Val5%pow(10,bar))/pow(10,bar-1);
					lock.Val5+=(Random(0,9)-curComb)*pow(10,bar-1);
				}
			}
			else if(curComb==curPos&&base>Random(0,100))
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if((curComb==(curPos-1)||curComb==(curPos+1))&&base>Random(0,100)&&Random(0,1)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if((curComb==(curPos-2)||curComb==(curPos+2))&&base>Random(0,100)&&Random(0,3)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if(base<Random(0,100)&&Random(0,9)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			player.TimeoutBase[(234)]=__FullSecond+((10-player.Skill[(209)]*0.03)*__TimeMultiplier);
			player.EraseTimeEvents((14));
			player.AddTimeEvent("cte_Focused",((10-player.Skill[(209)]*0.03)*__TimeMultiplier),(14),0);
		}
		else
		state="Щуп уперся, пружина язычка уже максимально зажата, ";
	}
	if(answerI==4)
	{
		curPos=(lock.Val4%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
		if(curPos>1||(curPos>=1&&player.StatBase[(91)]>=(lock.Val0+1)))
		{
			curComb=(lock.Val5%pow(10,player.StatBase[(91)]))/pow(10,player.StatBase[(91)]-1);
			lock.Val4-=pow(10,player.StatBase[(91)]-1);
			curPos--;
			state="Вы подвинули щупом язычок замка вниз, ";
			if(player.Timeout[(234)]>0)
			{
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы поторопились и неловко дернули щупом, ";
				if(Random(0,1)==0)
				{
					int bar=Random(1,lock.Val0+1);
					curComb=(lock.Val5%pow(10,bar))/pow(10,bar-1);
					lock.Val5+=(Random(0,9)-curComb)*pow(10,bar-1);
				}
			}
			else if(curComb==curPos&&base>Random(0,100))
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if((curComb==(curPos-1)||curComb==(curPos+1))&&base>Random(0,100)&&Random(0,1)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if((curComb==(curPos-2)||curComb==(curPos+2))&&base>Random(0,100)&&Random(0,3)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			else if(base<Random(0,100)&&Random(0,9)==0)
			{
				if(player.Skill[(209)]<Random(0,200))
				map.SetText(lock.HexX,lock.HexY,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"click");
				state+="вы услышали щелчок, ";
			}
			player.TimeoutBase[(234)]=__FullSecond+((10-player.Skill[(209)]*0.03)*__TimeMultiplier);
			player.EraseTimeEvents((14));
			player.AddTimeEvent("cte_Focused",((10-player.Skill[(209)]*0.03)*__TimeMultiplier),(14),0);
		}
		else
		state="Щуп уперся, пружина язычка уже максимально отжата, ";
	}
	if(answerI==5)
	{       
		
		if(lock.Val4==lock.Val5)
		{
			lock.LockerOpen();
			if(lock.GetType()==(8))
			{
				player.ShowContainer(null,lock,lock.Proto.GroundLevel?(2):(1));
			}
			else
			player.Say((11),"Вы успешно вскрыли замок. Осторожно, дверь может захлонуться.");
			lock.Update();
			player.AddScore((18),1);
			if((@lockpick!=null))
			lockpick.Val0=0;
			Log_Lockpick(player,player.Stat[(90)],0,1,null,null);
			return;
		}
		else if(player.StatBase[(92)]<Random(0,player.Skill[(209)]*0.05))
		{
			state="Замок не поворачивается, ";
			player.StatBase[(92)]++;
		}
		else
		{
			player.SayMsg((11),(3),(3440));
			if((@lockpick!=null)&&Random(0,1)==0)
			lockpick.Val0=0;
			return;
		}
	}
	if(answerI==6)
	{
		if(player.StatBase[(91)]>1)
		state="Сначала выдвините щуп в первую позицию, ";
		else
		{
			lockpick.Val0=0;
			player.Say((11),"Вы аккуратно вытащили отмычку из замка.");
			player.EraseTimeEvents((14));
			return;
		}
	}
	
	player.Say((6),"возится с замком");
	state+="позиция щупа - "+player.StatBase[(91)];
	player.ShowScreen((2),7,"answer_LOCKPICK_lock");
	player.Say((18),state);
	player.Say((19+(0)),"Осмотреть замок");
	player.Say((19+(1)),"Щуп дальше");
	player.Say((19+(2)),"Щуп назад");
	player.Say((19+(3)),"Щуп вверх");
	player.Say((19+(4)),"Щуп вниз");
	player.Say((19+(5)),"Повернуть");
	player.Say((19+(6)),"Вынуть отмычку");
}

bool IsKeyAviable(Critter&cr,uint lockerId)
{
	if(lockerId==0)
	return true;
	if((0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return true;
	Item@[]keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return true;
	return false;
}

uint GetKeyId(Critter&cr,uint lockerId)
{
	if(lockerId==0||(0x80000000|(cr.Id))==lockerId||(0x40000000|(cr.Id))==lockerId)
	return 0;
	Item@[]keys;
	for(uint i=0,j=cr.GetItemsByType((7),keys);i<j;i++)
	if(keys[i].LockerId==lockerId)
	return keys[i].Id;
	return 0;
}

void SwitchState(Item&locker)
{ 
	
	if(locker.GetType()==(9)||locker.GetType()==(8))
	{
		
		if(not(((locker.LockerCondition)&((0x10)))!=0))
		{
			
			if((((locker.LockerCondition)&((0x01)))!=0))
			locker.LockerClose();
			else
			locker.LockerOpen();
		}
	}
}

uint cte_Focused(Critter&cr,int identifier,uint&rate)
{
	string[]text={"сфокусировались","готовы продолжать","перехватили отмычки поудобней","заняли более удобную позицию","зафиксировали щуп","можете продолжать"};
	cr.Say((11),"Вы "+text[Random(0,text.length()-1)]+".");
	return 0;
}
