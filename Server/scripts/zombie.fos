/*
        Zombie Invasion Mode

   Суть:
   Спаунятся зомби, идут в сторону игрока, тот по ним стреляет, кровь-кишки.

   ToDo:
   Точка спауна зомби +
   Несколько точек спауна зомби, со всех сторон +
   функция спауна зомби +
   функция посылки зомби на... игрока +
   таймер
   Наращивание мощности зомби
   запуск-прекращение волн
   зона пополнения патронов
   карта +
   Использовать GetCritters для выборки строго зомби по pid, оставив турели вне зоны действия агро-скрипта
   Включить турели, защищающие игрока
   Поужасаться турелям, убивающим игрока в спину :)

   Карта:
   Путём просмотра карты калифорнии, был выбран Форт Джонс (Fort Jones), как место действия. Где-то между реддингом и кламатом, примерно.
   Зона в любом случае полностью разрушена и название нужно лишь в технических целях.
   Как игровая зона, была взята карта аванпоста 22, за авторством Denergar'а. Чуть подправленная. Проставлено несколько блокираторов, добавлены ящики с оружием-бронёй-патронами, на терминал перед входом повешена важная функция запуска данного скрипта.


 */

#include "_macros.fos"
#include "entire.fos"
#include "pids_groups.fos"
#include "_npc_pids.fos"
#include "_teams.fos"
#include "_bags.fos"

#define WAVE    ( 0 )

import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";

// Основная функция, вызываемая при использовании терминала. Модернизировать в дальнейшем (ну или циклов добавить и т.п; т.е. автоматизировать функцию внутри себя и передать ей всё управление над событиями. Если возможно :)
bool s_StartSpawn( Critter& player, Scenery& terminal, int skill, Item@ item )
{

    // Log("Вызов функции стартспаун успешно прошел");
    Map@ map = player.GetMap(); // Должно быть более элегантное решение определения карты? Или сразу указывать PID карты для спауна?..
    // SpawnWave(map); // Создание волны зомби
    // SpawnSomeItems(map); // Тестовая функция
    MassSpawn( map );           // Массовый спаун волн
    SendWave( player, map );    // Отправка волны зомби в атаку
    // Log("Wave!");
    return true;
}

// Координаты для карты:
// 150 110 - левый нижний угол (1)
// 125 70 - левая середина (4)
// 110 50 - левый верх (7)
// 70 70 - верх центр (8)
// 50 85 - право верх (9)
// 70 125 - право середина (6)
// 90 150 - право низ (3)
// 125 130 - низ центр (2)

// Наверно, стоит сделать массив с X и Y, а потом делать уже по нему спаун.
void MassSpawn( Map& map )
{
    // ВРЕМЕННАЯ ФУНКЦИЯ!
    /*uint TimeSwitcher=Random(0,1);
       if (TimeSwitcher == 0)	InitDusk(map);
       else InitDawn(map);*/
    InitDusk( map );   // Пока будет так, просто сбрасываем освещение на тёмное. Потом дополню.
    // КОНЕЦ ВРЕМЕННОЙ ФУНКЦИИ!


    uint WaveCount = Random( 3, 8 );  // количество волн
    for( uint i = 0; i <= WaveCount; i++ )
    {
        uint WaveDirection = Random( 1, 8 );
        // Надо бы более криво сделать, но нет.
        // Теоретически должен быть массив с координатами, из него делается уже выбор значения точки спауна
        switch( WaveDirection )
        {
        case 1:
            SpawnWave( map, 150, 110 );
            break;
        case 2:
            SpawnWave( map, 125, 70 );
            break;
        case 3:
            SpawnWave( map, 110, 50 );
            break;
        case 4:
            SpawnWave( map, 70, 70 );
            break;
        case 5:
            SpawnWave( map, 50, 85 );
            break;
        case 6:
            SpawnWave( map, 70, 125 );
            break;
        case 7:
            SpawnWave( map, 90, 150 );
            break;
        case 8:
            SpawnWave( map, 125, 130 );
            break;
        default:
            break;
        }
    }
}

void SpawnWave( Map& map, uint x, uint y )
{
    uint z = Random( 3, 6 );                                                                              // Количество зомби в волне
    // Log("Внутри функции спаунвейв");
    for( uint i = 0; i < ( z + WAVE ); i++ )                                                              // К количеству зомби прибавляется номер волны
    {
        // uint x=130,y=130; // нижний край карты по центру. Дополнить выбором через switch.
        if( map.IsHexPassed( x + i, y ) )                                                                 // проверяем можно ли заспауниться в данной клетке
        {
            Critter@ cr = map.AddNpc( NPC_PID_GenericGhoul, x + i, y, Random( 0, 5 ), null, null, null ); // DIALOG_mob_mutant
            if( valid( cr ) )
            {
                cr.StatBase[ ST_AI_ID ] = 23;                                                             // Было 26 (гекко), стало 23 (камикадзе?)
                cr.StatBase[ ST_BAG_ID ] = BAG_Empty;
                cr.StatBase[ ST_TEAM_ID ] = TEAM_Mob0;
                cr.StatBase[ ST_REPLICATION_TIME ] = -1;
                // AddAttackPlane(cr,0,player);
            }
        }
    }
}

// Код нагло взят с скрипта базы-собора. Отправляет нпц на карте в атаку на игроков.
// ДОПОЛНИТЬ: Проверять криттеров по PID, не затрагивая турели. Сделать турели дружелюбными и полезными.
// ДОПОЛНИТЬ: Вероято даже лучше по роли нпц проверять, хотя хз как это работает
// Никогда не встречал ii, выглядит странно
void SendWave( Critter& player, Map& map )
{
    // Log("Внутри функции сендкриттерс");
    Critter@[] npcs, players;
    if( map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players ) > 0 && map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
        for( uint i = 0, ii = npcs.length(); i < ii; i++ )
        {
            Critter@ npc = npcs[ i ];
            // for(uint j=0,jj=players.length();j<jj;j++) AddAttackPlane(npc,0,players[j]); //Оригинал
            for( uint j = 0, jj = players.length(); j < jj; j++ )
            {
                AddAttackPlane( npc, 0, players[ j ] );                           // Посылаем зомби в атаку
                npc.AddEnemyInStack( players[ j ].Id );                           // Добавляем игрока в память зомби
            }
        }
    }
}


/*
        Денежная механика
   Общая идея - за убийство зомби даётся 25 монет. За деньги можно покупать разные штуки с терминала.
   1) НПЦ-наёмники, занимающие позиции обороны и отстреливающие зомби.
   2) Авто-минирование проходов, по направлениям.
   3) Патроны для турелей, починка турелей?

 */

// ВсехНагнуть(критер, карта)
// { пока (все не нагнуты) {нагибать;} }
// Тут будет функция, в общем.

/*
        Графические навороты.
   Общая идея - перед запуском волны наступает ночь, в течении 10 секунд.
   После завершения волны - день, время для перерыва, закупки вещей и прочего.
   Всё это делается двумя функциями, оперирующими временем на карте.
   В теории всё просто и безумно красиво. На практике - поглядим.
 */

void InitDusk( Map& map )
{
    map.SetTime( 0 );
    map.SetRain( 100 );
}

void InitDawn( Map& map )
{
    map.SetTime( 600 );
}

// Тестовая функция спауна итемов и работы с их цветом.
void SpawnSomeItems( Map& map )
{
    for( uint i = 0; i < 10; i++ )
    {
        Item@ test = map.AddItem( ( 80 - i ), 125, 23, 1 );
        if( valid( test ) )
        {
            test.LightColor = 16711703;
            test.LightIntensity = 20 + ( i * 2 );
            test.LightRadius = 15 + i;
        }
    }
    // map.Reload();//Fail... с карты выкидывает и идёт перезагрузка, итемы удаляются :(
}
