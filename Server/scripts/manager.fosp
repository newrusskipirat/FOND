                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                                                                                     

shared interface iManagerModule{bool manager_init();
	bool manager_start();}
shared interface iManager_loop{uint global_loop();}
shared interface iManager_critter_init{bool global_critter_init(Critter&critter,bool firstTime);}
shared interface iManager_critter_finish{bool global_critter_finish(Critter&critter,bool toDelete);}
shared interface iManager_critter_idle{bool global_critter_idle(Critter&critter);}
shared interface iManager_critter_dead{bool global_critter_dead(Critter&critter,Critter@killer);}
shared interface iManager_critter_respawn{bool global_critter_respawn(Critter&critter);}
shared interface iManager_map_critter_in{bool global_map_critter_in(Map&map,Critter&critter);}
shared interface iManager_map_critter_out{bool global_map_critter_out(Map&map,Critter&critter);}
shared interface iManager_world_save{bool global_world_save();}
shared interface iManager_player_registration{bool global_player_registration(uint ip,string&name,uint&textMsg,uint&strNum);}
shared interface iManager_player_login{bool global_player_login(uint ip,string&name,uint id,uint&textMsg,uint&strNum);}
shared interface iManager_time{bool global_time(int8 type);}

shared interface iManager_critter_use_skill{bool global_critter_use_skill(Critter&critter,int skill,Critter@targetCritter,Item@targetItem,Scenery@targetScenery);}

shared interface iManagerElement
{
	iManagerModule@GetLink();
	uint GetId();
	string&GetName();
	uint&GetEventFlags();
	int8&GetTimeChangeCall();
	uint8 GetPriority();
}                                         

class ManagerElement:iManagerElement
{
	iManagerModule@Link;
	uint Id;
	string Name;
	uint EventFlags;
	
	uint NextLoopCall;
	
	int8 TimeChangeCall;
	
	uint8 Priority;
	
	ManagerElement(uint id,iManagerModule@link,string&name,uint8 priority)
	{
		Id=id;
		@Link=link;
		Name=name;
		Priority=priority;
		
		EventFlags=0;
		NextLoopCall=0;
		TimeChangeCall=0;
	}
	
	iManagerModule@GetLink(){return Link;}
	uint GetId(){return Id;}
	string&GetName(){return Name;}
	uint&GetEventFlags(){return EventFlags;}
	int8&GetTimeChangeCall(){return TimeChangeCall;}
	uint8 GetPriority(){return Priority;}
}

ManagerElement@[]Modules;

iManager_critter_init@[]CritterInitModules;
iManager_critter_finish@[]CritterFinishModules;
iManager_critter_idle@[]CritterIdleModules;
iManager_critter_dead@[]CritterDeadModules;
iManager_critter_respawn@[]CritterRespawnModules;
iManager_map_critter_in@[]MapCritterInModules;
iManager_map_critter_out@[]MapCritterOutModules;
iManager_critter_use_skill@[]CritterUseSkill; 

iManager_player_registration@[]PlayerRegistrationModules;
iManager_player_login@[]PlayerLoginModules;

iManager_world_save@[]WorldSaveModules;

iManager_loop@[]LoopModules;
iManager_time@[]TimeModules;

void MLE(string&str)
{
	Log("MANAGER ERROR: "+str);
}
void MLE(ManagerElement&module,string&str)
{
	Log("MANAGER ERROR: module "+module.Name+" ("+module.Id+"): "+str);
}
void ML(ManagerElement&module,string&str)
{
	Log("Manager module "+module.Name+" ("+module.Id+"): "+str);
}

uint PrepareManager(ManagerElement&module)
{
	uint ef=0,count=0;
	iManagerModule@li=module.Link;
	
	if(cast<iManager_loop@>(li)!is null){ef|=(0x1);count++;}
	if(cast<iManager_critter_init@>(li)!is null){ef|=(0x2);count++;}
	if(cast<iManager_critter_finish@>(li)!is null){ef|=(0x4);count++;}
	if(cast<iManager_critter_idle@>(li)!is null){ef|=(0x8);count++;}
	if(cast<iManager_critter_dead@>(li)!is null){ef|=(0x10);count++;}
	
	if(cast<iManager_critter_respawn@>(li)!is null){ef|=(0x20);count++;}
	if(cast<iManager_map_critter_in@>(li)!is null){ef|=(0x40);count++;}
	if(cast<iManager_map_critter_out@>(li)!is null){ef|=(0x80);count++;}
	if(cast<iManager_world_save@>(li)!is null){ef|=(0x100);count++;}
	if(cast<iManager_player_registration@>(li)!is null){ef|=(0x200);count++;}
	if(cast<iManager_player_login@>(li)!is null){ef|=(0x400);count++;}
	if(cast<iManager_time@>(li)!is null){ef|=(0x800);count++;}
	
	module.EventFlags=ef;
	
	return count;
}   

uint last_module_id=0;

ManagerElement@GetManagerByLink(iManagerModule@link)
{
	if(@link is null)return null;
	
	for(uint i=0,iEnd=Modules.length();i<iEnd;i++)
	if(@Modules[i]!is null&&@link is@Modules[i].Link)
	return@Modules[i];
	
	return null;
}

iManagerElement@manager_add_module(iManagerModule@link,string&name,uint8 priority)
{
	uint num=Modules.length();
	bool isLast=true;
	if(num<1)
	num=1;
	
	for(uint i=1,j=Modules.length();i<j;i++)
	{
		ManagerElement@module=Modules[i];if(module is null)
		continue;;
		
		if(module.Priority<priority)
		{
			isLast=i==num;
			num=i;
			break;
		}
	}
	if(num>Modules.length())
	Modules.resize(num);
	
	ManagerElement@module=ManagerElement(++last_module_id,link,name,priority);
	
	if(module.Link is null)
	MLE(module,"Null pointer Link!");
	else if(PrepareManager(module)<1)
	MLE(module,"Классу модуля не назначено ни одного callback-интерфейса.");
	else
	{
		Modules.insertAt(num,@module);   
		
		{
			iManager_critter_idle@castLink=cast<iManager_critter_idle@>(link);
			if(@castLink!is null)
			{if(isLast)CritterIdleModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterIdleModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterIdleModules[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterIdleModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterIdleModules.insertLast(castLink);}};
		}
		{
			iManager_critter_dead@castLink=cast<iManager_critter_dead@>(link);
			if(@castLink!is null)
			{if(isLast)CritterDeadModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterDeadModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterDeadModules[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterDeadModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterDeadModules.insertLast(castLink);}};
		}
		{
			iManager_critter_respawn@castLink=cast<iManager_critter_respawn@>(link);
			if(@castLink!is null)
			{if(isLast)CritterRespawnModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterRespawnModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterRespawnModules[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterRespawnModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterRespawnModules.insertLast(castLink);}};
		}
		{
			iManager_map_critter_in@castLink=cast<iManager_map_critter_in@>(link);
			if(@castLink!is null)
			{if(isLast)MapCritterInModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=MapCritterInModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(MapCritterInModules[i]));
						if(@imod!is null){if(imod.Priority<priority){MapCritterInModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)MapCritterInModules.insertLast(castLink);}};
		}
		{
			iManager_map_critter_out@castLink=cast<iManager_map_critter_out@>(link);
			if(@castLink!is null)
			{if(isLast)MapCritterOutModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=MapCritterOutModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(MapCritterOutModules[i]));
						if(@imod!is null){if(imod.Priority<priority){MapCritterOutModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)MapCritterOutModules.insertLast(castLink);}};
		}
		{
			iManager_critter_use_skill@castLink=cast<iManager_critter_use_skill@>(link);
			if(@castLink!is null)
			{if(isLast)CritterUseSkill.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterUseSkill.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterUseSkill[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterUseSkill.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterUseSkill.insertLast(castLink);}};
		}
		{
			iManager_critter_init@castLink=cast<iManager_critter_init@>(link);
			if(@castLink!is null)
			{if(isLast)CritterInitModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterInitModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterInitModules[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterInitModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterInitModules.insertLast(castLink);}};
		}
		{
			iManager_critter_finish@castLink=cast<iManager_critter_finish@>(link);
			if(@castLink!is null)
			{if(isLast)CritterFinishModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=CritterFinishModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(CritterFinishModules[i]));
						if(@imod!is null){if(imod.Priority<priority){CritterFinishModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)CritterFinishModules.insertLast(castLink);}};
		}
		{
			iManager_world_save@castLink=cast<iManager_world_save@>(link);
			if(@castLink!is null)
			{if(isLast)WorldSaveModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=WorldSaveModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(WorldSaveModules[i]));
						if(@imod!is null){if(imod.Priority<priority){WorldSaveModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)WorldSaveModules.insertLast(castLink);}};
		}
		{
			iManager_player_registration@castLink=cast<iManager_player_registration@>(link);
			if(@castLink!is null)
			{if(isLast)PlayerRegistrationModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=PlayerRegistrationModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(PlayerRegistrationModules[i]));
						if(@imod!is null){if(imod.Priority<priority){PlayerRegistrationModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)PlayerRegistrationModules.insertLast(castLink);}};
		}
		{
			iManager_player_login@castLink=cast<iManager_player_login@>(link);
			if(@castLink!is null)
			{if(isLast)PlayerLoginModules.insertLast(castLink);
				else{bool insert=false;
					for(uint i=0,iEnd=PlayerLoginModules.length();i<iEnd;i++)
					{ManagerElement@imod=GetManagerByLink(cast<iManagerModule@>(PlayerLoginModules[i]));
						if(@imod!is null){if(imod.Priority<priority){PlayerLoginModules.insertAt(i,castLink);
								insert=true;break;}}
					}if(!insert)PlayerLoginModules.insertLast(castLink);}};
		}
		
	}      
	
	return module;
}

bool manager_start()
{
	for(uint i=1,j=Modules.length();i<j;i++)
	{
		ManagerElement@module=Modules[i];if(module is null)
		continue;;
		
		if(!module.Link.manager_start())
		MLE(module,"Init fail!");
		else ML(module,"Successfully inited at position "+i);
	}
	return true;
}

bool manager_init()
{
	for(uint i=1,j=Modules.length();i<j;i++)
	{
		ManagerElement@module=Modules[i];if(module is null)
		continue;;
		
		if(!module.Link.manager_init())
		MLE(module,"Init fail!");
	}
	return true;
}

uint skip_loop=0;

uint last_loop_game_minute=0;

class Time
{
	uint16 Second;
	uint16 Minute;
	uint16 Hour;
	uint16 Day;
	uint16 DayOfWeek;
	uint16 Month;
	uint16 Year;
	
	void GetCurrent()
	{
		GetGameTime(__FullSecond,Year,Month,Day,DayOfWeek,Hour,Minute,Second);
	}
	
	int8 GetTimeChangeType()
	{
		int8 time_change=-1;
		
		if(__Minute!=Minute)
		{
			if(__Hour!=Hour)
			{
				if(__Day!=Day)
				{
					if(__Month!=Month)
					{
						if(__Year!=Year)
						{
							time_change=(0x6);
						}
						else
						time_change=(0x5);
					}
					else
					time_change=(0x3);
					
					if(DayOfWeek==6)
					time_change|=(0x10);
				}
				else
				time_change=(0x2);
			}
			else
			time_change=(0x1);
		}
		return time_change;
	}
	
	int8 GetTimeZeroType()
	{
		int8 time_change=0;
		
		if(Second==0)
		{
			if(Minute==0)
			{
				if(Hour==0)
				{
					if(Day==0)
					{
						if(Month==0)
						{
							time_change=(0x6);
						}
						else
						time_change=(0x5);
					}
					else
					time_change=(0x3);
					
					if(DayOfWeek==0)
					time_change|=(0x10);
				}
				else
				time_change=(0x2);
			}
			else
			time_change=(0x1);
		}
		return time_change;
	}
}

Time@last_loop_time=null;

int8 GetTimeChange()
{
	int8 time_change=-1;
	
	if(@last_loop_time!is null)
	{
		time_change=last_loop_time.GetTimeChangeType();
		if(time_change>0)
		last_loop_time.GetCurrent();
	}
	else
	{
		@last_loop_time=Time();
		last_loop_time.GetCurrent();
		
		time_change=last_loop_time.GetTimeZeroType();
	}
	
	return time_change;
}

uint manager_loop()
{
	if(skip_loop!=0)
	{
		uint t=skip_loop;
		skip_loop=0;
		
		if(t>GetTick())
		return t-GetTick();
	}
	
	uint MinimumNext=uint(-1),
	nextTime=0;
	
	int8 time_change=GetTimeChange();
	
	bool time_break=false;
	
	for(uint i=1,j=Modules.length();i<j;i++)
	{
		ManagerElement@module=Modules[i];if((module is null)or(module.Link is null))
		continue;;
		
		if((((module.EventFlags)&((0x1)))!=0)&&module.NextLoopCall<GetTick())
		{
			iManager_loop@p=cast<iManager_loop@>(module.Link);
			nextTime=p.global_loop();
			if(nextTime<MinimumNext)
			MinimumNext=nextTime;
			module.NextLoopCall=GetTick()+nextTime;
		}
		
		if(!time_break&&(((module.EventFlags)&((0x800)))!=0)&&(time_change==0||int8(time_change&0xF)>=module.TimeChangeCall))
		{
			iManager_time@p=cast<iManager_time@>(module.Link);
			if(!p.global_time(time_change))
			time_break=true;
		}
	}
	
	if(MinimumNext>1000)
	{
		skip_loop=GetTick()+MinimumNext;
		return 1000;
	}
	else
	return MinimumNext;
}

void manager_critter_init(Critter&critter,bool firstTime)
{
	if(critter.IsPlayer())
	{
		Map@map=critter.GetMap();
		if(@map is null)Log(critter.Id+" init");
		else Log(critter.Id+" init on map "+map.Id);
	}
	
	for(uint i=0,iEnd=CritterInitModules.length();i<iEnd;i++)
	if(!CritterInitModules[i].global_critter_init(critter,firstTime))
	break;
	
	if(critter.IsPlayer())
	SetOnline(critter,true);
}

void manager_critter_finish(Critter&critter,bool toDelete)
{
	for(uint i=0,iEnd=CritterFinishModules.length();i<iEnd;i++)
	if(!CritterFinishModules[i].global_critter_finish(critter,toDelete))
	break;
	
	if(critter.IsPlayer())
	SetOnline(critter,false);
}

void manager_critter_idle(Critter&critter)
{
	for(uint i=0,iEnd=CritterIdleModules.length();i<iEnd;i++)
	if(!CritterIdleModules[i].global_critter_idle(critter))
	break;
}

void manager_critter_dead(Critter&critter,Critter@killer)
{
	for(uint i=0,iEnd=CritterDeadModules.length();i<iEnd;i++)
	if(!CritterDeadModules[i].global_critter_dead(critter,killer))
	break;
}

void manager_critter_respawn(Critter&critter)
{
	for(uint i=0,iEnd=CritterRespawnModules.length();i<iEnd;i++)
	if(!CritterRespawnModules[i].global_critter_respawn(critter))
	break;
}

void manager_map_critter_in(Map&map,Critter&critter)
{
	if(critter.IsPlayer()&&critter.GetAccess()<(2)){
		critter.TimeoutBase[(239)]=__FullSecond+(15*__TimeMultiplier); 
		
	}
	
	for(uint i=0,iEnd=MapCritterInModules.length();i<iEnd;i++)
	if(!MapCritterInModules[i].global_map_critter_in(map,critter))
	break;
}

uint cte_Unstoppable(Critter&cr,int identifier,uint&rate){
	cr.ParamBase[(527)]=0;
	return 0;
}

void manager_map_critter_out(Map&map,Critter&critter)
{
	for(uint i=0,iEnd=MapCritterOutModules.length();i<iEnd;i++)
	if(!MapCritterOutModules[i].global_map_critter_out(map,critter))
	break;
}

bool manager_critter_use_skill(Critter&critter,int skill,Critter@targetCritter,Item@targetItem,Scenery@targetScenery)
{
	for(uint i=0,iEnd=CritterUseSkill.length();i<iEnd;i++)
	if(!CritterUseSkill[i].global_critter_use_skill(critter,skill,targetCritter,targetItem,targetScenery))
	return true;
	return false;
}

void manager_world_save()
{
	for(uint i=0,iEnd=WorldSaveModules.length();i<iEnd;i++)
	if(!WorldSaveModules[i].global_world_save())
	break;
}

bool manager_player_registration(uint ip,string&name,uint&textMsg,uint&strNum)
{
	for(uint i=0,iEnd=PlayerRegistrationModules.length();i<iEnd;i++)
	if(!PlayerRegistrationModules[i].global_player_registration(ip,name,textMsg,strNum))
	return false;
	return true;
}

bool manager_player_login(uint ip,string&name,uint id,uint&textMsg,uint&strNum)
{
	for(uint i=0,iEnd=PlayerLoginModules.length();i<iEnd;i++)
	if(!PlayerLoginModules[i].global_player_login(ip,name,id,textMsg,strNum))
	return false;
	return true;
}

uint[]OnlinePlayers; 

void SetOnline(Critter&cr,bool online)
{
	bool ck=false;
	for(uint i=0,j=OnlinePlayers.length();i<j;i++)
	{
		if(OnlinePlayers[i]!=cr.Id)
		continue;
		if(online)
		{
			ck=true;
			break;
		}
		OnlinePlayers.removeAt(i);
		i--;
		j--;
	}
	
	if(online&&!ck)
	OnlinePlayers.insertLast(cr.Id);
} 

uint GetAllPlayers(Critter@[]&crs)
{
	uint len=OnlinePlayers.length();
	uint j=crs.length();
	crs.resize(len+j);
	for(uint i=0;i<len;i++)
	{
		Critter@cr=GetCritter(OnlinePlayers[i]);
		if(@cr is null)
		{
			OnlinePlayers.removeAt(i);
			i--;
			len--;
			continue;
		}
		@crs[j++]=cr;
	}
	if(j<crs.length())
	crs.resize(j);
	return j;
} 

uint GetPlayers(Critter&cr,uint16 radius,bool square,Critter@[]&crs)
{
	return GetPlayers(cr.WorldX,cr.WorldY,radius,square,crs);
} 

uint GetPlayers(uint16 worldX,uint16 worldY,uint16 radius,bool square,Critter@[]&crs)
{
	Critter@[]players;
	uint len=GetAllPlayers(players);
	for(uint i=0;i<len;i++)
	{
		int x=players[i].WorldX-worldX,y=players[i].WorldY-worldY;
		if(square&&(abs(x)>radius||abs(y)>radius))
		continue;
		else if(!square&&sqrt(x*x+y*y)>radius)
		continue;
		else
		{
			crs.insertLast(players[i]);
		}
	}
	return crs.length();
}
