                                                                 

shared interface iManagerModule{bool manager_init();
	bool manager_start();}
shared interface iManager_loop{uint global_loop();}
shared interface iManager_critter_init{bool global_critter_init(Critter&critter,bool firstTime);}
shared interface iManager_critter_finish{bool global_critter_finish(Critter&critter,bool toDelete);}
shared interface iManager_critter_idle{bool global_critter_idle(Critter&critter);}
shared interface iManager_critter_dead{bool global_critter_dead(Critter&critter,Critter@killer);}
shared interface iManager_critter_respawn{bool global_critter_respawn(Critter&critter);}
shared interface iManager_map_critter_in{bool global_map_critter_in(Map&map,Critter&critter);}
shared interface iManager_map_critter_out{bool global_map_critter_out(Map&map,Critter&critter);}
shared interface iManager_world_save{bool global_world_save();}
shared interface iManager_player_registration{bool global_player_registration(uint ip,string&name,uint&textMsg,uint&strNum);}
shared interface iManager_player_login{bool global_player_login(uint ip,string&name,uint id,uint&textMsg,uint&strNum);}
shared interface iManager_time{bool global_time(int8 type);}

shared interface iManager_critter_use_skill{bool global_critter_use_skill(Critter&critter,int skill,Critter@targetCritter,Item@targetItem,Scenery@targetScenery);}

shared interface iManagerElement
{
	iManagerModule@GetLink();
	uint GetId();
	string&GetName();
	uint&GetEventFlags();
	int8&GetTimeChangeCall();
	uint8 GetPriority();
}                     

import iManagerElement@manager_add_module(iManagerModule@link,string&name,uint8 priority)from"manager";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

shared interface Project
{
	string@get_Name();
	void Build();
	void SetAssociation(string@ex,string@className,string@classModule);
}

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared class TimeLog
{
	uint tick;
	
	TimeLog()
	{
		refresh();
	}
	
	void refresh()
	{
		tick=GetTick();
	}
	
	bool check(uint count)
	{
		return(GetTick()-tick>=count);
	}
	
	uint get()
	{
		uint old=tick;
		refresh();
		return(tick-old);
	}
	
	void Log(string&in message)
	{
		::ClearLog(message+" ["+(GetTick()-tick)+"ms]");
	}
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world"; 

import EventTree@get_EventRoot()from"world"; 

import Project@CreateProject(string@name,string@path)from"main";
import Project@get_Project(string@name)from"main";                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

uint[]windMillParts={};

uint[]alcoPart={(125),(124)};
uint[]alcoCount={10,10};
uint[]alcoScience={20,20};
uint[]alcoRepair={50,50};

import void DropBleed(Critter&cr)from"critter_status";
import void DropToxic(Critter&cr)from"critter_status";

import void Prolonged_Doc(Critter&targetCr,uint16 doctime,uint16 damage)from"heal";
import void Prolonged_heal(Critter&targetCr,uint16 sk)from"heal";                                               

string[]valDesc={"Генератор","Энергия","Включено","Заряды","Заряды.Макс","PID инструм.","ремонт%","наука%","(Двери)Питание","слж.поломки"};

ObjectsManager objectMng;

void start(string&in,Handle@)
{
	iManagerModule@module=objectMng;
	iManagerElement@manager=manager_add_module(module,"objects",100);
	if(@manager is null)
	return;  
	
}

void ModuleInit(string&in,Handle@)
{
	EventRoot.SetCallback("Start",start);
}

class ObjectsManager:iManagerModule,iManager_loop,iManager_world_save,iManager_time
{
	
	bool manager_init()
	{
		return true;
	}
	
	bool manager_start(){
		
		used_map_obj.Load();
		return true;
	}
	
	bool global_world_save(){
		
		return true;
	}
	
	uint global_loop(){
		return uint(-1);
	}
	
	bool global_time(int8 type){
		if(type==(0x2)){
			used_map_obj.ObjectTimeLoop();
			used_map_obj.Save();
		}
		
		return true;
	}
} 

class CUMO
{
	uint Id;
	uint ItemId;
	uint PID;
	
	int[]Val;
	
	CUMO(){
		Id=0;
		ItemId=0;
		for(uint8 i=0;i<10;++i){
			Val.insertLast(0);
		}
	}
	
	CUMO(Item&item,uint id){
		Id=id;
		ItemId=item.Id;
		PID=item.GetProtoId();    
		
		Val[0]=item.Val0;
		Val[1]=item.Val1;
		Val[2]=item.Val2;
		Val[3]=item.Val3;
		Val[4]=item.Val4;
		Val[5]=item.Val5;
		Val[6]=item.Val6;
		Val[7]=item.Val7;
		Val[8]=item.Val8;
		Val[9]=item.Val9;
	}
	
	CUMO(int[]val,uint id){
		Id=id;
		
		uint len=val.length()-1;
		
		ItemId=uint(val[len-1]);
		PID=uint(val[len]);
		val.resize(len);
		Val=val; 
		
	}
	
	string SGetVal(){
		string sout="";
		for(uint8 i=0;i<10;++i){
			sout+=this.Val[i]+"\n";
		}
		
		return(sout!=""?sout:"ERROR "+this.Id);
	}
}

class CUMOBREAKGROUP
{
	uint8 BreakPosition;
	
	uint[]BreakPids;
	uint[]BreakCounts;
	uint[]BreakScience;
	uint[]BreakRepair;
	
	CUMOBREAKGROUP(uint[]pids,uint[]counts,uint[]science,uint[]repair){
		BreakPids=pids;
		BreakCounts=counts;
		BreakScience=science;
		BreakRepair=repair;
		
		if(BreakPids.length()!=BreakCounts.length()){Log("LENGTH ERROR");}
	}
	
	uint GetLen(){
		return BreakPids.length();
	}
	
	uint GetPid(uint8 index){
		return BreakPids[index];
	}
	
	uint GetCount(uint8 index){
		return BreakCounts[index];
	}
	
	uint GetScience(uint8 index){
		return BreakScience[index];
	}
	
	uint GetRepair(uint8 index){
		return BreakRepair[index];
	}
	
	void GetBreakRandom(uint&pid,uint&count,uint&science,uint&repair){
		uint8 index=(Random(0,BreakPids.length()-1));
		
		pid=BreakPids[index];
		count=BreakCounts[index];
		science=BreakScience[index];
		repair=BreakRepair[index];
	}
}

class CUMOBREAK
{
	
	uint8 BreakChance;
	uint CUMOPid;
	uint BreakPeriod; 
	
	CUMOBREAKGROUP[]BreakGroups;
	
	CUMOBREAK(uint pid,uint8 chance){
		CUMOPid=pid;
		BreakChance=chance;
		
		Init();
	}
	
	void AddBreakGroup(CUMOBREAKGROUP&breakGroup){
		BreakGroups.insertLast(breakGroup);
	}
	
	bool IsThisCUMO(uint pid){
		return pid==CUMOPid;
	}
	
	bool CheckBreak(CUMO&cum){
		if(!IsThisCUMO(cum.PID))return false;
		
		uint8 chance=(Random(0,99));
		
		if(BreakChance>chance){
			uint8 complexity=cum.Val[(9)]++;
			
			uint len=BreakGroups.length();
			
			uint pid=0,count=0,science=0,repair=0;
			
			BreakGroups[Random(0,len-1)].GetBreakRandom(pid,count,science,repair);
			
			count=uint(count*complexity*0.2);
			
			cum.Val[(5)]=((count<<12)|(pid));
			cum.Val[(7)]=science+(science*complexity*0.2);
			cum.Val[(6)]=repair+(repair*complexity*0.2);
			
			return true;
			
		}
		
		return false;
	}
	
	void Init(){}
}

class CUMOBREAK_WINDMILL:CUMOBREAK
{
	
	CUMOBREAK_WINDMILL(){
		CUMOPid=(1306);
		BreakPeriod=48;
		
		Init();
	}
	void Init(){
		AddBreakGroup(CUMOBREAKGROUP(alcoPart,alcoCount,alcoScience,alcoRepair));
	}
}

CUMOBREAK[]cumo_breaks;

void GetState(Critter&cr,int,int,int)
{
	
}

void InitBreak(){
	cumo_breaks.resize(0);
	
	cumo_breaks.insertLast(CUMOBREAK_WINDMILL());
}

class CUMOA
{
	CUMO[]cumos;
	AirLock[]airLocks;
	
	CUMOA(){
		cumos.resize(0);
	}
	
	bool Load()
	{
		if(!IsAnyData(("CUMO")))return false;
		
		int[]cumos_data;
		GetAnyData(("CUMO"),cumos_data);
		
		uint len=cumos_data.length();
		
		if(len%12!=0)return false;
		
		int[]val;
		
		for(uint i=0;i<len;++i){
			
			val.insertLast(cumos_data[i]);
			if(val.length()==12){
				uint cumoslen=cumos.length();  
				
				cumos.insertLast(CUMO(val,cumoslen));  
				
				val.resize(0);
			}
			
		}
		
		InitBreak();
		
		Log("CUMO LOAD : "+cumos.length()+" OBJECTS");
		return true;
		
	}
	
	void Save()
	{
		int[]cumos_data(0); 
		
		for(uint i=0,j=cumos.length();i<j;++i){
			CUMO cumo=cumos[i];
			
			for(uint8 ii=0;ii<10;++ii){
				cumos_data.insertLast(cumo.Val[ii]);
			}
			
			cumos_data.insertLast(int(cumo.ItemId));
			cumos_data.insertLast(int(cumo.PID));
			
			if(cumos_data.length()%12!=0){Log("INVALID LENGTH");return;}
		} 
		
		if(IsAnyData(("CUMO"))){  
			
			EraseAnyData(("CUMO"));
		}
		
		SetAnyData(("CUMO"),cumos_data);
	}
	
	int GetValue(uint index,uint8 val,int&rV)
	{
		if(index<cumos.length()){
			rV=cumos[index].Val[val];
			return 0;
		}
		
		return-1;
	}
	
	int SetValue(uint index,uint8 val,int rV)
	{
		if(index<cumos.length()){
			
			if(val==(3))
			rV=(((rV)>((4)))?((4)):(((rV)<(0))?(0):(rV)));
			
			cumos[index].Val[val]=rV;
			
			if(val==(3)&&cumos[index].Val[(3)]<=0){
				if(cumos[index].PID==(1303)){
					ShutDown(index,0);
				} 
				
			}
			
			return 0;
		}
		
		return-1;
	}
	
	uint GetIndexByItemId(uint itemId)
	{
		for(uint i=0,j=cumos.length();i<j;++i){
			
			if(cumos[i].ItemId==itemId)return i;
		}
		
		return uint(-1);
	}
	
	uint GetGeneratorId(uint8 generatorGroup){
		
		for(uint i=0,j=cumos.length();i<j;++i){
			if(cumos[i].PID==(1303)&&cumos[i].Val[(0)]==generatorGroup)
			return i;
		}
		
		return uint(-1);
	}
	
	void ShutDown(uint index,int val)
	{
		
		uint8 generatorGroup=cumos[index].Val[(0)];
		
		for(uint i=0,j=cumos.length();i<j;++i)
		{
			CUMO@cumo=cumos[i]; 
			
			if(cumo.Val[(0)]!=generatorGroup)continue;
			
			if(cumo.PID==(1303))
			{
				Item@item=GetItem(cumo.ItemId);
				if(@item is null)continue;
				uint16 x=0,y=0;
				Map@map=item.GetMapPosition(x,y);
				if(@map is null)continue;
				
				map.SetData((24),val);
			}
			
			if(IsDoorAutomatic(cumo.PID)){
				
				Item@item=GetItem(cumo.ItemId);
				if(item is null)continue;
				
				item.Val8=val;
				
				cumo.Val[(8)]=val;  
				
			}
			else if(cumo.PID==(1305))
			{
				
				Item@item=GetItem(cumo.ItemId);
				
				if(item is null)continue;
				
				if(val>0){
					item.LightIntensity=100;
				}else{
					item.LightIntensity=0;
				}
				
				cumo.Val[(1)]=val;  
				
				item.Update();
			}else if(val>0){
				cumo.Val[(1)]=val;
			}else{
				cumo.Val[(1)]=val;
				cumo.Val[(2)]=val;
			}
		}
	}
	
	void UseSwitcher(uint index,uint switcher)
	{
		uint pid=cumos[index].PID;
		
		if(pid==(1302)||pid==(1300)){
			cumos[index].Val[(2)]=switcher;
		}else if(pid==(1303)){
			ShutDown(index,switcher);
		}else if(pid==(1308)){
			if(cumos[index].Val[(2)]>0){
				
				Item@item=GetItem(cumos[index].ItemId);
				if(item is null)return;
				
				Item@[]@cont;
				item.GetItems(uint(-1),cont);
				
				if(@cont is null)return;
				
				for(uint i=0,j=cont.length();i<j;++i){
					if(cont[i].GetProtoId()==(286)){
						item.AddItem((1488),uint(cont[i].GetCount()*0.5),0);
					}else{item.AddItem((98),uint(cont[i].GetCount()*Random(0,3)),0);}
				}
			}
		}else if(pid==(1309)){
			if(cumos[index].Val[(2)]>0){
				
				Item@item=GetItem(cumos[index].ItemId);
				if(item is null)return;
				
				Item@[]@cont;
				item.GetItems(uint(-1),cont);
				
				if(@cont is null)return;
				
				for(uint i=0,j=cont.length();i<j;++i){
					if(cont[i].GetProtoId()==(475)){
						item.AddItem((50),uint(cont[i].GetCount()*0.2),0);
					}
				}
			}
		}
		
	}
	
	void Generate(){
		
	}
	
	void ObjectTimeLoop()
	{
		
		airLocks.resize(0);
		
		for(uint i=0,j=cumos.length();i<j;++i)
		{
			CUMO@cumo=cumos[i];                   
			
			if(cumo.PID==(1302)){
				AirLock airLock(GetItem(cumo.ItemId).MapId,(cumo.Val[(2)]>0?true:false));
				airLocks.insertLast(airLock);
			}
			
			if(cumo.PID==(10108)){
				ShitDen(cumo.ItemId);
			}
			
			if(cumo.PID==(1310)){
				cumo.Val[(3)]++;
			}
			
			if(cumo.Val[(2)]>0){
				
				if(cumo.PID==(1300)){
					
					cumo.Val[(3)]++;
					
				}else if(cumo.PID==(1303)){
					
					GameVar@timeLoop=GetLocalVar((10005),cumo.ItemId);
					
					if(timeLoop is null)continue;
					
					int multiplier=(cumo.Val[(4)]>0?cumo.Val[(4)]:1);
					
					if(timeLoop.GetValue()>=24*multiplier){
						timeLoop.opAssign(0);
						cumo.Val[(3)]--;
					}
					
					timeLoop.opAddAssign(1);
					
					if(cumo.Val[(3)]<=0){
						used_map_obj.ShutDown(cumo.Id,0);
						cumo.Val[(2)]=0;
					}
					
				}
			}
		}
		
		uint[]mapId;
		uint[]airLen;
		uint[]airAct; 
		
		for(uint i=0,j=airLocks.length();i<j;++i)
		{  
			
			int index=mapId.find(airLocks[i].MapId);
			
			if(index!=-1)
			{
				airLen[index]++;
				if(airLocks[i].IsActive)airAct[index]++;
			}
			else
			{
				mapId.insertLast(airLocks[i].MapId);
				airLen.insertLast(1);
				airAct.insertLast(airLocks[i].IsActive?1:0);
			}
		}   
		
		for(uint8 i=0,j=mapId.length();i<j;++i){
			
			Map@map=GetMap(mapId[i]);
			if(map is null)continue;
			
			uint8 airMod=100/(airLen[i]>0?airLen[i]:1),
			airPer=airMod*(airAct[i]);
			
			GameVar@dyspnea=GetLocalVar((9990),map.Id);
			if(dyspnea is null)continue;
			
			if(airPer<70)
			{
				dyspnea.opAddAssign(25);
				map.SetData((25),1);
			}
			else
			{
				dyspnea.opSub(20);
				map.SetData((25),0);
			}   
			
		}
		
	}      
	
}  

class ShitDen
{
	uint ItemId;
	
	ShitDen(uint itemId){
		ItemId=itemId;
		ProduceShit();
	}
	
	void ProduceShit()
	{
		
		Item@sd=GetItem(ItemId);
		if(sd is null)return;
		
		Item@[]insideMes();
		Item@item=null;
		
		for(uint i=0,iEnd=sd.GetItems(uint(-1),@insideMes);i<iEnd;++i)
		{
			@item=@insideMes[i];
			if(@item is null||item.IsNotValid)continue;
			if(item.Proto.Type!=15||item.Proto.Type!=16||item.GetProtoId()==(1599))continue;
			
			DeleteItem(item);
			ChangeConstBool(item.IsNotValid,true);
			sd.AddItem((1599),1,0);
		}
	}
	
	void ChangeConstBool(bool&var,bool value)
	{
		var=value;
	}
}

void ChangeConstBool(bool&var,bool value)
{
	var=value;
}  

class AirLock
{
	bool IsActive;
	uint MapId;
	
	AirLock(){
		MapId=0;
		IsActive=false;
	}
	
	AirLock(uint mapId,bool isActive){
		MapId=mapId;
		IsActive=isActive;
	}
}                  

void cumoa_parse(Critter&cr,int scriptSet,int,int)
{
	
	uint[]count(6);
	
	Item@[]items;
	Item@[]doors;
	Map@[]maps;
	uint mlen=GetAllMaps(0,maps);
	for(uint i=0;i<mlen;i++){
		if(maps[i]is null)continue;
		
		Map@map=maps[i];
		
		map.GetItems((1303),items);
		map.GetItems((1300),items);
		map.GetItems((1302),items);
		map.GetItems((1304),items);
		map.GetItems((1305),items);
		map.GetItems((1307),items);
		map.GetItems((1310),items);
		map.GetItems((1308),items);
		map.GetItems((1309),items);
		map.GetItems((1306),items);
		
		map.GetItems((10108),items);
		map.GetItemsByType((9),doors);
		
	}
	
	int[]iA;
	cumoa_add(iA,items);
	if(scriptSet>0){
		for(uint i=0,j=items.length();i<j;++i){
			Item@temp=GetItem(iA[i]);
			if(temp is null)continue;
			
			string sScript=GetScriptName(temp.GetProtoId()); 
			
			if(temp.GetType()!=(9))
			temp.SetScript(sScript);
		}
	}
	
	cumoa_add(iA,doors);        
	
	string msg="PARSE ERROR";
	
	if(IsAnyData(("CUMO"))){  
		
		EraseAnyData(("CUMO"));
	}
	
	if(SetAnyData(("CUMO"),iA)){
		msg="Динамических обьектов : "+(iA.length()/12);
	}          
	
	used_map_obj.Load();
	
	cr.Say((11),msg);
	
}

string GetScriptName(uint16 pid)
{
	string sScript="interactive_obj@";
	switch(pid)
	{
		case(1302):sScript+="AirLockInit";break;
		case(1303):sScript+="WattsInit";break;
		case(1300):sScript+="WaterPumpInit";break;
		case(1304):sScript+="DocInit";break;
		case(1305):sScript+="LightInit";break;
		case(1307):sScript+="SwitcherInit";break;
		case(1310):sScript+="WellInit";break;
		case(1308):sScript+="SawmillInit";break;
		case(1309):sScript+="FoundaryInit";break;
		case(1306):sScript+="WindmillInit";break;
		default:break;
	}
	return sScript;
}

bool cumo_add(int itemId,int setScript){
	
	Item@item=GetItem(uint(itemId));
	
	if(item is null){
		Log("Wrong item id.");
		return false;
	}else{
		if(setScript>0){
			item.SetScript(GetScriptName(item.GetProtoId()));
		}
	}
	
	int[]iA;
	Item@[]itms={item};
	
	GetAnyData(("CUMO"),iA);
	
	cumoa_add(iA,itms);
	
	SetAnyData(("CUMO"),iA);
	
	used_map_obj.Load();
	
	Log("object add");
	
	return true;
}

void cumoa_add(int[]&iA,Item@[]items){
	for(uint16 i=0,j=items.length();i<j;++i){
		Item@item=items[i];
		
		if(item is null||(item.GetType()==(9)&&!IsDoorAutomatic(item.GetProtoId()))){ 
			
			continue;
		}
		
		iA.insertLast(item.Val0);
		iA.insertLast(item.Val1);
		iA.insertLast(item.Val2);
		iA.insertLast(item.Val3);
		iA.insertLast(item.Val4);
		iA.insertLast(item.Val5);
		iA.insertLast(item.Val6);
		iA.insertLast(item.Val7);
		iA.insertLast(item.Val8);
		iA.insertLast(item.Val9);
		
		iA.insertLast(items[i].Id);
		iA.insertLast(items[i].GetProtoId());  
		
	}
	
}

CUMOA used_map_obj; 

void WaterPumpInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_WaterPumpSkill");
	item.SetEvent((3),"_WaterPumpOnMe");
}

const uint[]bottlePid={(542),(532)};
const uint[]bottleFull={(1627),(533)}; 

const uint[]ALLamapPids={(89),(92),(131)};   

bool IsRepair(Critter&cr,int science,int parts,int repair){
	if(science>0){cr.Say((11),"Требуется внимательный осмотр.");return true;}
	else if(parts>0){cr.Say((11),"Требуется деталь:");cr.SayMsg((11),(2),parts*100);return true;}
	else if(repair>0){cr.Say((11),"Требуется ремонт.");return true;}
	
	return false;
}

bool _WaterPumpSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;   
	
	int power=0,
	switcher=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{  
		
		if(IsRepair(cr,science,parts,repair))return true;
		
		if(power>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			string msg="";
			
			if(val>0)
			{
				msg="Включено";
			}
			else
			{
				msg="Выключено";
			}
			
			used_map_obj.SetValue(thisIndex,(2),val);
			
			cr.Say((11),""+msg+". Вода "+(val>0?"":"не")+" очищается.");
		}
		else
		{
			cr.Say((11),"Энергоснабжение отклчено. Запустите генератор сначала.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включено";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	return true;
}

bool _WaterPumpOnMe(Item&item,Critter&cr,Item@usedItem)
{
	
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	int8 index=bottlePid.find(pid);
	
	if(index!=-1)
	{     
		
		int power=0,
		switcher=0,
		charge=0;
		
		used_map_obj.GetValue(thisIndex,(1),power);
		used_map_obj.GetValue(thisIndex,(2),switcher);
		used_map_obj.GetValue(thisIndex,(3),charge); 
		
		if(power>0)
		{
			if(switcher>0)
			{
				if(charge>0)
				{
					do{if(usedItem.GetCount()>(1))
						usedItem.SetCount(usedItem.GetCount()-(1));else
						DeleteItem(usedItem);}while(false);
					cr.AddItem(bottleFull[index],1);
					charge--;
					used_map_obj.SetValue(thisIndex,(3),charge);
				}
				else
				{
					cr.Say((11),"Воды больше нет.");
				}
			}
			else
			{
				cr.Say((11),"Помпа отключена. Включите ее сначала.");
			}
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
		
		return true;
	}
	
	return false;
}

void WellInit(Item&item,bool firstTime){
	item.SetEvent((4),"_WellSkill");
	item.SetEvent((3),"_WellOnMe");
}

bool _WellSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;   
	
	int parts=0,
	repair=0,
	science=0;  
	
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		if(IsRepair(cr,science,parts,repair))return true;
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	
	return true;
}

bool _WellOnMe(Item&item,Critter&cr,Item@usedItem)
{
	
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	int8 index=bottlePid.find(pid);
	
	if(index!=-1)
	{     
		
		int charge=0;
		
		used_map_obj.GetValue(thisIndex,(3),charge);
		
		if(charge>0)
		{
			do{if(usedItem.GetCount()>(1))
				usedItem.SetCount(usedItem.GetCount()-(1));else
				DeleteItem(usedItem);}while(false);
			cr.AddItem(bottleFull[index],1);
			charge--;
			used_map_obj.SetValue(thisIndex,(3),charge);
		}
		else
		{
			cr.Say((11),"Воды больше нет.");
		}
		
		return true;
	}
	
	return false;
}

void SwitcherInit(Item&item,bool firstTime){
	item.SetEvent((4),"_SwitcherSkill");
	item.SetEvent((3),"_SwitcherOnMe");
}

bool _SwitcherSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1)){Log("CUMO INDEX ERROR");return false;}   
	
	int power=0,
	switcher=0,
	objId=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(3),objId);
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		
		if(IsRepair(cr,science,parts,repair))return true;   
		
		int val=switcher;
		val=(val>0?0:1);
		
		used_map_obj.SetValue(thisIndex,(2),val);
		used_map_obj.UseSwitcher(objId,val);
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
		}
		else
		{
			msg="выключен";
		}  
		
		cr.Say((11),"Переключатель "+msg+".");    
		
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
			
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	
	return true;
}

bool _SwitcherOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	return true;
}

void SawmillInit(Item&item,bool firstTime){
	item.SetEvent((4),"_SawmillSkill");
	item.SetEvent((3),"_SawmillOnMe");
}

bool _SawmillSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1)){Log("CUMO INDEX ERROR");return false;}   
	
	int power=0,
	switcher=0,
	charge=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher); 
	
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		
		if(IsRepair(cr,science,parts,repair))return true;   
		
		int val=switcher;
		val=(val>0?0:1);
		
		used_map_obj.SetValue(thisIndex,(2),val);
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
		}
		else
		{
			msg="выключен";
		}
		
		WattsRelease(thisIndex,val);
		
		cr.Say((11),"Деревообрабатывающий станок "+msg+".");    
		
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
			
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}  
	
	return true;
}

bool _SawmillOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	return true;
}

void FoundryInit(Item&item,bool firstTime){
	item.SetEvent((4),"_FoundrySkill");
	item.SetEvent((3),"_FoundryOnMe");
}

bool _FoundrySkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1)){Log("CUMO INDEX ERROR");return false;}   
	
	int power=0,
	switcher=0,
	charge=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher); 
	
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		
		if(IsRepair(cr,science,parts,repair))return true;   
		
		int val=switcher;
		val=(val>0?0:1);
		
		used_map_obj.SetValue(thisIndex,(2),val);
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
		}
		else
		{
			msg="выключен";
		}  
		
		cr.Say((11),"Плавильня "+msg+".");    
		
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
			
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}  
	
	return true;
}

bool _FoundryOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	return true;
}

void WindmillInit(Item&item,bool firstTime){
	item.SetEvent((4),"_WindmillSkill");
	item.SetEvent((3),"_WindmillOnMe");
}

bool _WindmillSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1)){Log("CUMO INDEX ERROR");return false;}   
	
	int power=0,
	switcher=0,
	charge=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher); 
	
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		
		if(IsRepair(cr,science,parts,repair))return true;   
		
		int val=switcher;
		val=(val>0?0:1);
		
		used_map_obj.SetValue(thisIndex,(2),val);
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
		}
		else
		{
			msg="выключен";
		}
		
		WattsRelease(thisIndex,val);
		
		cr.Say((11),"Ветряк "+msg+".");    
		
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включен";
			
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	
	return true;
}

bool _WindmillOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	return true;
}

void WattsInit(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_WattsSkill");
	item.SetEvent((3),"_WattsOnMe");
}

bool _WattsSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1)){Log("CUMO INDEX ERROR");return false;}   
	
	int power=0,
	switcher=0,
	charge=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(3),charge);
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		
		if(IsRepair(cr,science,parts,repair))return true;
		
		if(charge>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			used_map_obj.SetValue(thisIndex,(2),val);
			
			string msg="";
			
			if(val>0)
			{
				msg="включен";
			}
			else
			{
				msg="выключен";
			}
			
			WattsRelease(thisIndex,val);
			
			cr.Say((11),"Генератор "+msg+".");
		}
		else
		{
			cr.Say((11),"Кончился заряд. Зарядите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;
		
		int val=switcher;
		
		string msg="",addMsg="";
		
		if(val>0)
		{
			msg="включен";
			addMsg=" Уровень заряда генератора : "+charge+" .";
		}
		else
		{
			msg="выключен";
		}
		
		cr.Say((11),"Сейчас "+msg+"."+addMsg);
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	
	return true;
}

bool _WattsOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	if(usedItem.GetProtoId()!=(39))
	return false;     
	
	int power=0,
	switcher=0,
	charge=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(3),charge);
	
	charge+=20;
	used_map_obj.SetValue(thisIndex,(3),charge);
	
	do{if(usedItem.GetCount()>(1))
		usedItem.SetCount(usedItem.GetCount()-(1));else
		DeleteItem(usedItem);}while(false);
	
	cr.Say((11),"Вы подзарядили генератор.");
	
	return true;
}

void WattsRelease(uint index,int val)
{
	used_map_obj.ShutDown(index,val);
}

bool IsDoorAutomatic(uint pid)
{
	bool automat=(pid==2142||pid==2143||pid==3169||pid==3170||pid==4763||pid==4765);
	
	return automat;
}

bool IsDoorAutomatic(Item&door,bool&isPower)
{
	if(IsDoorAutomatic(door.GetProtoId()))
	{
		int value=-1;
		if(intgetval(door.Id,(8),value))
		isPower=value>0;
		return true;
	}
	return false;
}

void AirLockInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_AirLockSkill");
	item.SetEvent((3),"_AirLockOnMe");
}

bool _AirLockSkill(Item&item,Critter&cr,int skill)
{
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;   
	
	int power=0,
	switcher=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{
		if(IsRepair(cr,science,parts,repair))
		{
			used_map_obj.ObjectTimeLoop();
			return true;
		} 
		
		if(power>0)
		{
			int val=switcher;
			val=(val>0?0:1);
			
			string msg="";
			
			if(val>0)
			{
				msg="Включено";
			}
			else
			{
				msg="Выключено";
			} 
			
			switcher=val;
			used_map_obj.SetValue(thisIndex,(2),switcher);
			cr.Say((11),""+msg+". Воздух "+(val>0?"":"не")+" поступает.");
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))
		{
			used_map_obj.ObjectTimeLoop();
			return true;
		}  
		
		int val=switcher;
		
		string msg="";
		
		if(val>0)
		{
			msg="включено";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+".");
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))
		{
			used_map_obj.ObjectTimeLoop();
			return true;
		}
	}
	used_map_obj.ObjectTimeLoop();
	return true;
}

bool _AirLockOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	uint pid=usedItem.GetProtoId();
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	return false;
}

void DocInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"_DocSkill");
	item.SetEvent((3),"_DocOnMe");
}

bool _DocSkill(Item&item,Critter&cr,int skill)
{
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;   
	
	int power=0,
	switcher=0,
	charge=0,
	parts=0,
	repair=0,
	science=0;
	
	used_map_obj.GetValue(thisIndex,(1),power);
	used_map_obj.GetValue(thisIndex,(2),switcher);
	used_map_obj.GetValue(thisIndex,(3),charge);
	used_map_obj.GetValue(thisIndex,(5),parts);
	used_map_obj.GetValue(thisIndex,(6),repair);
	used_map_obj.GetValue(thisIndex,(7),science);
	
	if(skill==(-1))
	{          
		
		if(IsRepair(cr,science,parts,repair))return true;  
		
		if(power>0)
		{
			if(charge>0)
			{
				DocHeal(cr);
				
				charge--;
				charge=(((charge)>(100))?(100):(((charge)<(0))?(0):(charge)));
				used_map_obj.SetValue(thisIndex,(3),charge);
				
			}
			else
			{
				cr.Say((11),"Закончился биогель, обновите резервуар.");
			}
		}
		else
		{
			cr.Say((11),"Энергия отключена. Включите генератор.");
		}
	}
	else if(skill==(212))
	{
		if(!check_science(used_map_obj.cumos[thisIndex],cr))return true;     
		
		string msg="",addMsg="";
		
		if(power>0)
		{
			msg="включено";
			addMsg=" Биогеля хватит на "+charge+" операций.";
		}
		else
		{
			msg="выключено";
		}
		
		cr.Say((11),"Сейчас "+msg+"."+addMsg);
	}
	else if(skill==(213)&&repair>0)
	{
		if(!check_repair(used_map_obj.cumos[thisIndex],cr))return true;
	}
	
	return true;
}

bool _DocOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem is null)
	return false;
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return false;
	
	if(!check_parts(used_map_obj.cumos[thisIndex],cr,usedItem))return true;
	
	if(usedItem.GetProtoId()!=(440))
	return false;     
	
	int charge=0;
	
	used_map_obj.GetValue(thisIndex,(3),charge);    
	
	if(charge<=0)
	{
		
		charge=100;
		do{if(usedItem.GetCount()>(1))
			usedItem.SetCount(usedItem.GetCount()-(1));else
			DeleteItem(usedItem);}while(false);
		
		cr.Say((11),"Вы залили биогель в резервуар.");
	}
	else
	{
		cr.Say((11),"Биогель пока не требуется.");
	}
	
	return true;
}

void DocHeal(Critter&cr)
{
	if(!(@cr!=null))return;
	
	DropBleed(cr);
	DropToxic(cr);
	cr.StatBase[(146)]=0;
	cr.EraseTimeEvents((41));
	cr.EraseTimeEvents((42));
	
	for(uint16 i=502;i<506;++i)
	{
		if(cr.Damage[i]!=0)Prolonged_Doc(cr,Random(500,1000),i);
	}
	
	Prolonged_heal(cr,300);
}            

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                        

void LightInit(Item&item,bool firstTime)
{
	
	item.SetEvent((4),"_LightSkill");        
	
	string picName="art\\scenery\\whitePXL.frm";
	
	uint hash=GetStrHash(picName);
	item.SetMapPic(hash); 
	
	item.LightColor=(item.Val3!=0?item.Val3:9999666);
	item.LightDistance=6;   
	
	uint thisIndex=used_map_obj.GetIndexByItemId(item.Id),genIndex=0;
	if(thisIndex==uint(-1))return;
	
	int switcher=0;
	
	used_map_obj.GetValue(thisIndex,(2),switcher);
	
	item.LightIntensity=(switcher>0?100:0);
	
	item.Update();
	
}

bool _LightSkill(Item&item,Critter&cr,int skill)
{
	return true;
}                                                                                                                                                

void ProccessAir(){
	
}

void ShowLight(Critter&cr,int x,int,int)
{
	Item@[]item;
	Map@map=cr.GetMap();
	
	if(map is null)
	return;
	
	map.GetItems((1305),item);
	
	for(uint16 i=0,j=item.length();i<j;++i)
	{
		string picName="art\\scenery\\";
		
		if(x>0)
		{
			picName+="grid_wall.frm";
		}
		else
		{
			picName+="whitePXL.frm";
		}
		
		uint hash=GetStrHash(picName);
		item[i].SetMapPic(hash);
		
		cr.Say((11),"flag "+item[i].Flags);
	}
	
}                  

void debugOnOff(Critter&cr,int index,int val,int){
	used_map_obj.ShutDown(index,val);
}

void spawn_autodoors(Critter&cr,int val,int,int)
{
	for(uint8 i=0;i<ALLamapPids.length();++i)
	{
		Map@map=GetMapByPid(ALLamapPids[i],0);
		if(map is null)
		continue;
		
		Item@[]door;
		
		map.GetItemsByType((9),door);
		
		for(uint8 ii=0,jj=door.length();ii<jj;++ii)
		{
			Item@item=door[ii];
			
			if(item is null)
			continue;
			
			if(IsDoorAutomatic(item.GetProtoId()))
			{
				uint16 x=item.HexX;
				uint16 y=item.HexY;
				for(uint8 i=0;i<6;i++)
				{
					map.MoveHexByDir(x,y,i,1);
					if(!(@map.GetItem(x,y,(1544))!=null))
					{
						Item@pedal=map.AddItem(x,y,(1544),1);
						pedal.Val1=item.Id;
					}
					x=item.HexX;
					y=item.HexY;
				}
				
			}
		}
		
	}
} 

void debugDyspnea(Critter&cr,int val,int,int){
	Map@map=cr.GetMap();
	if(map is null)return;
	
	GameVar@dyspnea=GetLocalVar((9990),map.Id);
	if(dyspnea is null)return;
	
	dyspnea.opAssign((((val)>(100))?(100):(((val)<(0))?(0):(val))));
	map.SetData((25),(((val)>(1))?(1):(((val)<(0))?(0):(val)))); 
	
	return;
}

bool check_parts(CUMO&cumo,Critter&cr,Item&usedItem)
{  
	
	uint pid=usedItem.GetProtoId();
	
	if(cumo.Val[(7)]>0){cr.Say((11),"Пока еще непонятно в чем проблема.");return false;}
	if(cumo.Val[(5)]>0)
	{
		
		uint partPid=cumo.Val[(5)]&0xFFF;
		uint partCount=(cumo.Val[(5)]>>12)&0xF;
		
		if(pid==partPid)
		{
			cr.Say((11),"Вы установили требуемую деталь.");
			cr.StatBase[(76)]+=(50);
			do{if(usedItem.GetCount()>(1))
				usedItem.SetCount(usedItem.GetCount()-(1));else
				DeleteItem(usedItem);}while(false);
			
			partCount--;
			
			if(partCount>0){
				partCount=((partCount<<12)|(partPid));
			}else{
				partCount=0;
				cumo.Val[(9)]--;
				(((cumo.Val[(9)])>(9))?(9):(((cumo.Val[(9)])<(0))?(0):(cumo.Val[(9)])));
				
				for(uint8 i=0,j=cumo_breaks.length();i<j;++i){
					if(cumo_breaks[i].CheckBreak(cumo))break;
				}
			}
			
			cumo.Val[(5)]=partCount;
			return true;
		}
		
		cr.Say((11),"Деталь не подходит.");
		return false;
	}
	return true;
}

bool check_repair(CUMO&cumo,Critter&cr)
{  
	
	if(cumo.Val[(7)]>0){cr.Say((11),"Пока еще непонятно в чем проблема.");return false;}
	if(cumo.Val[(5)]>0){cr.Say((11),"Пока еще нет нужной детали.");return false;}
	if(cr.Skill[(213)]<cumo.Val[(6)]){cr.Say((11),"Недостаточно навыка для того чтобы исправить проблему.");return false;}
	else
	{
		cr.Say((11),"Вы определили неисправность и устранили ее.");
		cr.StatBase[(76)]+=(cumo.Val[(6)]*2);
		cumo.Val[(6)]=0;
	}
	return true;
}

bool check_science(CUMO&cumo,Critter&cr)
{  
	
	uint16 science=cumo.Val[(7)];
	uint16 parts=cumo.Val[(5)];
	if(science>0)
	{
		if(cr.Skill[(212)]<science){cr.Say((11),"Недостаточно навыка для того чтобы определить проблему.");return false;}
		else
		{
			if(parts>0){cr.Say((11),"Вы определили и пометили неисправность, требуется деталь:");cr.SayMsg((11),(2),parts*100);}
			else if(cumo.Val[(6)]>0)cr.Say((11),"Вы определили и пометили неисправность, остается применить практические навыки.");
			else cr.Say((11),"Вы определили неисправность и устранили ее.");
			cumo.Val[(7)]=0;
			return true;
		}
	}
	return true;
}                                                              

int intsetval(uint id,uint val,int value)
{
	if(val<(0)||val>(9))
	return-1;
	
	uint index=used_map_obj.GetIndexByItemId(id);
	if(index==uint(-1))
	return-2;
	
	used_map_obj.SetValue(index,val,value);
	return 0;
}

string@intGetValueName(uint val)
{
	return valDesc[val];
}

void iobjadd(Critter&cr,int id,int script,int){
	if(!cumo_add(uint(id),script)){
		cr.Say((11),"wrong id");
	}else{
		cr.Say((11),"object add");
	}
}

void intsetval(Critter&cr,int id,int val,int value)
{
	int result=intsetval(id,val,value);
	switch(result)
	{
		case-1:
		cr.Say((11),"wrong VAL num");
		break;
		case-2:
		cr.Say((11),"wrong item id");
		break;
		default:
		cr.Say((11),"Уставновил\n"+intGetValueName(val)+" для "+id+" в "+value);
		break;
	}
}

bool intgetval(uint id,int val,int&out value)
{
	uint index=used_map_obj.GetIndexByItemId(id);
	if(index==uint(-1))
	return false;
	
	used_map_obj.GetValue(index,val,value);
	return true;
}

void intgetval(Critter&cr,int id,int,int)
{
	uint index=used_map_obj.GetIndexByItemId(id);
	if(index==uint(-1))
	{
		cr.Say((11),"wrong item id");
		return;
	}
	
	int val=0;
	if(!intgetval(id,0,val))
	{
		cr.Say((11),"wrong item id");
		return;
	}
	cr.Say((11),intGetValueName(0)+" : "+val);
	
	for(uint8 i=1;i<10;i++)
	{
		used_map_obj.GetValue(index,i,val);
		cr.Say((11),valDesc[i]+" : "+val);
	}
}

void intturnonobjs(Critter&cr,int generatorValue,int objType,int onoff){  
	
	uint16[]objTypePids={(1300),(1303),(1302),(1304),(1305),
		(1306),(1307),(1308),(1309),(1310)};
	
	uint objCount=0;
	
	for(uint i=0,j=used_map_obj.cumos.length;i<j;i++){
		if(used_map_obj.cumos[i].Val[(0)]==generatorValue&&used_map_obj.cumos[i].PID==objTypePids[objType]){
			used_map_obj.ShutDown(i,(((onoff)>(1))?(1):(((onoff)<(0))?(0):(onoff))));
			if(onoff>0){
				used_map_obj.cumos[i].Val[(2)]=1;
			}
			objCount++;
		}
	}
	
	cr.Say((11),""+(onoff>0?"Включил ":"Выключил ")+objCount+" обьектов");
}

void interasedouble(Critter&cr,int,int,int){ 
	
	uint cumLen=used_map_obj.cumos.length();
	
	CUMO[]tempCUMos=used_map_obj.cumos;
	
	uint[]delIndex;
	
	uint counter=0;
	uint delObj=0;
	
	while(counter<tempCUMos.length()){
		delIndex.resize(0);
		
		for(uint i=0,j=tempCUMos.length();i<j;i++){
			if(tempCUMos[counter].ItemId==tempCUMos[i].ItemId){
				delIndex.insertLast(i);
			}
			
		}
		
		delIndex.removeLast();
		delIndex.reverse();
		
		delObj+=delIndex.length();
		
		for(uint i=0;i<delIndex.length();i++){
			tempCUMos.removeAt(delIndex[i]);
		}
		
		counter++;
	};  
	
	used_map_obj.cumos=tempCUMos;
	
	cr.Say((11),"обьектов удаленно : "+delObj+"\nосталось : "+tempCUMos.length()+"\nциклов : "+counter);
	
}
