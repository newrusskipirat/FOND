// Author: cvet, Atom
// Client main script
// Compile using fo_client.dll
/*# define SOURCE_EVENT_ROOT
namespace Global
{
	EventTree@ __EventRoot = null;
}

EventTree @get_EventRoot(){ return @Global::__EventRoot; }*/

#include "_client_defines.fos"
#include "_macros.fos"
#include "_msgstr.fos"
#include "sprite.fos"
#include "_colors.fos"
#include "_animation.fos"
#include "combat_h.fos"
#include "throwing.fos"
// #include "client_call_sign.fos" //tnf radio

import void InitializeGame() from "config";
import void InitTestScreen() from "client_screen_test";
import void InitRadioScreen() from "radio";
import void GUI_Init() from "client_gui";
import int GUI_GetActiveMainScreen() from "client_gui";
import void GUI_GetActiveScreens( int[]& result ) from "client_gui";
import void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_Render() from "client_gui";
import bool GUI_MouseDown( int click, int x, int y ) from "client_gui";
import bool GUI_MouseUp( int click, int x, int y ) from "client_gui";
import void GUI_MouseMove( int x, int y ) from "client_gui";
import bool GUI_KeyDown( uint8 key ) from "client_gui";
import bool GUI_KeyUp( uint8 key ) from "client_gui";
import void GUI_InputLost() from "client_gui";
import bool PerkCheck( CritterCl& cr, uint perk ) from "perks";
import void CritterGenerate( int[]& data ) from "parameters";
import bool CritterGenerateCheck( int[]& data ) from "parameters";
// import void InitNameColorizing() from "name_colorizing";
// import bool TryColorizeCritter(CritterCl& cr) from "name_colorizing";
import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";
// binyan - Hotkeys
import void SetHotkeysUse( bool use ) from "hotkeys";
// binyan - timeouts
import void show_timeouts() from "client_timeouts";
// ///////////////////////////////////////////////////////
import bool gm_msg( string& message ) from "client_gm";

#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender( int gender ) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters( int[]& params ) from "client_3d_cha_reg";
#endif
import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

// qthree
import void    SaveNames() from "client_names";
import void    LoadNames() from "client_names";
import void    ClearNameCache() from "client_names";
import string@ GetName( uint id ) from "client_names";
import bool    updateNick( CritterCl& cr ) from "client_names";
import bool    updateAllNicks() from "client_names";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";


// @pm menu
import void InitContMenuScreen() from "client_screen_contmenu";     // Export
import void InitFastPanelScreen() from "client_screen_fastpanel";   // Export
import void InitFastPanelSkillbox() from "client_screen_fastpanel"; // export
import void InitFastPanelTextbox() from "client_screen_fastpanel";
// import void SaveFastPanel(bool save) from "client_screen_fastpanel";
import void InitHistoryViewScreen() from "client_screen_history";
import void InitHistoryAllScreen() from "client_screen_history";
import void HidePanel( bool show ) from "client_screen_fastpanel";
import void InitCodedoorScreen() from "client_screen_codedoor";
import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";
import void InitTeachScreen() from "client_screen_teaching";
import void InitScreenDoc() from "client_screen_doc";
import void InitFirstAidScreen() from "client_screen_firstais";
import void InitOptMenuScreen() from "client_screen_options"; // Export
import void SetHivePos( int16 x, int16 y, int16 realX, int16 realY, int16 type, uint8 count ) from "client_screen_additional";
import void InitScreenInputbox() from "client_screen_inputbox";
import void InitInventoryTnfScreen() from "client_screen_inventory";
import void MoveHand() from "client_screen_copybool";
import void InitClockScreen() from "client_screen_copybool";
import void InitWaypointScreen() from "checkpoints";
// #pm menu

uint prevId = 0; // нужен для определения, когда загружать сохраненные имена
Sprite[] arrow;

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
	/*@Global::__EventRoot = EventTree::Create("root");
	if( @EventRoot is null )
	{
		Message( "Ошибка инициализации системы ивентов." );
		return false;
	}*/
	InitializeGame();

    if( __ScreenWidth < 800 || __ScreenWidth > 1280 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
//		return false;
    }

    #ifdef PLAYERS_3D
    AppendIfaceIni( "players3d_chareg.ini" );
    # ifndef PLAYERS_3D_NO_HEAD
    AppendIfaceIni( "players3d_headinv.ini" );
    # endif
    #endif

    LoadFont( FONT_COURIER_NEW_SMALL, "CourierNewSmall" );
    // SetDefaultFont(FONT_COURIER_NEW_SMALL,COLOR_TEXT);
/*
        if(!LoadDataFile("longhairdude.dat")) Message("File longhairdude.dat with Long Hair Dude animations not found. Run Updater.exe.");
        if(!LoadDataFile("vaultboy.dat")) Message("File vaultboy.dat with Vault Boy animations not found. Run Updater.exe.");
        if(!LoadDataFile("cablack.dat")) Message("File cablack.dat with Black Combat Armor animations not found. Run Updater.exe.");
        if(!LoadDataFile("mirelurk.dat")) Message("File mirelurk.dat with Black Combat Armor animations not found. Run Updater.exe.");
        if(!LoadDataFile("balddude.zip")) Message("File balddude.zip not found. Run Updater.exe.");
        if(!LoadDataFile("sandrobe.zip")) Message("File sandrobe.zip not found. Run Updater.exe.");
 */
    if( !AppendIfaceIni( "rp_default.ini" ) )
        Message( "Не найден rp_default.ini! Обновите клиент с репозитория http://svn3.xp-dev.com/svn/fo_cl_rp/" );
    //else
    //    Message( "Файлы из tnf.zip успешно загружены, карта мира и интерфейс изменены для игры на Roleplay сервере." );

    GUI_Init();
    // InitNameColorizing();
// TMP  CallSignStart();
    // InitTestScreen();
    InitRadioScreen();
    InitChosenTabs();

    // @pm menu
    InitContMenuScreen();
    InitFastPanelScreen();
    InitFastPanelSkillbox();
    InitFastPanelTextbox();
    InitCodedoorScreen();
    InitScreenAddiotional();
    InitTeachScreen();
    InitScreenDoc();
    InitFirstAidScreen();
    InitOptMenuScreen();
    InitInventoryTnfScreen();
    InitScreenInputbox();
    InitClockScreen();
    InitWaypointScreen();

    ExpBarSetPos();

    // InitHistoryViewScreen();
    // InitHistoryAllScreen();
    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu

    #ifdef PLAYERS_3D
    Init3DChaRegScreen();
    #endif

    __ShowPlayerNames = true;
    __ShowNpcNames = true;

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

    if( !__FullScr )
        __MouseScroll = false;

    // 3d models preloading
    #ifdef PLAYERS_3D
    // Mobs
/*	Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbAntQueen.fo3d"      , PT_ART_CRITTERS);
        Load3dFile("VbBat.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbBeetle.fo3d"        , PT_ART_CRITTERS);
        Load3dFile("VbCentipede.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbCougar.fo3d"        , PT_ART_CRITTERS);
        Load3dFile("VbCow.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbDeathclaw.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbDesertStalker.fo3d" , PT_ART_CRITTERS);
        Load3dFile("VbDog.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbGila.fo3d"          , PT_ART_CRITTERS);
        Load3dFile("VbMantrap.fo3d"       , PT_ART_CRITTERS);
        Load3dFile("VbRadToad.fo3d"       , PT_ART_CRITTERS);
        Load3dFile("VbRat.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbThornSlinger.fo3d"  , PT_ART_CRITTERS);
        Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbWaspGiant.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbWeedling.fo3d"      , PT_ART_CRITTERS);*/
    // Critters
    Load3dFile( "VbFemaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleSkeleton.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleSkeleton.fo3d", PT_ART_CRITTERS );
    #endif
	
	CellBioms.resize( 0 );
	real_CellBiomWidth = 0;
	
	return true;
	/*EventRoot.ScanCallback( "Init", "ModuleInit" );
	if( !EventRoot.Run( "Init" ) )
		return false;
	
    return EventRoot.Run( "Start" );*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
/*	CritterCl@ cr = GetChosen();
        if(!valid(cr)) return 1000;
        cr.NameOnHead="|0xff77ff22 "+cr.Name+" |0xffff0000 (Id:"+cr.Id+")\n|0xffAA55BB HexX: "+cr.HexX+"\n|0xff11ffff HexY: "+cr.HexY;
        return 100;
 */
    if( GUI_GetActiveMainScreen() == CLIENT_MAIN_SCREEN_WAIT )
        return 250;
    if( __isClockActive /* && loop_turn % 100 == 0*/ )
    {
        MoveHand();
    }

    if( loop_turn % 5 == 0 )
        qmap_loop();

    if( loop_turn % 100 == 0 )
    {
		int[] result;
		GUI_GetActiveScreens( result );
        CritterCl@ chosen = GetChosen();
        if( @chosen !is null && prevId == chosen.Id && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
        loop_turn = 0;

    return 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Show/hide screen behaviour.
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{
	if( screen == CLIENT_MAIN_SCREEN_GLOBAL_MAP && !show )
	{
		CellBioms.resize( 0 );
		real_CellBiomWidth = 0;
	}

// qthree
    if( screen == CLIENT_MAIN_SCREEN_LOGIN )
    {
        prevId = 0;
        ClearNameCache();
    }

// binyan - Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
        __IsTextInput = show ? true : false;
// /////////////////////////////////////
    if( show )
        GUI_ShowScreen( screen, p0, p1, p2 );
    else
        GUI_HideScreen( screen, p0, p1, p2 );
}

int[]@ data_color = null;
int[]@ data_number = null;
int[]@ data_char = null;

string@ GlobalMapDebugStr = null;

int[] hive_data;

void SetHiveData( int[] hivedata )
{
    hive_data.resize( 0 );
    for( uint8 i = 0; i < hivedata.length(); i++ )
    {
        hive_data.insertLast( hivedata[ i ] );
    }
}

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
	@GlobalMapDebugStr = @param3;
    switch( param0 )
    {
    case 1:
        @data_color = @param4;
        break;
    case 2:
        @data_number = @param4;
        break;
    case 3:
        @data_char = @param4;
        break;
    default:
        break;
    }
}

string@[] CellBioms;
uint real_CellBiomWidth = 0;

uint get_CellBiomWidth()
{
	if( real_CellBiomWidth == 0 )
	{
		real_CellBiomWidth = uint( -1 );
		RunServerScriptUnsafe( "world@unsafe_GetCellBiomWidth", 0, 0, 0, null, null );
		return 0;
	}
	else if( real_CellBiomWidth == uint( -1 ) )
		return 0;
	else return real_CellBiomWidth;
}

string GetCellBiomName( uint uid )
{
	if( CellBioms.length() <= uid )
		CellBioms.resize( uid + 1 );
	
	if( @CellBioms[uid] is null )
	{
		@CellBioms[uid] = "none";
		RunServerScriptUnsafe( "world@unsafe_GetCellBiom", uid, 0, 0, null, null );
		return "";
	}
	return CellBioms[uid];
}

string GetCellBiomName( uint x, uint y )
{
	uint w = CellBiomWidth;
	if( w == 0 || w == uint( -1 ) )
		return "";
	return GetCellBiomName( x + y * w );
}

void _SetCellBiomWidth( int uid, int, int, string@ name, int[]@ ) 
{
	real_CellBiomWidth = uid;
}

void _SetCellBioms( int uid, int, int, string@ name, int[]@ ) 
{
	CellBioms[uid] = name;
}

void DrawTxt(string& text, int posx, int posy, int wMax, int hMax, uint color, int font, int flags)
{
	string@[] linesTxt = split( text, "\n" );

	int  w = 0;
	int  h = 0, hStand = 0;
	uint linesCount = linesTxt.length();
	int  lines = 0;
	GetTextInfo( "L", 0, 0, font, flags, w, hStand, lines );
	hStand += 2;
			
	hMax = hStand * ( linesCount + 1 );
	for( uint i = 0; i < linesCount; i++ )
	{
	    GetTextInfo( linesTxt[ i ], 0, 0, font, flags, w, h, lines );
	    if( w > wMax )
	    {
	        string@[] wordTxt = split( linesTxt[ i ], " " );
	        int wx = 0, wxt = 0;
	        for( uint wi = 0; wi < wordTxt.length(); wi++ )
	        {
				GetTextInfo( wordTxt[ wi ], 0, 0, font, flags, wx, h, lines );
				if( ( wxt + wx ) >= wMax )
				{
					wxt = 0;
					hMax += hStand;
				}
				else wxt += wx;
	        }

	        hMax += hStand;
	    }
	}

    DrawText( text, posx, posy, wMax, hMax, color, font, flags );  
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    0
// Game map, Global map, Login, Registration, Credits, Wait
//    1
// Game interface
//    2
// Console, Messbox
//    3
// Inventory, PickUp, MiniMap, Dialog/Barter, PipBoy, FixBoy, Options menu, Character, Aim
// Split, Timer, DialogBox, Elevator, Say, Character name, Character age, Character sex, Global map town, InputBox, SkillBox, Use, Perk
//    4
// PopUp menu, Cursor
//    5
//
// Extra layers:
// Global map
//    100, 101

void render_iface( uint layer )
{
    if( GUI_GetActiveMainScreen() == CLIENT_MAIN_SCREEN_WAIT )
        return;
		
	if( layer == 4 )
	{
		//int[] drawData = {0, 0, 0xFFFFFFFF, 5, 5, 0xFFFF00FF};
		//DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
		TestDirect3d(0);
	}
	//return;

    if( layer == 3 )
    {
        DrawChosenTabs();
        GUI_Render();

        // if(!__GmapActive && )DrawExpBar();

        if( GetCurrentCursor() == CURSOR_MOVE )     // pm map arrows
        {
            ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
            if( @item !is null )
            {
                if( item.GetProtoId() >= EXIT_GRID_PID && item.GetProtoId() <= EXIT_GRID_PID + 8 )
                {
                    CritterCl@ choo = GetChosen();

                    if( ABS( int(choo.HexX - item.HexX) ) <= 16 && ABS( int(choo.HexY - item.HexY) ) <= 16 )
                    {
                        // Message(""+item.Val7+" "+item.Val8+" "+item.Val9+" "+item.Val1+" "+item.Val0);
                        int value = GetScenParam( item.HexX, item.HexY, item.GetProtoId(), 0 );                      // item.Param0;//item.Val1;
                        // Message("value1 "+value);
                        int x = 0, y = 0;
                        switch( value )
                        {
                        case 0:
                            x = -100;
                            y = -80;
                            break;
                        case 1:
                            x = -120;
                            y = -110;
                            break;
                        case 2:
                            x = -120;
                            y = -120;
                            break;
                        case 3:
                            x = -120;
                            y = -100;
                            break;
                        case 4:
                            x = -90;
                            y = -110;
                            break;
                        case 5:
                            x = -100;
                            y = -110;
                            break;
                        case 6:
                            x = -60;
                            y = -125;
                            break;
                        case 7:
                            x = -120;
                            y = -120;
                            break;
                        default:
                            break;
                        }

                        int localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

                        if( value != choo.StatBase[ ST_LOCALMAP_DIR ] ){
                            RunServerScriptUnsafe( "world@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );
                        }
						if( localMapPid != -1 )
						{
							string mapName = GetMsgStr( TEXTMSG_GM, ( localMapPid + 1) * 10 + 8 );
							if( strlwr(mapName) == "error" )
								localMapPid = 0;
							arrow[ value ].Draw( __MouseX + x, __MouseY + y );
							DrawText( ( ( localMapPid != 0 ) ? mapName : "Пустошь" ), __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, localMapPid != 0 ? COLOR_LGREEN : COLOR_RED, FONT_BIG, 0 );
						}
                    }


                }
            }

        }
        // binyan - Hex attack
        if( __IsHexAttack )
        {
            int tohit = to_hit_hex();
            if( tohit > 0 )
                DrawText( tohit + "%", __MouseX + 7, __MouseY + 8, ( ( tohit / 10 >= 1 ? 2 : 1 ) + 2 ) * 10, 10, COLOR_RED, FONT_FALLOUT, 0 );
        }
        if( __ShowTimeouts )
            show_timeouts();

        RenderThrowing();
    }
    else if( layer == 100 && __GmapActive )
    {
        // Here you can draw on global map

        // bool  __GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  __GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float __GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   __GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   __GmapGroupCurX/Y - координаты группы игрока;
        // int   __GmapGroupToX/Y  - координаты точки назначения;
        // float __GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        CritterCl@ ch = GetChosen();

        // SetHivePos(__GmapOffsetX, __GmapOffsetY, 5);
        if( @ch !is null && ch.Quest[ QST_GAMEMODE ] == GAME_ARCADE )
        {
            // Message(""+hive_data.length());
            for( uint i = 0; i < hive_data.length(); i++ )
            {
                int16 x = ( hive_data[ i ] ) & 0x3FF;
                int16 y = ( hive_data[ i ] >> 10 ) & 0x3FF;
                int16 type = ( hive_data[ i ] >> 20 ) & 0xFFF;

                SetHivePos( x / __GmapZoom + __GmapOffsetX, y / __GmapZoom + __GmapOffsetY, x, y, type, i );

                // Message("i "+i+" type "+type+" x "+x+" offX "+__GmapOffsetX+" y "+y+" offY "+__GmapOffsetY);
            }

            // GUI_Render(100);
        }


        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED ),
            font = FONT_FALLOUT;

        float  size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            uint len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                // int color = 0x44772222;

                int[] drawData( len / 2*18 );

                for( uint i = 0, j = 0; i < len / 2; j++ )
                {
                    float x = ( data_color[ j * 2 ] & 0xFFFF ),
                          y = ( ( data_color[ j * 2 ] >> 16 ) );

                    // if(x0==chx && y0==chy) {len-=2; continue;}

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;

                    int a = data_color[ j * 2 + 1 ];

                    /*if(a==0x33773333)
                       {
                            len-=2; continue;
                       }*/

                    uint k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;

                    /*for(uint k=0, p=i*18; k<4; k++)
                       {
                            drawData[p++]=x+size*(k&1);
                            drawData[p++]=y+size*(k>>1);
                            drawData[p++]=a;
                       }*/

                    i++;
                }
                drawData.resize( len / 2 * 18 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            uint8 alpha = CLAMP( ( size - 5 ) * 20, 0, 0xAA );
            // int r=0x66, g=0xBB, b=0x44;
            int   r = 0x22, g = 0x22, b = 0x22;
            // float t=2/__GmapZoom-2; t=MIN(t, 1);
            // r*=t*t*t; g*=t; b*=t*t*t;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int   color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            float x0 = __GmapOffsetX,
                  y0 = __GmapOffsetY,
                  x = ( ZONE_COUNT_X * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetX,
                  y = ( ZONE_COUNT_Y * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetY;

            uint w = ZONE_COUNT_X * ZONE_LENGTH / 10,
                 h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 )*6 );

            for( uint i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = y0 + size * i;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = y0 + size * i;
                drawData[ i * 6 + 5 ] = color;
            }
            for( uint j = 0; j <= w; j++ )
            {
                uint i = h + 1 + j;
                drawData[ i * 6 ] = x0 + size * j;
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x0 + size * j;
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }

            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 /*&& ((ch !is null and ch.Quest[QST_GAMEMODE]==GAME_ARCADE) || __sinf&SINF_GRID!=0 || __sinf&SINF_GLOBAL!=0)*/ )
        {
            float x = ( chx * 10 ) / __GmapZoom + __GmapOffsetX,
                  y = ( chy * 10 ) / __GmapZoom + __GmapOffsetY;

            // int[]  drawData = {x, y, color, x+size, y, color, x+size, y+size, color, x, y+size, color, x, y, color};
            // if(size<=10)
            {
                int color = int( 0xAA00FFFF );

                int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + size - 1, y + size - 1, color, x + 1, y + size - 1, color, x + 1, y + 1, color };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }
            /*else
               {
                    uint8 alpha = MIN((2000.0f/size), 0x88);
                    int color = 0x0000FFFF|((alpha)<<24);

                    int[]  drawData = {x+1, y+1, color, x+size-1, y+1, color, x+1, y+size-1, color, x+size-1, y+size-1, color};
                    DrawPrimitive(DRAW_PRIMITIVE_TRIANGLESTRIP, drawData);
               }*/
        }

        if( @data_number != null )
        {
            uint len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0, iEnd = len * 0.5; i < iEnd; i++ )
                {
                    float x = ( data_number[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_number[ i * 2 ] >> 16 ) );

                    // bool drawTriangle=true;
                    // if(uint16(x/10)==chx && uint16(y/10)==chy) drawTriangle=false;

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF,
                        b = data_number[ i * 2 + 1 ] >> 16;
                    ;
                    // if(x<0 || y<0 || x>)
                    string str = a;
                    if( b > 0 )
                        str += "+" + ( b - a );

                    /*if(size<=10 || !drawTriangle)
                       {
                            int color = 0xAAFFAA00;

                            int[]  drawData = {x+1, y+1, color, x+size-1, y+1, color, x+size-1, y+size-1, color, x+1, y+size-1, color, x+1, y+1, color};
                            DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP, drawData);
                       }
                       else*/
                    {
                        uint8 alpha = MIN( ( 2000.0f / size ), 0x88 );
                        int   color = 0x00FFAA00 | ( ( alpha ) << 24 );

                        int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + 1, y + size - 1, color, x + size - 1, y + size - 1, color };
                        DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    }
                    // void GetTextInfo(string& text, int w, int h, int font, int flags, int& tw, int& th, int& lines)
                    // string& text – текст;
                    // int w, h, font, flags – высота, ширина, шрифт, флаги;
                    // int& tw, int& th, int& lines – итоговые ширина, высота и количество строк данного текста.
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            uint len = data_char.length();

            if( len > 0 && len % 3 != 1 )
            {
                for( uint i = 0; i < len / 3; i++ )
                {
                    float x = ( data_char[ i * 3 ] & 0xFFFF ),
                          y = ( ( data_char[ i * 3 ] >> 16 ) );

                    // bool drawTriangle=true;
                    // if(uint16(x/10)==chx && uint16(y/10)==chy) drawTriangle=false;

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;

                    string str = " ";
                    str[ 0 ] = data_char[ i * 3 + 2 ];
					
                    // void GetTextInfo(string& text, int w, int h, int font, int flags, int& tw, int& th, int& lines)
                    // string& text – текст;
                    // int w, h, font, flags – высота, ширина, шрифт, флаги;
                    // int& tw, int& th, int& lines – итоговые ширина, высота и количество строк данного текста.
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, data_char[ i * 3 + 1 ], font, flags );
                }
            }
        }
		
		if( @GlobalMapDebugStr !is null )
		{
			DrawText( GlobalMapDebugStr, 0,0, 100, 100, COLOR_LGREEN , FONT_BIG, 0 );
		}

        /*if(__sinf&SINF_GLOBAL!=0)*/
        {
            float x = ( __MouseX - __GmapOffsetX ) * __GmapZoom,
                  y = ( __MouseY - __GmapOffsetY ) * __GmapZoom;

            x -= x % 10;
            y -= y % 10;

			uint cellx = floor( x / 10 );
			uint celly = floor( y / 10 );
            x = x / __GmapZoom + __GmapOffsetX;
            y = y / __GmapZoom + __GmapOffsetY;

            if( size >= 5 )
            {
                int[]  drawData = { x + 1, y + 1, int COLOR_RED, x + size - 1, y + 1, int COLOR_RED, x + size - 1, y + size - 1, int COLOR_RED, x + 1, y + size - 1, int COLOR_RED, x + 1, y + 1, int COLOR_RED };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }
			if( @ch !is null )
			{
				if( ch.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER )
					DrawTxt( "" + cellx + " : " + celly + "\n" + GetCellBiomName( cellx, celly ),
						__MouseX + 30, __MouseY + 10, 200, 0, COLOR_LGREEN, font, FT_BORDERED );
				else DrawTxt( "" + cellx + " : " + celly,
						__MouseX + 30, __MouseY + 10, 200, 0, COLOR_LGREEN, font, FT_BORDERED );
			}
        }
    }

	if( layer == 5 )
    {
		//TestDirect3d(0);
		//DrawText( "d3d draw: "+TestDirect3d(0), 30, 30, 100, 20, COLOR_LGREEN, FONT_FALLOUT, FT_NOBREAK );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( int click )
{
    ThrowingMouseDown( click );
    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( int click )
{
    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( int x, int y )
{
    // x == __MouseX
    // y == __MouseY
    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.
bool AltDown = false;
bool key_down( uint8 key )
{
    if( __waiting )
    {
        CritterCl@ ch = GetChosen();
        if( @ch != null )
        {
            if( key == DIK_ESCAPE || key == DIK_SPACE )
            {
                if( ch.Stat[ ST_VAR5 ] > 0 )
                {
                    Message( "Antiflood." );
                }
                else
                    RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
            }
            return true;
        }
        else
            __waiting = false;
    }

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = true;
    if( AltDown && key == DIK_Q )
        SetEffect( EFFECT_2D, -1, "2D_Default.fx" );
    if( AltDown && key == DIK_W )
        SetEffect( EFFECT_2D, -1, "2D_BlackWhite.fx" );
    /*if(AltDown && key==DIK_E) SetEffect(EFFECT_2D, EFFECT_2D_TILE,"2D_DesGen.fx");
       if(AltDown && key==DIK_R) SetEffect(EFFECT_2D, EFFECT_2D_TILE,"2D_Default.fx");*/

    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = true;                                                // @pm menu

    if( key == DIK_Z )
        __MapZooming = true;

    /*
	//Frank Kost hotfix 19.03.2018 08:05 - убрал лишние хоткеи на приём наркоты. Это неРП, да к тому же эти хоткеи ИТАК используются для скриншотов и сохранения логов!
	if(key >= DIK_F1 && key <= DIK_F12){
	uint16 drugPid = DKPCheckDrugKey(key);
	if(drugPid != uint16(-1)){
			DKPUnsafeRun(drugPid);
		}
      }
*/
    ThrowingKeyDown( key );

    return GUI_KeyDown( key );
}

bool key_up( uint8 key )
{
    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = false;
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = false;                                                // @pm menu

    if( __waiting )
        return true;

    if( key == DIK_Z )
        __MapZooming = false;
    ThrowingKeyUp( key );

    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost()
{
    AltDown = false;
    __MapZooming = false;
    ThrowingInputLost();
    GUI_InputLost();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
    CritterCl@ ch = GetChosen();
    if( !(ch is null) && ( ch.Id == cr.Id ) && ( prevId != cr.Id ) )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );
    if( cr.Quest[ QST_GAMEMODE ] == GAME_ARCADE )
        cr.ContourColor = COLOR_CONTOUR_RED;

    // Try colorize from file
    // if(TryColorizeCritter(cr)) return;

    // Karma voting
    // cr.NameColor=COLOR_LIGHT(COLOR_CRITTER_NAME,cr.Stat[ST_PLAYER_KARMA]/10);

    // Good / Evil system (not used)
    // Also see _GoodEvilListChanged in parameters.fos
    /*CritterCl@ chosen=GetChosen();
       if(cr.IsPlayer() && not cr.IsChosen() && valid(chosen))
       {
            int crId=int(cr.Id);
            for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
            {
                    int id=chosen.GoodEvilList[i];
                    bool isEvil=FLAG(id,0x80000000);
                    if(isEvil) id^=0x80000000;

                    if(id==crId)
                    {
                            cr.NameColor=(isEvil?COLOR_RED:COLOR_GREEN);
                            cr.ContourColor=(isEvil?COLOR_CONTOUR_RED:COLOR_CONTOUR_GREEN);
                            break;
                    }
            }
       }*/
    //if( __fastPanel )
    //    HidePanel( true );
    // SaveFastPanel(false); //@pm menu
}

void critter_out( CritterCl& cr )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{}

void item_map_out( ItemCl& item )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("in");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

void item_inv_out( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("out");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("drag");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    // Detect radio
    if( color == 0xFFFFFFFE )
        message = ".." + message + "..";
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
	
	if( sayType == SAY_INFO )
	{
		Message( message );
		return false;
	}
	
	if( sayType == SAY_NORM )
    {
        if( findFirst( message, "*" ) != -1 )
        {
            uint countfirst = findFirst( message, "*" );
            if( findFirst( message, "*", countfirst ) != -1 )
            {
				while (findFirst( message, "**", 0 ) != -1)
				{
					message = ReplaceText(message, "**", "*");
				}
                string@[] strs;
                strs = split( message, "*" );
				for(uint i = 1; i < strs.length(); ++i )
				{
					strs[ i ] = "|0xFFBB33CC **" + strs[ i ] + "**|0xF8F993 ";
					++i;
				}
                message = join( strs, "" );
            }
        }
    }
	
    if( sayType >= SAY_RADIO )
        return true;                          // for work radio and service messages

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
    if( ( __sinf & SINF_INSIGHT ) != 0 )
        return true;

    // binyan - Language barrier
    CritterCl@ sender = GetCritter( critterId );
    if( sender is null )
        return false;

    if( sender.IsNpc() )
        return true;

    CritterCl@ receiver = GetChosen();
    if( @receiver !is null && receiver.Quest[ QST_MEDIUM ] == 0 && sender.Quest[ QST_MEDIUM ] == 0 )
    {
        int bs = sender.Stat[ ST_BODY_TYPE ];
        int br = receiver.Stat[ ST_BODY_TYPE ];
        if( message.length() > 1 )
        {
            if( ( bs == br && bs != BT_PLANT ) ||
                ( ( ( bs >= BT_MEN && bs < BT_BRAHMIN ) || bs == BT_ROBOT || bs == BT_BIG_BAD_BOSS ) && ( ( br >= BT_MEN && br < BT_BRAHMIN ) || br == BT_ROBOT || br == BT_BIG_BAD_BOSS ) ) ||
                ( ( bs == BT_MANTI || bs == BT_RADSCORPION || bs == BT_GIANT_ANT || bs == BT_GIANT_BEETLE || bs == BT_GIANT_WASP ) && ( br == BT_MANTI || br == BT_RADSCORPION || br == BT_GIANT_ANT || br == BT_GIANT_BEETLE || br == BT_GIANT_WASP ) ) )
                return true;
        }

        if( bs == BT_ZOMBIE )
        {
            if( sender.IsDead() )
                return false;
            string@ msg = GenerateZombieSpeech( sayType );
            if( msg !is null && msg.length() > 0 )
                message = msg;
        }
        else
        {
            sayType = SAY_EMOTE;
            switch( bs )
            {
            case BT_MEN:
                message = "Говорит";
                break;
            case BT_WOMEN:
                message = "Говорит";
                break;
            case BT_CHILDREN:
                message = "Говорит";
                break;
            case BT_SUPER_MUTANT:
                message = "Говорит";
                break;
            case BT_GHOUL:
                message = "Говорит";
                break;
            case BT_BRAHMIN:
                message = "Мычит";
                break;
            case BT_RADSCORPION:
                message = "Щелкает клешнями";
                break;
            case BT_RAT:
                message = "Пищит";
                break;
            case BT_FLOATER:
                message = "Хрипение";
                break;
            case BT_CENTAUR:
                message = "Хрипение";
                break;
            case BT_ROBOT:
                message = "Попикивает";
                break;
            case BT_DOG:
                message = "Лает";
                break;
            case BT_MANTI:
                message = "Стрекочет";
                break;
            case BT_DEADCLAW:
                message = "Рычит";
                break;
            case BT_PLANT:
                message = "";
                break;
            case BT_GECKO:
                message = "Шипит";
                break;
            case BT_ALIEN:
                message = "Хрипит";
                break;
            case BT_GIANT_ANT:
                message = "Стрекочет";
                break;
            case BT_BIG_BAD_BOSS:
                message = "Говорит";
                break;
            case BT_GIANT_BEETLE:
                message = "Стрекочет";
                break;
            case BT_GIANT_WASP:
                message = "Жужит";
                break;
            case MAX_BODY_TYPES:
                message = "";
                break;
            }
        }
    }
    return true;
}

import void DrawHives( uint8 hiveCount ) from "client_screen_additional";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
	RunServerScriptUnsafe( "general_unsafe@unsafe_checkAFK", 0, 0, 0, null, null );

	if( sayType == SAY_INFO )
	{
		Message( message );
		return false;
	}
    if( findFirst( message, "$arcade" ) == 0 )
        RunServerScriptUnsafe( "arcade_menu@unsafe_arcade", 0, 0, 0, null, null );

    // binyan - Hotkyes

    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
        __IsTextInput = true;

    if( findFirst( message, "~hotkeys" ) == 0 )
    {
        string@[] @ msg = split( message, " " );
        if( msg.length() == 1 )
            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        else
        {
            if( msg[ 1 ] == "on" )
                SetHotkeysUse( true );
            else if( msg[ 1 ] == "off" )
                SetHotkeysUse( false );

            if( __IsHotkeysUse )
                __IsTextInput = true;
            ;

            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        }
        return false;
    }
    // /////////////////////////////////////////////

	string[] effect = { "", "сквозь помехи", "басовито", "тихо", "громко", "звонко", "пискляво", "картаво", "шепеляво", "нежно", "страстно", "с отдышкой", "пьяно", "прокуренно", "невнятно", "строго", "резко", "хрипло", "недовольно", "радостно", "упрямо", "ворчливо", "шепотом", "недовольно", "картаво", "уверенно", "неуверенно", "смело", "настойчиво", "робко", "чеканя слова", "быстро", "медленно", "неторопливо", "торопливо", "неразборчиво", "издалека", "нараспев", "монотонно" };
	
	if( message[ 0 ] == '%' ) // ДАЙСЫ
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = { "S", "P", "E", "C", "I", "A", "L" };
				p0 = letters.find( valuesStr[ 1 ] ) + 1;
			}
		}
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}
		
		CritterCl@ chosen = GetChosen();
		CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
		if( chosen.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER && valid( target ) )
		{
			int[] vals = { p0, p1, p2, target.Id };
			RunServerScriptUnsafe( "test@unsafe_rolling_GM", 0, 0, 0, null, vals );
			return false;
		}
		RunServerScriptUnsafe( "test@unsafe_rolling", p0, p1, p2, null, null );
		Log("Дошло");
		return false;
	}
	
    if( message[ 0 ] == '~' ) // Command
    {
        /*if(message=="~names")
           {
                InitNameColorizing();
                Message("Names colorizer refreshed.");
                return false;
           }*/
/*
                if(message=="~newmenu")
                {
                        __mouse3Use = (__mouse3Use ? false : true);
                        Message("newmenu for critters : "+(__mouse3Use ? "On" : "Off"));
                        return false;
                }
 */
        if( message == "~fastpanel" )
        {
            __fastPanel = ( __fastPanel ? false : true );
            HidePanel( false );
            // HidePanel();
            if( __fastPanel )
                RunServerScriptUnsafe( "general_unsafe@unsafe_send_fastpanel", 1, 0, 0, "", null );
            //Message( "fastpanel : " + ( __fastPanel ? "On" : "Off" ) );
            // HidePanel();
            return false;
        }
		
		if( message == "~trap" ) 
		{
			RunServerScriptUnsafe( "general_unsafe@unsafe_make_trap", 0, 0, 0, "", null );
		}
		

        if( message == "~gmhot" )
        {
            __mobhotkeys = ( __mobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __mobhotkeys ? "On" : "Off" ) );
            return false;
        }
        
		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }

        if( message == "~mobhot" )
        {
            __usermobhotkeys = ( __usermobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __usermobhotkeys ? "On" : "Off" ) );
            return false;
        }

        if( message == "~teach" )
        {
            CritterCl @ choo = GetChosen();
            if( @choo is null || choo.Quest[ QST_GAMEMODE ] != GAME_ADVENTURE )
            {
                Message( "Запрещено не квентовым персонажам." );
                return false;
            }
            if( choo.Quest[ QST_GAMEMODE ] == GAME_START )
            {
                Message( "Запрещено до выбора режима игры." );
                return false;
            }
			if( choo.Stat[ ST_LEVEL ] < 12)
            {
                Message( "Запрещено до достижения 12го уровня." );
                return false;
            }
            ShowScreen( CLIENT_SCREEN_TEACH, 0, 0, 0 );
            return false;
        }
		/*
		if( message == "~rush" ) 
		{
			Message("Вы чувствуете прилив адреналина.");
			RunServerScriptUnsafe("debug@unsafe_SetRush", 1, 0, 0, null, null );
		}
		if( message == "~calm" ) 
		{
			Message("Вы успокаиваете себя.");
			RunServerScriptUnsafe("debug@unsafe_SetRush", -1, 0, 0, null, null );
		}
		*/
		if( message[0] == '~' ) 
		{
			
			string@[]@ parts = split( message, " " );

			if( parts[0] == "~desc" ) 
			{
				string text = "";
				int l = parts[0].length();
				if( parts.length() > 1 ) text = substring( message, l, message.length() - l );
				RunServerScriptUnsafe( "general_unsafe@unsafe_newPopup", 0, 0, 0, text, null ); 
				return false; 
			}
			
			if( parts[0] == "~silent" ) 
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_silent", 0, 0, 0, "", null ); 
				return false; 
			}
			
			if( parts[0] == "~afk" ) 
			{
				string text = "";
				int l = parts[0].length();
				if( parts.length() > 1 ) text = substring( message, l, message.length() - l );
				RunServerScriptUnsafe( "general_unsafe@unsafe_afk", 0, 0, 0, text, null ); 
				return false; 
			}
			
			if( parts[0] == "~lex" ) 
			{
				string text = "";
				int l = parts[0].length();
				if( parts.length() > 1 ) text = substring( message, l, message.length() - l );
				RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
				return false; 
			}

			if( parts[0] == "~voice" )
			{
				if( parts.length() != 2 ) { Message("Неверный формат вызова команды! Введите лишь одно число после команды!"); return false; }
				int number = 0;
				if(!StrToInt( parts[ 1 ], number )) {
					Message("Неверный формат вызова команды! Вы должны ввести число от 0 до " + (effect.length()-1) + "!"); return false;
				}
				RunServerScriptUnsafe("general_unsafe@unsafe_setKarma", number, 0, 0, null, null );
				if(number == 0) Message( "Вы стали говорить нормально." );
				else Message( "Вы изменили манеру речи по рации на \"" + effect[number] + "\"." );
				return false;
			}
			if( parts[0] == "~voices" ) 
			{
				if( parts.length() != 1 ) { Message("Неверный формат вызова команды! Не мудрите, просто пишите её без аргументов!"); return false; }
				string output = "Список доступных манер речи:\n";
				for(uint i = 0, iEnd = effect.length(); i<iEnd;i++)
					output += i + ") " + effect[i] + ".\n";
				Message(output);
				return false;
			}
			
			if( parts[0] == "~sp" || parts[0] == "~pp" ) 
			{
				CritterCl@ chosen = GetChosen();
				if( parts.length() != 2 )
				{
					Message("Неверный формат вызова команды! Введите лишь одно число после команды!");
					return false;
				}
				int number = 0;
				if( parts[ 1 ].length() > 3 )
				{
					Message("Для конвертации опыта требуется ввести число в пределах от 1 до 999!");
					return false;
				}
				if( !StrToInt( parts[ 1 ], number ) )
				{	
					Message("Для конвертации опыта требуется ввести целочисленное число!");
					return false;
				}
				if( number <= 0 ) 
				{
					Message("Для конвертации опыта требуется ввести положительное число!");
					return false;
				}
				if( chosen.Stat[ ST_LEVEL ] < 12 ) 
				{
					Message("Для конвертации опыта небходимо иметь 12й уровень!");
					return false;
				}
				int PlayerExp = chosen.Stat[ ST_EXPERIENCE ] - 66000;
				int PlayerExp2 = chosen.Stat[ ST_EXPERIENCE ] - 66000;
				if( PlayerExp <= 0 ) 
				{
					Message("Для конвертации опыта небходимо иметь больше 66к опыта!");
					return false;
				}
				int cost = ( chosen.StatBase[ST_UNSPENT_SKILL_POINTS]+chosen.Skill [ SK_BIG_GUNS ] + chosen.Skill [ SK_SMALL_GUNS] + chosen.Skill [ SK_ENERGY_WEAPONS] + chosen.Skill [SK_UNARMED] +chosen.Skill[SK_MELEE_WEAPONS] + chosen.Skill [ SK_THROWING] + chosen.Skill [SK_FIRST_AID] + chosen.Skill [ SK_DOCTOR ] + chosen.Skill [ SK_SNEAK ] + chosen.Skill [ SK_LOCKPICK ] + chosen.Skill [ SK_STEAL] + chosen.Skill [ SK_TRAPS] + chosen.Skill [ SK_SCIENCE] + chosen.Skill [ SK_REPAIR ] + chosen.Skill [ SK_SPEECH] + chosen.Skill [SK_BARTER] + chosen.Skill [ SK_GAMBLING] + chosen.Skill [ SK_OUTDOORSMAN] );
				int cost2 = ( chosen.StatBase[ST_UNSPENT_PERKS] + chosen.Perk[PE_AWARENESS] + chosen.Perk[PE_FLOWER_CHILD] + chosen.Perk[PE_BOOKWORM] + chosen.Perk[PE_BONUS_HTH_ATTACKS] + chosen.Perk[PE_BONUS_HTH_DAMAGE] + chosen.Perk[PE_BONUS_MOVE] + chosen.Perk[PE_BONUS_RANGED_DAMAGE] + chosen.Perk[PE_BONUS_RATE_OF_FIRE] + chosen.Perk[PE_EARLIER_SEQUENCE] + chosen.Perk[PE_FASTER_HEALING] + chosen.Perk[PE_MORE_CRITICALS] + chosen.Perk[PE_RAD_RESISTANCE] + chosen.Perk[PE_TOUGHNESS] + chosen.Perk[PE_STRONG_BACK] + chosen.Perk[PE_SHARPSHOOTER] + chosen.Perk[PE_SILENT_RUNNING] + chosen.Perk[PE_SURVIVALIST] + chosen.Perk[PE_MASTER_TRADER] + chosen.Perk[PE_EDUCATED] + chosen.Perk[PE_HEALER] + chosen.Perk[PE_BETTER_CRITICALS] + chosen.Perk[PE_SLAYER] + chosen.Perk[PE_SNIPER] + chosen.Perk[PE_SILENT_DEATH] + chosen.Perk[PE_ACTION_BOY] + chosen.Perk[PE_LIFEGIVER] + chosen.Perk[PE_DODGER] + chosen.Perk[PE_SNAKEATER] + chosen.Perk[PE_MR_FIXIT] + chosen.Perk[PE_MEDIC] + chosen.Perk[PE_MASTER_THIEF] + chosen.Perk[PE_SPEAKER] + chosen.Perk[PE_HEAVE_HO] + chosen.Perk[PE_PICKPOCKET] + chosen.Perk[PE_GHOST] + chosen.Perk[PE_EXPLORER] + chosen.Perk[PE_PATHFINDER] + chosen.Perk[PE_SCOUT] + chosen.Perk[PE_RANGER] + chosen.Perk[PE_QUICK_POCKETS] + chosen.Perk[PE_SMOOTH_TALKER] + chosen.Perk[ PE_SWIFT_LEARNER] + chosen.Perk[PE_ADRENALINE_RUSH] + chosen.Perk[PE_CAUTIOUS_NATURE] + chosen.Perk[PE_COMPREHENSION] + chosen.Perk[PE_DEMOLITION_EXPERT] + chosen.Perk[PE_GAMBLER] + chosen.Perk[PE_HARMLESS] + chosen.Perk[PE_HTH_EVADE] + chosen.Perk[PE_KAMA_SUTRA_MASTER] + chosen.Perk[PE_KARMA_BEACON] + chosen.Perk[PE_LIGHT_STEP] + chosen.Perk[PE_LIVING_ANATOMY] + chosen.Perk[PE_MAGNETIC_PERSONALITY] + chosen.Perk[PE_NEGOTIATOR] + chosen.Perk[PE_PACK_RAT] + chosen.Perk[PE_PYROMANIAC] + chosen.Perk[PE_QUICK_RECOVERY] + chosen.Perk[PE_SALESMAN] + chosen.Perk[PE_STONEWALL] + chosen.Perk[PE_THIEF] + chosen.Perk[PE_WEAPON_HANDLING] + chosen.Perk[PE_TERMINATOR] + 1 ) *25000 ;
				PlayerExp /= cost; //exp points
				PlayerExp2 /=cost2;
				if( parts[0] == "~sp" ) 
				{
					if( number <= PlayerExp )
					{
						RunServerScriptUnsafe("debug@unsafe_ExpToSp", number, cost, 0, null, null );
						return true;
					}
					else 
					{
						Message("У вас недостаточно опыта для конвертации в скиллпоинты! Один скиллпоинт стоит " + cost + " единиц опыта.");
						return false;
					}
				}
				if( parts[0] == "~pp" ) 
				{
					if( number * cost2 + 66000 <= chosen.StatBase[ ST_EXPERIENCE ] ) 
					{
						RunServerScriptUnsafe("debug@unsafe_ExpToPp", number, cost2 , 0, null, null );
						return true;
					}
					else 
					{
						Message("У вас недостаточно опыта для конвертации в перкпоинты! Один перк стоит " + cost2 + " опыта.");
						return false;
					}
				}
			}
		}
		/*
        if( message == "~global" )
        {
            ShowScreen( CLIENT_SCREEN_WAYPOINTS, 0, 0, 0 );
            Message( "test" );
            // DrawHives(1);
            return false;
        }
        if( message == "~editway" )
        {
            __isEditWaypoint = ( __isEditWaypoint ? false : true );
            Message( "редактирование точек маршрута : " + ( __isEditWaypoint ? "выключено" : "включено" ) );
            // DrawHives(1);
            return false;
        }
		*/
		
		/*if(message == "~monitoritem")
		{
			ItemCl    @it = GetMonitorItem( __MouseX, __MouseY );
			if( @it !is null )
				Message( " " + it.Id );
		}*/
		
        if(message == "~gmmenu")
		{
			CritterCl@ chosen = GetChosen();
			if( @chosen !is null && chosen.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER )
			{
				uint16    x = __MouseX, y = __MouseY;
				CritterCl @cr = GetMonitorCritter( x, y );
				ItemCl    @it = GetMonitorItem( x, y );
				if( @cr !is null )
				{
					if( cr.IsPlayer() )
						RunServerScript( "gm@GM_PANNEL_CRITTER_PLAYER", cr.Id, 0, 0, null, null );                     // панель действий с игроком
					else
						RunServerScript( "gm@GM_PANNEL_CRITTER_NPC", cr.Id, 0, 0, null, null );                        // панель действий с нпц
				}
				else if( @it !is null )
					RunServerScript( "gm@GM_PANNEL_ITEM", it.Id, 0, 0, null, null );                       // панель действий с итемом
				else
				{
					uint16 hexX = 0, hexY = 0;
					GetMonitorHex( x, y, hexX, hexY );
					RunServerScript( "gm@GM_PANNEL_HEX", hexX, hexY, 0, null, null );                       // панель действий с гексом
				}
				return true;
			}
		}
        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
        return gm_msg( message );
    }


    CritterCl@ chosen = GetChosen();
    if( @chosen !is null && sayType< SAY_NETMSG && chosen.IsDead() && chosen.Anim2Dead > ANIM2_DEAD_BACK )
    {
        Message( "Мертвые не разговаривают." );
        return false;
    }

    if( sayType == SAY_NORM )
    {
        if( message.length() > 2 && ( message[ 0 ] == '/' || message[ 0 ] == '.' ) )
        {
            int  eraseCount = 1;
            int8 ch = message[ 1 ];
            if(     ch == 'к' || ch == 'К' || ch == 's' || ch == 'S' )
                sayType = SAY_SHOUT;
            else if( ch == 'э' || ch == 'Э' || ch == 'e' || ch == 'E' )
                sayType = SAY_EMOTE;
            else if( ch == 'ш' || ch == 'Ш' || ch == 'w' || ch == 'W' )
                sayType = SAY_WHISP;
            else if( ch == 'с' || ch == 'С' || ch == '$'           )
                sayType = SAY_SOCIAL;
            else if( ch == 'р' || ch == 'Р' || ch == 'r' || ch == 'R' )
                sayType = SAY_RADIO;

            if( sayType != SAY_NORM )
            {
                eraseCount++;
                if( message[ 2 ] == ' ' )
                    eraseCount++;
            }

            message = substring( message, eraseCount, message.length() - eraseCount );
        }
        else if(         // RegExp: [*]([^*].*[^*])[*]
            message.length() >= 4 && message[ 0 ] == '*' && message[ 1 ] != '*' &&
            message[ message.length() - 2 ] != '*' && message[ message.length() - 1 ] == '*' )
        {
            sayType = SAY_EMOTE;
            message = substring( message, 1, message.length() - 2 );
        }
    }
	
    if( sayType >= SAY_NORM && sayType <= SAY_RADIO )
    {
        for( uint i = 0, len = message.length(); i < len; i++ )
        {
            uint8 chr = message[ i ];
            if( chr < 32 || ( chr > 34 && chr < 42 ) || ( chr > 42 && chr < 44 ) || chr == 47 || ( chr > 57 && chr < 63 ) || chr == 64 || ( chr > 90 && chr < 97 ) || ( chr > 122 && chr < 192 && chr != 168 && chr != 184 ) )
            {
                Message( "В сообщениии есть запрещенные символы." );
                return false;
            }
        }
    }
	if( sayType == SAY_SHOUT )
	{ 
		//RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, chosen.Name + " " + chosen.Id + " !!!" + message + "!!!", null); 
		RunServerScriptUnsafe("test@unsafe_shout_all", 0, 0, 0, "!!!" + message + "!!!", null);
		//return false;
	}

/*	if(sayType==SAY_RADIO)
        {
                bool result=false;
                if (CallSignHook1(message, sayType, result)) return result;  //radio sign
                CritterCl@ chosen=GetChosen();
                if(not valid(chosen)) return false;
                ItemCl@ hand1=_CritGetItemHand(chosen);
                ItemCl@ hand2=_CritGetItemHandExt(chosen);
                if((not valid(hand1) || hand1.GetProtoId()!=PID_RADIO) && (not valid(hand2) || hand2.GetProtoId()!=PID_RADIO))
                {
                        Message(TEXTMSG_GAME,STR_RADIO_NOITEM);
                        return false;
                }

                if (CallSignHook2(message, sayType, result)) return result; //radio sign
        }
 */
    bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }
	
	if( sayType == SAY_RADIO ) {
		RunServerScriptUnsafe( "general_unsafe@unsafe_AutoEmote", 0, 0, 0, "говорит в рацию", null );	
		bool isMale = chosen.Stat[ ST_GENDER ] == GENDER_MALE;
		string[][] voice = { { "юный", "молодой", "взрослый", "старый" }, { "юная", "молодая", "взрослая", "старая" } };
		//string[] timbre = { "бас", "баритон", "тенор", "контральто", "меццо-сопрано", "сопрано", };
		int n = chosen.Stat[ ST_AGE ];
		int t = CLAMP( chosen.Stat[ST_KARMA], 0, int( effect.length() ) );
		if( n < 18 ) n = 0;
		else if( n < 26 ) n = 1;
		else if( n < 50 ) n = 2;
		else n = 3;
		message = "[" + voice[isMale ? 0 : 1][n] + ( t == 0 ? "" : ( ", " + effect[t] ) ) + "] " + message;
	}

    return result;
}

// binyan - Hex attack
int to_hit_hex()
{
    // Used only on empty hex and throwing weapon and rocket launchers
    CritterCl@ chosen = GetChosen();
    if( !chosen.IsLife() )
        return 0;
    CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
    if( valid( target ) )
        return 0;

    uint8      mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( weapon is null )
        return 0;
    uint    skillNum = _WeaponSkill( weapon, mode );
    int     dmgType = _WeaponDmgType( weapon, mode );

    ItemCl@ realWeapon = _CritGetItemHand( chosen );

    bool    isFlareGun = ( realWeapon.AmmoPid == PID_FLARE_GUN_AMMO ) && ( _WeaponModeUse( mode ) == 1 ); // pm added flare gun check

    bool    isRocket = false;
    if( valid( realWeapon ) )
        isRocket = ( realWeapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realWeapon.AmmoPid == PID_ROCKET_AP ) || ( realWeapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realWeapon.AmmoPid == PID_GRENADELAUNCHER_AMMO );

    if( !isFlareGun && !isRocket && ( skillNum != SK_THROWING || !( dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EMP || dmgType == DAMAGE_EXPLODE ) ) )
        return 0;

    if( valid( realWeapon ) && skillNum != SK_THROWING )
        if( realWeapon.AmmoCount == 0 )
            return 0;

    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );
    if( tx == 0 && ty == 0 )
        return 0;

    int    dist = GetDistantion( chosen.HexX, chosen.HexY, tx, ty );

    uint16 toHx = tx, toHy = ty;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( tx != toHx ) || ( ty != toHy ) )
        return 0;



    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );


    if( dist > wpnMaxDist )
        return 0;

    int toHit = int(chosen.Skill[ skillNum ]);
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;


    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance
    if( weaponPerk == WEAPON_PERK_LONG_RANGE )
        distmod1 = 4;
    else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = chosen.Stat[ ST_PERCEPTION ];
    int acc = dist;

    if( dist < distmod2 )
        acc += distmod2;
    else
    {
        if( chosen.IsPlayer() )
            acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
        else
            acc -= perception * distmod1;
    }

    if( -2 * perception > acc )
        acc = -2 * perception;

    acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

    if( acc >= 0 )
    {
        if( chosen.Damage[ DAMAGE_EYE ] != 0 )
            acc *= -12;
        else
            acc *= -4;
    }
    else
        acc *= -4;

    toHit += acc;
    blockers = GetCrittersPath( chosen.HexX, chosen.HexY, tx, ty, 0.0f, dist, FIND_LIFE, null ); // + map
    toHit -= 10 * blockers;


    if( chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;


    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;

}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int use = _WeaponModeUse( weaponMode );
    int hitLocation = _WeaponModeAim( weaponMode );
    if( use > 2 )
        return 0;

    if( target.IsDead() )
        return 0;
    if( !chosen.IsLife() )
        return 0;

    ItemCl@    realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
    int  skillVal = int(chosen.Skill[ skillNum ]);
    int  wpnMaxDist = _WeaponMaxDist( weapon, use );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
    uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
    // Roleplay
    // Добавляем плюсы к рассчётам за счёт вторичных навыков стрельбы.
    // Выше 150 навык таким образом не поднять, можно даже урезать до 100-120.
    // Но нормально стрелять теперь можно. Ура.
    if( weaponSubtype == WS_GUN )
    {
        // Log("Тип оружия - стрелковое. Используется " + skillNum + " скилл (200 - лёгкое, 201 - тяжелое, 202 - энерго)");
        // Log("Скилл стреляющего " + skillVal + ", а номер скилла - " + skillNum);
        if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            // Log("Скилл для текущего оружия - лёгкое оружие, навык криттера - " + chosen.Skill[skillNum]);
            skillVal += chosen.Skill[ SK_BIG_GUNS ] / 3;
            // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
            skillVal += chosen.Skill[ SK_ENERGY_WEAPONS ] / 2;
            // Log("Добавляем энергооружие, поделенное на 2, к вычислению, теперь скилл " + skillVal);
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal = SECONDARY_SKILLS_BONUS_CAP;                                              /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
            }
            // Log("Итоговый скилл для рассчётов " + skillVal);
        }

        if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            // Log("Скилл для текущего оружия - тяжелое оружие, навык криттера - " + chosen.Skill[skillNum]);
            skillVal += chosen.Skill[ SK_SMALL_GUNS ] / 3;
            // Log("Добавляем скилл лёгкого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
            skillVal += chosen.Skill[ SK_ENERGY_WEAPONS ] / 3;
            // Log("Добавляем энергооружие, поделенное на 3, к вычислению, теперь скилл " + skillVal);
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal = SECONDARY_SKILLS_BONUS_CAP;                                              /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
            }
            // Log("Итоговый скилл для рассчётов " + skillVal);
        }

        if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            // Log("Скилл для текущего оружия - энергетическое оружие, навык криттера - " + chosen.Skill[skillNum]);
            skillVal += chosen.Skill[ SK_SMALL_GUNS ] / 2;
            // Log("Добавляем скилл лёгкого оружия, поделенный на 2, к вычислению, теперь скилл " + skillVal);
            skillVal += chosen.Skill[ SK_BIG_GUNS ] / 3;
            // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal = SECONDARY_SKILLS_BONUS_CAP;                                              /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
            }
            // Log("Итоговый скилл для рассчётов " + skillVal);
        }
    }
    else
    {
        // Log("Тип оружия - нестрелковое. Используется " + skillNum + " скилл (203 - рукопашка, 204 - холодное, 205 - метательное)");
        if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            skillVal += chosen.Skill[ SK_THROWING ] / 3;
            skillVal += chosen.Skill[ SK_MELEE_WEAPONS ] / 2;
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                skillVal = SECONDARY_SKILLS_BONUS_CAP;
        }

        if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            skillVal += chosen.Skill[ SK_UNARMED ] / 2;
            skillVal += chosen.Skill[ SK_THROWING ] / 3;
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                skillVal = SECONDARY_SKILLS_BONUS_CAP;
        }

        if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
        {
            skillVal += chosen.Skill[ SK_UNARMED ] / 3;
            skillVal += chosen.Skill[ SK_MELEE_WEAPONS ] / 2;
            if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                skillVal = SECONDARY_SKILLS_BONUS_CAP;
        }
    }

    // Roleplay
    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
        return 0;

    int toHit = skillVal;
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        // cr.Say(SAY_NETMSG, "Applying range modifiers.");
        // ranged attack modifiers
        int distmod1 = 2; // used for initial weapon bonus
        int distmod2 = 0; // minimal distance
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
            distmod1 = 4;
        else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( chosen.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        // Map@ map = chosen.GetMap();
        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null ); // + map
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    } // end range modifiers

    if( !( weapon.Weapon_IsUnarmed ) && chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;

    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
        acmod += ammo.Ammo_ACMod;
    if( acmod > 0 )
        toHit -= acmod;
    // TODO: tohit+=15 if target is multihex
    // TODO: light penalty

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    if( target.IsKnockout() )
        toHit += 40;
    toHit += target.GetMultihex() * 15;

    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
        hitMod /= 2;
    toHit -= hitMod;
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result( uint[]& data )
{
    uint datalen = data.length();
    if( datalen == 0 )
        return;
    if( data[ 0 ] != datalen )
        return;

    uint current = 1;

    while( current < datalen )
    {
        int        damage = -1;
        uint       effect = 0;
        uint       loc = 0;
        int        message = -1;

        uint       mode = data[ current++ ];
        uint       who = data[ current++ ];
        uint       who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
        CritterCl@ chosen = GetChosen();
        CritterCl@ trueTarget = null;

        bool       self = ( who == GetChosen().Id );

        string     name = "error0";
        if( valid( cr ) )
        {
            if( !self )
                name = cr.Name;
            else
                name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
        }

        uint offset;
        if( self )
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 506;
            else
                offset = 556;
        }
        else
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 606;
            else
                offset = 706;
        }

        string result;

        // reading and preparing the data:
        switch( mode )
        {
        case CMSG_CRIT_MISS:
            effect = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_CRIT_MISS_DAMAGE:
            effect = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_HIT:
        case CMSG_HIT_DEAD:
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_AIMED_HIT:
        case CMSG_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT:
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT:
            loc = data[ current++ ];
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT_DEAD:
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_OOPS:
            who2 = data[ current++ ]; // who2 was hit instead of who
            // +2 "... was hit instead of you!"
            // +3 "... was hit instead of ...!"
            @trueTarget = GetCritter( who2 );
            if( self )
            {
                // It was original target
                result = GetMsgStr( TEXTMSG_COMBAT, cr.Stat[ ST_GENDER ] == GENDER_MALE ? 608 : 708 );
                string nameTrue = "error1";
                if( valid( trueTarget ) )
                    nameTrue = trueTarget.Name;
                result = ReplaceText( result, "%s", nameTrue );
            }
            else
            {
                // It was not original target
                result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
                if( who2 == GetChosen().Id )
                {
                    result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
                }
                else
                {
                    string nameTrue = "error1";
                    if( valid( trueTarget ) )
                        nameTrue = trueTarget.Name;
                    result = ReplaceText( result, "%s", nameTrue );
                }
                result = ReplaceText( result, "%s", name );
            }
            break;
        case CMSG_MISS:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_HIT_RANDOMLY:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
        default:
            break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;

        if( message != -1 && isVerbose )       // Must be critical hit
        {
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
        else if( effect != 0 )
        {
            offset -= 306;
            if( mode > CMSG_CRIT_MISS_DAMAGE )           // Hit flags
            {
                if( FLAG( effect, HF_KNOCKOUT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 0 ) );
                if( FLAG( effect, HF_KNOCKDOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 1 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 2 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 3 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 4 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 5 ) );
                if( FLAG( effect, HF_BLINDED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 6 ) );
                // if(FLAG(effect, HF_DEATH))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset     )); // This is handled elsewhere
                // if(FLAG(effect, HF_ON_FIRE))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, HF_BYPASS_ARMOR ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 11 ) );
                if( FLAG( effect, HF_DROPPED_WEAPON ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, HF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, HF_RANDOM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
            }
            else
            {
                if( FLAG( effect, MF_KNOCKED_DOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 1 ) );
                // if(FLAG(effect, MF_ON_FIRE))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, MF_WEAPON_EXPLODED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 12 ) );
                if( FLAG( effect, MF_WEAPON_DESTROYED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 13 ) );
                if( FLAG( effect, MF_WEAPON_DROPPED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, MF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, MF_HIT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 16 ) );
                if( FLAG( effect, MF_LOST_REST_OF_AMMO ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 17 ) );
                if( FLAG( effect, MF_FIRED_DUD_SHOT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 18 ) );
                if( FLAG( effect, MF_HURT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 19 ) );
                // if(FLAG(effect, MF_HIT_RANDOMLY))         ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 20)); // This is handled elsewhere
                if( FLAG( effect, MF_CRIPPLED_RANDOM_LIMB ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
                if( FLAG( effect, MF_WAS_KILLED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 7 ) );
            }
            offset += 306;
        }

        if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) );

        for( uint m = 0, n = ext.length(); m < n; m++ )
        {
            if( m == n - 1 )
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            else
                result += ", ";

            result += ext[ m ];
        }

        result += ".";

        Message( result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) + ".", FOMB_COMBAT_RESULT );

        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) )
        return "";
    string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += chosen.Name + "\n";
        result += "---------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
        result += "---------------------\n";

        ItemCl@ weaponMain = chosen.GetItem( 0, SLOT_HAND1 );
        if( valid( weaponMain ) )
        {
            int use = _WeaponModeUse( weaponMain.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponMain ) ) + "\n";

            if( weaponMain.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponMain.Proto, use ) + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponMain.Proto, use );
                if( _WeaponIsHtHAttack( weaponMain.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;

                if( _WeaponMaxDist( weaponMain.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponMain.Proto, use );
                    if( _WeaponSkill( weaponMain.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponMain.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponMain.AmmoCount            + "/";
                    result += weaponMain.Proto.Weapon_MaxAmmoCount  + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponMain.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND1, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }
        result += "---------------------\n";

        ItemCl@ weaponExt = chosen.GetItem( 0, SLOT_HAND2 );
        if( valid( weaponExt ) )
        {
            int use = _WeaponModeUse( weaponExt.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponExt ) ) + "\n";

            if( weaponExt.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponExt.Proto, use ) + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponExt.Proto, use );
                if( _WeaponIsHtHAttack( weaponExt.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;
                if( _WeaponMaxDist( weaponExt.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponExt.Proto, use );
                    if( _WeaponSkill( weaponExt.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponExt.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponExt.AmmoCount             + "/";
                    result += weaponExt.Proto.Weapon_MaxAmmoCount   + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponExt.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND2, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }

        result += GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + " ";
        result += ( chosen.ItemsWeight() / 1000 ) + "/";
        result += ( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000 ) + ".";
    }
    else if( descType == DESC_INVENTORY_SPECIAL )
    {
        offsX = 23;
        result += "\n\n";
        result += chosen.Stat[ ST_STRENGTH ] + "\n";
        result += chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += chosen.Stat[ ST_CHARISMA ] + "\n";
        result += chosen.Stat[ ST_INTELLECT ] + "\n";
        result += chosen.Stat[ ST_AGILITY ] + "\n";
        result += chosen.Stat[ ST_LUCK ];
    }
    else if( descType == DESC_INVENTORY_STATS )
    {
        offsX = 39;
        result += "\n\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += chosen.Stat[ ST_CURRENT_HP ] + "/" + chosen.Stat[ ST_MAX_LIFE ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_AC ) + " ";
        result += chosen.Stat[ ST_ARMOR_CLASS ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_LASER ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE );
    }
    else if( descType == DESC_INVENTORY_RESIST )
    {
        offsX = 103;
        result += "\n\n\n\n";
        result += chosen.Stat[ ST_NORMAL_ABSORB ] + "/" + chosen.Stat[ ST_NORMAL_RESIST ] + "%\n";
        result += chosen.Stat[ ST_LASER_ABSORB ] + "/" + chosen.Stat[ ST_LASER_RESIST ] + "%\n";
        result += chosen.Stat[ ST_FIRE_ABSORB ] + "/" + chosen.Stat[ ST_FIRE_RESIST ] + "%\n";
        result += chosen.Stat[ ST_PLASMA_ABSORB ] + "/" + chosen.Stat[ ST_PLASMA_RESIST ] + "%\n";
        result += chosen.Stat[ ST_EXPLODE_ABSORB ] + "/" + chosen.Stat[ ST_EXPLODE_RESIST ] + "%";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );

    string result;
	uint16 pid = item.GetProtoId();

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
        result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += " " + lex;
        }
        if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 0 && item.GetType() < 10 )
        {
            result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
        }
    }
    // Full info
    else
    {
        if( lookType == ITEM_LOOK_INVENTORY )
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + "\n";
        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += "" + lex + " ";
        }
        if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
            result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
        else
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );

        if( lookType != ITEM_LOOK_MAP )
        {

            // indefine bullshit
            /*
               CritterCl @ choo = GetChosen();
               if(choo is null) return "";

               if(item.GetIndefineValue() < choo.Param[item.GetIndefineStat()])
               {
             */
            if( pid < PID_FISH_SMALLEST || pid > PID_FISH_BIGGEST )
            {
                // Weight
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );
            }
            else
            {
                result += "\nРазмер: " + item.Val7 + " см.";
            }

            // Ammo load
            if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
            {
                result += "\n";
                string str = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
                str = ReplaceText( str, "VALUE",     item.AmmoCount );
                str = ReplaceText( str, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
                str = ReplaceText( str, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
                result += str;
            }

            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags    = item.BrokenFlags;
                uint8  brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                else
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );

                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );

                // Broken count
                CritterCl@ chosen = GetChosen();
                if( valid( chosen ) && chosen.Perk[ PE_MR_FIXIT ] != 0 )
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
            }

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
            
			// indefine bullshit
            /*
               }else
               {
                    result = "\nМусор.";
               }
             */
        }
    }
    // Format tags
    if( item.Lexems != "" )
        return FormatTags( result, item.Lexems );
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result;
    int    gender = cr.Stat[ ST_GENDER ];
    int    crType = cr.CrType;

    // Player
    if( cr.IsPlayer() )
    {
        // Only name
        if( lookType == CRITTER_ONLY_NAME )
        {
            // result="|0xff77ff22 "+cr.Name+" |0xffff0000 (Id:"+cr.Id+")\n|0xffAA55BB HexX: "+cr.HexX+"\n|0xff11ffff HexY: "+cr.HexY;		//cr.Name; // No change
            result = cr.Name;           // No change
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT )
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
            if( cr.Quest[ QST_GAMEMODE ] != GAME_ARCADE || ( ( __sinf & SINF_LOGIN ) != 0 ) )
            {
                if( cr.Name != "" )
                    result += cr.Name + ".";
                else
                    result += "???";
            }
            else
            {
                if( crType == 20 || crType == 21 || crType == 114 )
                    result += GetMsgStr( TEXTMSG_GAME, 10950 );
                else if( crType == 28 || crType == 29 || crType == 79 )
                    result += GetMsgStr( TEXTMSG_GAME, 10953 );
                else if( crType == 22 || crType == 59 )
                    result += GetMsgStr( TEXTMSG_GAME, 10952 );
                else if( crType == 25 )
                    result += GetMsgStr( TEXTMSG_GAME, 10951 );
                else if( crType == 15 )
                    result += GetMsgStr( TEXTMSG_GAME, 10954 );
                else if( crType == 19 )
                    result += GetMsgStr( TEXTMSG_GAME, 10955 );
                else if( crType == 23 )
                    result += GetMsgStr( TEXTMSG_GAME, 10956 );
                else if( crType == 70 || crType == 75 )
                    result += GetMsgStr( TEXTMSG_GAME, 10957 );
                else if( crType == 16 )
                    result += GetMsgStr( TEXTMSG_GAME, 10958 );
                else if( crType == 52 )
                    result += GetMsgStr( TEXTMSG_GAME, 10959 );
                else if( crType == 51 || crType == 60 || crType == 100 )
                    result += GetMsgStr( TEXTMSG_GAME, 10960 );
                else if( crType == 65 )
                    result += GetMsgStr( TEXTMSG_GAME, 10961 );
                else if( crType == 67 )
                    result += GetMsgStr( TEXTMSG_GAME, 10962 );
                else if( crType == 80 )
                    result += GetMsgStr( TEXTMSG_GAME, 10963 );
                else if( crType == 97 )
                    result += GetMsgStr( TEXTMSG_GAME, 10964 );
                else if( crType == 17 )
                    result += GetMsgStr( TEXTMSG_GAME, 10965 );
                else if( crType == 53 )
                    result += GetMsgStr( TEXTMSG_GAME, 10966 );
                else if( crType == 54 )
                    result += GetMsgStr( TEXTMSG_GAME, 10967 );
                else if( crType == 66 )
                    result += GetMsgStr( TEXTMSG_GAME, 10968 );
                else if( crType == 101 )
                    result += GetMsgStr( TEXTMSG_GAME, 10969 );
                else if( crType == 24 )
                    result += GetMsgStr( TEXTMSG_GAME, 10970 );
                else if( crType == 55 )
                    result += GetMsgStr( TEXTMSG_GAME, 10971 );
                else if( crType == 76 )
                    result += GetMsgStr( TEXTMSG_GAME, 10972 );
                else if( crType == 68 )
                    result += GetMsgStr( TEXTMSG_GAME, 10973 );
                else if( crType == 81 )
                    result += GetMsgStr( TEXTMSG_GAME, 10974 );
                else if( crType == 86 )
                    result += GetMsgStr( TEXTMSG_GAME, 10975 );
                result += ".";
            }
        }
        // Full info
        else
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
            // Age
            if( crType == 20 || crType == 21 || crType == 114 )
                result += GetMsgStr( TEXTMSG_GAME, 10950 );
            else if( crType == 28 || crType == 29 || crType == 79 )
                result += GetMsgStr( TEXTMSG_GAME, 10953 );
            else if( crType == 22 || crType == 59 )
                result += GetMsgStr( TEXTMSG_GAME, 10952 );
            else if( crType == 25 )
                result += GetMsgStr( TEXTMSG_GAME, 10951 );
            else if( crType == 15 )
                result += GetMsgStr( TEXTMSG_GAME, 10954 );
            else if( crType == 19 )
                result += GetMsgStr( TEXTMSG_GAME, 10955 );
            else if( crType == 23 )
                result += GetMsgStr( TEXTMSG_GAME, 10956 );
            else if( crType == 70 || crType == 75 )
                result += GetMsgStr( TEXTMSG_GAME, 10957 );
            else if( crType == 16 )
                result += GetMsgStr( TEXTMSG_GAME, 10958 );
            else if( crType == 52 )
                result += GetMsgStr( TEXTMSG_GAME, 10959 );
            else if( crType == 51 || crType == 60 || crType == 100 )
                result += GetMsgStr( TEXTMSG_GAME, 10960 );
            else if( crType == 65 )
                result += GetMsgStr( TEXTMSG_GAME, 10961 );
            else if( crType == 67 )
                result += GetMsgStr( TEXTMSG_GAME, 10962 );
            else if( crType == 80 )
                result += GetMsgStr( TEXTMSG_GAME, 10963 );
            else if( crType == 97 )
                result += GetMsgStr( TEXTMSG_GAME, 10964 );
            else if( crType == 17 )
                result += GetMsgStr( TEXTMSG_GAME, 10965 );
            else if( crType == 53 )
                result += GetMsgStr( TEXTMSG_GAME, 10966 );
            else if( crType == 54 )
                result += GetMsgStr( TEXTMSG_GAME, 10967 );
            else if( crType == 66 )
                result += GetMsgStr( TEXTMSG_GAME, 10968 );
            else if( crType == 101 )
                result += GetMsgStr( TEXTMSG_GAME, 10969 );
            else if( crType == 24 )
                result += GetMsgStr( TEXTMSG_GAME, 10970 );
            else if( crType == 55 )
                result += GetMsgStr( TEXTMSG_GAME, 10971 );
            else if( crType == 76 )
                result += GetMsgStr( TEXTMSG_GAME, 10972 );
            else if( crType == 68 )
                result += GetMsgStr( TEXTMSG_GAME, 10973 );
            else if( crType == 81 )
                result += GetMsgStr( TEXTMSG_GAME, 10974 );
            else if( crType == 86 )
                result += GetMsgStr( TEXTMSG_GAME, 10975 );
            else
            {
                uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( gender, cr.Stat[ ST_AGE ] ) );
                if( ageStr != 0 )
                    result += GetMsgStr( TEXTMSG_GAME, ageStr );
                else if( cr.Name == "" )
                    result += "???";
                else
                {
                    result += cr.Name;
                    result += ".";
                }
            }


/*			// Condition
                        if(IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_COND(gender,cr.Cond,cr.CondExt)))
                        {
                                result+=", ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_COND(gender,cr.Cond,cr.CondExt));
                        }

                        // Special
                        uint[] special;
                        for(uint i = 0; i < 7 ; i++)
                        {
                                if(not IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_SPEC(gender,i,cr.Stat[ST_STRENGTH+i]))) continue;
                                special.insertLast(i);
                        }

                        if(special.length()>0)
                        {
                                result+=". ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK2(gender));

                                for(uint i=0,j=special.length();i<j;i++)
                                {
                                        uint sp=special[i];
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_SPEC(gender,sp,cr.Stat[ST_STRENGTH+sp]));

                                        if(i==j-1) break;
                                        else if(i==j-2) result+=GetMsgStr(TEXTMSG_GAME,STR_AND);
                                        else result+=", ";
                                }
                        }

                        // Damage
                        uint[] damage;
                        for(uint i=0;i<7;i++)
                        {
                                if(cr.GetPerk(PE_DAMAGE_POISONED+i)!=0 && IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_DMG(gender,i)))
                                        damage.insertLast(i);
                        }

                        if(damage.length()>0)
                        {
                                result+=". ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK3(gender));

                                for(uint i=0,j=damage.length();i<j;i++)
                                {
                                        uint dmg=damage[i];
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_DMG(gender,dmg));

                                        if(i==j-1) break;
                                        else if(i==j-2) result+=GetMsgStr(TEXTMSG_GAME,STR_AND);
                                        else result+=", ";
                                }
                                result+=".";
                        }

                        // Perks
                        for(uint i = 0; i <= PE_SEPARATED_KARMA; i++)
                        {
                                if(cr.GetPerk(i)!=0 && IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_PERK(gender,i)))
                                {
                                        result+=" ";
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_PERK(gender,i));
                                }
                        }
                        if(result.length()>0 && result[result.length()-1]!='.') result+=".";*/
        }
    }
    // Npc
    else
    {
        uint   dlgId = cr.Stat[ ST_DIALOG_ID ];
        uint16 npcPid = cr.Pid;
        bool   defaultText = false;

        if( lookType == CRITTER_ONLY_NAME )
        {
            result = GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) );
			// Message( "------- " + result );
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT )
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO( dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }
        // Full info
        else
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO( dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }

        if( defaultText )
        {
            // Check standart text
            if( IsMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) )
            {
                if( cr.IsLife() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIFE ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsKnockout() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_KO ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsDead() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_DEAD ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
            }
            // Set default text
            else
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
            }
        }
    }

    // Additional description
    if( lookType == CRITTER_LOOK_FULL )
    {
        if( result.length() > 0 && result[ result.length() - 1 ] != '.' )
            result += ".";
        result += " ";

        CritterCl@ chosen = GetChosen();
        ItemCl@    item = cr.GetItem( 0, SLOT_HAND1 );
        ItemCl@    item2 = cr.GetItem( 0, SLOT_HAND2 );
        ItemCl@    item3 = cr.GetItem( 0, SLOT_ARMOR );
        if( valid( chosen ) && chosen.Perk[ PE_AWARENESS ] >= 2 ) // GM AWARNESS
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_HP( gender ) );
            result = ReplaceText( result, "CUR", cr.Stat[ ST_CURRENT_HP ] );
            result = ReplaceText( result, "MAX", cr.Stat[ ST_MAX_LIFE ] );

            if( _CritIsInjured( cr ) )
            {
                if( valid( item ) )
                    result += ", ";
                else
                    result += GetMsgStr( TEXTMSG_GAME, STR_AND );

                if( cr.Damage[ DAMAGE_EYE ] != 0 )
                    result += "повреждены глаза, ";
                if( cr.Damage[ DAMAGE_RIGHT_ARM ] != 0 )
                    result += "повреждена правая рука, ";
                if( cr.Damage[ DAMAGE_LEFT_ARM ] != 0 )
                    result += "повреждена левая рука, ";
                if( cr.Damage[ DAMAGE_RIGHT_LEG ] != 0 )
                    result += "повреждена правая нога, ";
                if( cr.Damage[ DAMAGE_LEFT_LEG ] != 0 )
                    result += "повреждена левая нога, ";

                // result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_LIMBS(gender,false));
            }


            if( valid( item ) )
            {
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    if( item.Proto.Weapon_MaxAmmoCount == 0 )
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                    }
                    else
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP_AMMO );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                        result = ReplaceText( result, "CUR", item.AmmoCount );
                        result = ReplaceText( result, "MAX", item.Proto.Weapon_MaxAmmoCount );
                        result = ReplaceText( result, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
                    }
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }
            if( valid( item2 ) )
            {
                if( item2.GetType() == ITEM_TYPE_WEAPON )
                {
                    if( item2.Proto.Weapon_MaxAmmoCount == 0 )
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                    }
                    else
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP_AMMO );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                        result = ReplaceText( result, "CUR", item2.AmmoCount );
                        result = ReplaceText( result, "MAX", item2.Proto.Weapon_MaxAmmoCount );
                        result = ReplaceText( result, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item2.Proto.Weapon_Caliber ) ) );
                    }
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                }
            }
            if( valid( item3 ) )
            {
                if( gender == GENDER_FEMALE )
                    result += ", на ней ";
                else
                    result += ", на нем ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item3 ) );
            }
        }

        else if( valid( chosen ) && chosen.Perk[ PE_AWARENESS ] == 1 ) // Awareness
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_HP( gender ) );
            result = ReplaceText( result, "CUR", cr.Stat[ ST_CURRENT_HP ] );
            result = ReplaceText( result, "MAX", cr.Stat[ ST_MAX_LIFE ] );

            if( _CritIsInjured( cr ) )
            {
                if( valid( item ) )
                    result += ", ";
                else
                    result += GetMsgStr( TEXTMSG_GAME, STR_AND );

                if( cr.Damage[ DAMAGE_EYE ] != 0 )
                    result += "повреждены глаза, ";
                if( cr.Damage[ DAMAGE_RIGHT_ARM ] != 0 )
                    result += "повреждена правая рука, ";
                if( cr.Damage[ DAMAGE_LEFT_ARM ] != 0 )
                    result += "повреждена левая рука, ";
                if( cr.Damage[ DAMAGE_RIGHT_LEG ] != 0 )
                    result += "повреждена правая нога, ";
                if( cr.Damage[ DAMAGE_LEFT_LEG ] != 0 )
                    result += "повреждена левая нога, ";

                // result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_LIMBS(gender,false));
            }
            if( valid( item ) )
            {
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                    result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }

            if( valid( item2 ) )
            {
                result += " и ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) );
            }
            if( valid( item3 ) )
            {
                if( gender == GENDER_FEMALE )
                    result += ", на ней ";
                else
                    result += ", на нем ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item3 ) );
            }
        }
        else         // Simple
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );

            int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
            if( cr.IsDead() )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
            else if( hp_proc < 34 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) );
            else if( hp_proc < 67 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) );
            else if( hp_proc < 100 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) );
            else
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) );

            if( _CritIsInjured( cr ) )
            {
                if( hp_proc < 90 )
                    result += GetMsgStr( TEXTMSG_GAME, STR_AND );
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) );
                if( cr.Damage[ DAMAGE_EYE ] != 0 )
                    result += "повреждены глаза, ";
                if( cr.Damage[ DAMAGE_RIGHT_ARM ] != 0 )
                    result += "повреждена правая рука, ";
                if( cr.Damage[ DAMAGE_LEFT_ARM ] != 0 )
                    result += "повреждена левая рука, ";
                if( cr.Damage[ DAMAGE_RIGHT_LEG ] != 0 )
                    result += "повреждена правая нога, ";
                if( cr.Damage[ DAMAGE_LEFT_LEG ] != 0 )
                    result += "повреждена левая нога, ";
            }
            if( valid( item ) )
            {
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                    result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }
        }
        if( valid( item3 ) && ( item3.GetProtoId() == PID_SANDROBE ) )
            result += ", лицо скрыто капюшоном";
        else
        {
            if( chosen.Trait[ TRAIT_BLOODY_MESS ] != 0 && chosen.Id != cr.Id )
            {
                switch( Random( 0, 9 ) )
                {
                case 0:
                    result += ", смотрит зло на вас";
                    break;
                case 1:
                    result += ", бормочет что-то нехорошее о вас";
                    break;
                case 2:
                    result += ", смотрит с ненавистью";
                    break;
                case 3:
                    result += ", насмехается над вами";
                    break;
                case 4:
                    result += ", смотрит презрительно";
                    break;
                case 5:
                    result += ", выглядит уродливо";
                    break;
                case 6:
                    result += ", коситься в вашу сторону";
                    break;
                case 7:
                    result += ", кажется хочет напасть";
                    break;
                case 8:
                    result += ", скалится на вас";
                    break;
                case 9:
                    result += ", шепчет сдохни";
                    break;
                }
            }
            else if( cr.IsPlayer() && chosen.Id != cr.Id )
            {
                if( cr.StatBase[ ST_STRENGTH ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", мощная";
                    else
                        result += ", мощный";
                }
                else if( cr.StatBase[ ST_STRENGTH ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", сильна";
                    else
                        result += ", силен";
                }
                else if( cr.StatBase[ ST_STRENGTH ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", немощная";
                    else
                        result += ", немощный";
                }
                else if( cr.StatBase[ ST_STRENGTH ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", слабая";
                    else
                        result += ", слабый";
                }
                if( cr.StatBase[ ST_ENDURANCE ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", крепко сбита";
                    else
                        result += ", крепко сбит";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", крепкая";
                    else
                        result += ", крепкий";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", хрупкая";
                    else
                        result += ", хрупкий";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", хилая";
                    else
                        result += ", хилый";
                }
                if( cr.StatBase[ ST_CHARISMA ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", харизматична";
                    else
                        result += ", харизматичен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", притягательна";
                    else
                        result += ", притягателен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] >= 7 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", привлекает внимание";
                    else
                        result += ", привлекает внимание";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", отвратительна";
                    else
                        result += ", отвратителен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 2 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", отталкивающа";
                    else
                        result += ", отталкивающ";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неприятна";
                    else
                        result += ", неприятен";
                }
                if( cr.StatBase[ ST_AGILITY ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", проворна";
                    else
                        result += ", проворен";
                }
                else if( cr.StatBase[ ST_AGILITY ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", ловкая";
                    else
                        result += ", ловкий";
                }
                else if( cr.StatBase[ ST_AGILITY ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неповоротливая";
                    else
                        result += ", неповоротливый";
                }
                else if( cr.StatBase[ ST_AGILITY ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неуклюжая";
                    else
                        result += ", неуклюжий";
                }
            }
            if( cr.Lexems != "" && cr.Quest[ QST_MEDIUM ] != 3 )
            {
                result += ", ";
                result += cr.Lexems;
            }
        }
        result += ".";
    }

    if( lookType == CRITTER_LOOK_SHORT && ( __sinf & SINF_CRID ) != 0 )
    {
        result += " |0xffff0000 ";
        result += cr.Id;
    }

    // Format tags
    if( cr.Lexems != "" )
        return FormatTags( result, cr.Lexems );

	// Message( "-<" + lookType + ">- " + result );
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos
void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& chosen, CritterCl& npc, bool sell )
{
    uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    float cost = GetProtoItem( pid ).Cost;

    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
        return 1;
	
	if( sell ) {
		if ( pid == PID_DARTS_LOW ) return 0;
	}

    if( !item.IsStackable() && ( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON ) )
	{
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
            cost *= 0.01;
        else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
            cost /= 3;
        else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
            cost /= 2;
        else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
            cost /= 1.4;
        else if( brokenCount > 0 )
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;

        if( itemType == ITEM_TYPE_WEAPON )
        {
            cost += GetProtoItem( item.AmmoPid ).Cost * item.AmmoCount;
        }
    }

    float MarkUp = ( 100 - ( chosen.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ] ) ) * 0.01;
	if( MarkUp < 0 ) MarkUp = 0; //manual float CLAMPing 
	if( MarkUp > 2 ) MarkUp = 2; //manual float CLAMPing 
	//Message( pid+  ") dS = " + MarkUp );
	//Message( pid+  ") sell = " + cost * (1/pow( 3, MarkUp )) );
	//Message( pid+  ") buy = " + cost * pow( 3, MarkUp ) );
	MarkUp = sell ? cost * (1/pow( 3, MarkUp )) : cost * pow( 3, MarkUp );
	//Message( pid+  ") actual = " + MarkUp );
	//Message( pid+  ") final = " + CLAMP( MarkUp, 1, 999999 ) );
	//Message( "\n");
	return CLAMP( MarkUp, 1, 999999 );
	/*
	Есть предел положительного бонуса от навыка: +100 от навыка торговца. buy x1 sell x1
	Есть предел отрицательного бонуса от навыка: -100 от навыка торговца. buy x9 sell x0.11(1)
	При нулевой разнице навыков цена продажи х3 а покупки х0.33(3)
	
	Оставил закомменченные сообщения для отладки цен.
	*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );

    #ifdef PLAYERS_3D
    Set3DRegistrationGender( data[ ST_GENDER ] );
    #endif
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );
    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( data );
    #endif

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
    // Not process locally called actions
    if( cr.IsChosen() && not localCall )
    {
        switch( action )
        {
        case ACTION_MOVE_ITEM:
        case ACTION_MOVE_ITEM_SWAP:
        // case ACTION_USE_ITEM: binyan - правка для действий по хоткеям
        case ACTION_DROP_ITEM:
        // case ACTION_USE_WEAPON:   binyan - правка для мяча
        // case ACTION_RELOAD_WEAPON: binyan - правка для действий по хоткеям
        case ACTION_USE_SKILL:
        // case ACTION_PICK_ITEM:
        // case ACTION_PICK_CRITTER:
        case ACTION_OPERATE_CONTAINER:
            return;             // Skip processing
        default:
            break;              // Processing
        }
    }

    uint8            mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );

    if( ( action >= ACTION_MOVE_ITEM && action <= ACTION_OPERATE_CONTAINER ) || action == ACTION_STANDUP )
        cr.Wait( __Breaktime );

    switch( action )
    {
    case ACTION_MOVE:
        // Not implemented
        // cr.Wait(move time);
        break;
    case ACTION_RUN:
        // Not implemented
        // cr.Wait(run time);
        break;
    case ACTION_MOVE_ITEM:
        if( cr.IsLife() )
        {
            if( proto.ProtoId == 585 )
                return;                        // Игнорируем перекладывание мяча в руку. binyan

            uint8 fromSlot = actionExt;
            uint8 toSlot = item.CritSlot;

            cr.ClearAnim();

            if( toSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
            else if( fromSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
            else
                cr.Animate( 0, ANIM2_SWITCH_ITEMS );
        }
        break;
    case ACTION_MOVE_ITEM_SWAP:
        break;
    case ACTION_USE_ITEM:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();

            if( proto.Type == ITEM_TYPE_WEAPON && FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) )
                cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
            else
                cr.Animate( 0, ANIM2_USE, item );
        }
        break;
    case ACTION_DROP_ITEM:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_PICKUP );
        }
        break;
    case ACTION_USE_WEAPON:
        // Log("Use weapon procedure (client)");
        if( localCall )
            return;
        if( cr.IsLife() && valid( proto ) )
        {
            int  use   = ( actionExt & 0xF );
            int  aim   = ( ( actionExt >> 4 ) & 0xF );
            bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );

            cr.ClearAnim();

            cr.Animate( 0, ANIM2_PREPARE_WEAPON );

            PlaySound( 'W', SOUND_WEAPON_USE, _WeaponSoundId( proto, use ), use != 1 ? '1' : '2' );
            cr.Animate( 0, _WeaponAnim2( proto, use ), item );

            if( fail )
                cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
            else
                cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
        }
        break;
    case ACTION_RELOAD_WEAPON:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();
            PlaySound( 'W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1' );
            cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
        }
        break;
    case ACTION_USE_SKILL:
        if( cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_PICK_ITEM:
        if( cr.IsLife() )
        {
            cr.ClearAnim();

            bool isGround = ( actionExt != 0 );

            if( !isGround )
            {
                if( !valid( proto ) )
                    break;
                isGround = proto.GroundLevel;
            }

            cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
        }
        break;
    case ACTION_PICK_CRITTER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();

            switch( actionExt )           // 0 - loot, 1 - steal, 2 - push
            {
            case 0:
                cr.Animate( 0, ANIM2_LOOT );
                break;
            // case 1: cr.Animate(0, ANIM2_STEAL); break;
            case 2:
                cr.Animate( 0, ANIM2_PUSH );
                break;
            case 3:
                cr.Animate( 0, ANIM2_STEAL );
                break;
            default:
                break;
            }
        }
        break;
    case ACTION_OPERATE_CONTAINER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            int transferType = actionExt / 10;
            int directionType = actionExt % 10;

            if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT )
                cr.Animate( 0, ANIM2_PICKUP );
            else
                cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_DODGE:
        if( not cr.IsAnimPlaying() && cr.IsLife() )
        {
            cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
        }
        break;
    case ACTION_DAMAGE:
        if( not cr.IsAnimPlaying() )
        {
            if( cr.IsLife() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
            else if( cr.IsKnockout() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        else
        {
            // Todo:
            // ANIM2_WALK_DAMAGE_FRONT
            // ANIM2_WALK_DAMAGE_BACK
            // ANIM2_LIMP_DAMAGE_FRONT
            // ANIM2_LIMP_DAMAGE_BACK
            // ANIM2_RUN_DAMAGE_FRONT
            // ANIM2_RUN_DAMAGE_BACK
        }
        break;
    case ACTION_DAMAGE_FORCE:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
        }
        else if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        break;
    case ACTION_KNOCKOUT:
        if( not cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_STANDUP:
        if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_FIDGET:
        if( cr.IsLife() && not cr.IsAnimPlaying() )
        {
            cr.Animate( 0, ANIM2_FIDGET );
        }
        break;
    case ACTION_DEAD:
        if( not cr.IsDead() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_CONNECT:
        // __tempFastText = "";
        break;
    case ACTION_DISCONNECT:
        __tempFastText = "";
        __fastPanelShow = false;
        __fastPanel = false;
        break;
    case ACTION_RESPAWN:
        break;
    case ACTION_REFRESH:
        if( __tempFastText != "" )
            LoadPanel( 2, 0, 0, "", null );
        break;
    default:
        break;
    }
}

import void LoadPanel( int p0, int p1, int p2, string@ word2, int[] @ p4 ) from "client_screen_fastpanel";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );

// #ifdef PLAYERS_3D
    // You must implement this pids
    #define PID_STRAWHAT             uint( -1 )      // Head slot
    #define PID_ARMIN_CAP            uint( -2 )      // Head slot
    #define PID_POWER_HELMET         uint( -3 )      // Head slot
    #define PID_MOTORCYCLE_HELMET    uint( -4 )      // Head slot
    #define PID_TIBBETS_PRISON       uint( -5 )      // Armor slot
    #define PID_VAULT_SUIT           uint( -6 )      // Armor slot

    // Change values
    uint8   mode = 0;
    uint16  armorPid   = ( valid( cr.GetSlotProto( SLOT_ARMOR, mode ) ) ? cr.GetSlotProto( SLOT_ARMOR, mode ).ProtoId : 0 );
    uint16  weapPid    = ( valid( item ) ? item.GetProtoId() : cr.GetSlotProto( SLOT_HAND1, mode ).ProtoId );
    uint16  weapExPid  = ( valid( cr.GetSlotProto( SLOT_HAND2, mode ) ) ? cr.GetSlotProto( SLOT_HAND2, mode ).ProtoId : 0 );
    ItemCl@ armorItem = cr.GetItem( 0, SLOT_ARMOR );
    ItemCl@ headItem  = null;

    #ifndef PLAYERS_3D_NO_HEAD
    uint16 headPid    = ( valid( cr.GetSlotProto( SLOT_HEAD,  mode ) ) ? cr.GetSlotProto( SLOT_HEAD,  mode ).ProtoId : 0 );
    @headItem         = cr.GetItem( 0, SLOT_HEAD );
    #endif
    #ifdef PLAYERS_3D_NO_HEAD
    uint16 headPid    = 0;
    #endif

    bool weapBigGun = false;
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }
    else
    {
        ItemCl@ weap = cr.GetItem( 0, SLOT_HAND1 );
        if( valid( weap ) && FLAG( weap.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }

    int rhandleAtr = 0;
    int lhandleAtr  = 0;
    int handsAtr = 0;
    int bodyAtr = 0;
    int feetAtr = 0;
    int headAtr = 0;
    int eyeAtr      = 0;
    int shoulderAtr = 0;
    int backAtr     = 0;
    int backpackAtr = 0;

    /*switch(armorPid)
       {
       case PID_LEATHER_JACKET:
            bodyAtr=ATTRIBUTE_Body_LeatherOutfit;
            handsAtr=ATTRIBUTE_Hands_LeatherOutfit; // ATTRIBUTE_Hands_LeatherOutfitGauntlet
            feetAtr=ATTRIBUTE_Feet_LeatherOutfit;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_LeatherOutfit;
            break;
       case PID_POWERED_ARMOR:
       case PID_HARDENED_POWER_ARMOR:
            bodyAtr=ATTRIBUTE_Body_PowerArmor;
            handsAtr=ATTRIBUTE_Hands_PowerArmor;
            feetAtr=ATTRIBUTE_Feet_PowerArmor;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_PowerArmor;
            headAtr     = ATTRIBUTE_Head_ArmingCap;
       #ifdef PLAYERS_3D_NO_HEAD
            headAtr     = ATTRIBUTE_Head_PowerArmor;
       #endif
            break;
       case PID_TIBBETS_PRISON:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            backAtr     = armorItem.Val5;
            break;
       case PID_VAULT_SUIT:
            bodyAtr     = ATTRIBUTE_Body_VaultSuit;
            feetAtr     = ATTRIBUTE_Feet_VaultSuit;
            backAtr     = armorItem.Val5;
            break;
            // Missed models, set some default clothes
       case PID_LEATHER_ARMOR:
       case PID_LEATHER_ARMOR_MK_II:
       case PID_CURED_LEATHER_ARMOR:
       case PID_METAL_ARMOR:
       case PID_METAL_ARMOR_MK_II:
       case PID_TESLA_ARMOR:
       case PID_COMBAT_ARMOR:
       case PID_COMBAT_ARMOR_MK_II:
       case PID_BROTHERHOOD_COMBAT_ARMOR:
       case PID_ADVANCED_POWER_ARMOR:
       case PID_ADVANCED_POWER_ARMOR_MK2:
       case PID_PURPLE_ROBE:
       case PID_KEEPBRIGE_ROBE:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            break;
       default:
            break;
       }*/

    // Temporary sets, mostly intended for work with PLAYERS_3D_NO_HEAD
    // Will be corrected as the development of the missing content
    switch( armorPid )
    {
    case PID_LEATHER_JACKET:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfit;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        break;

    case PID_POWERED_ARMOR:
    case PID_HARDENED_POWER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    case PID_TIBBETS_PRISON:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_JUMPSUIT:
    case PID_FAKE_JUMPSUIT:
    case PID_VAULT_SUIT:
        bodyAtr     = ATTRIBUTE_Body_VaultSuit;
        feetAtr     = ATTRIBUTE_Feet_VaultSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_LEATHER_ARMOR:
    case PID_LEATHER_ARMOR_MK_II:
    case PID_CURED_LEATHER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfitGauntlet;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
        break;

    case PID_METAL_ARMOR:
    case PID_METAL_ARMOR_MK_II:
    case PID_TESLA_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        break;

    case PID_COMBAT_ARMOR:
    case PID_COMBAT_ARMOR_MK_II:
    case PID_BROTHERHOOD_COMBAT_ARMOR:
    case PID_MIRELURK_ARMOR:
    case PID_BLACK_COMBAT_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_CombatArmor;
        handsAtr    = ATTRIBUTE_Hands_CombatArmor;
        feetAtr     = ATTRIBUTE_Feet_CombatArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_CombatArmor;
        #ifdef PLAYERS_3D_NO_HEAD
        headAtr     = ATTRIBUTE_Head_CombatArmor;
        #endif
        break;

    case PID_ADVANCED_POWER_ARMOR:
    case PID_ADVANCED_POWER_ARMOR_MK2:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;

    case PID_PURPLE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        break;
    case PID_KEEPBRIGE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_BLACK_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    default:
        break;
    }

    // Head
    switch( headPid )
    {
    case PID_STRAWHAT:
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_ARMIN_CAP:
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;
    case PID_POWER_HELMET:
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;
    case PID_MOTORCYCLE_HELMET:
        headAtr     = ( headItem.Val5 != 0 ? headItem.Val5 : ATTRIBUTE_Head_Motorcycle_White );
        break;
    default:
        break;
    }

    // Backpack
    if(     weapPid   == PID_BAG || weapPid   == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapPid   == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;
    else if( weapExPid == PID_BAG || weapExPid == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapExPid == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;

    // Hands
    if( weapPid == PID_POWER_FIST || weapPid == PID_MEGA_POWER_FIST )
    {
        handsAtr = ATTRIBUTE_Hands_PowerFist;
    }
    else if( weapBigGun )
    {
        rhandleAtr = GetHandleValue( weapPid );
    }
    else
    {
        rhandleAtr = GetHandleValue( weapPid );
        lhandleAtr = GetHandleValue( weapExPid );
    }

    #ifdef PLAYERS_3D_VAULT_SUITE
    bool isSkeleton = ( cr.CrType == CRTYPE_3D_MALE_SKELETON || cr.CrType == CRTYPE_3D_FEMALE_SKELETON );
    if( bodyAtr == 0 && !isSkeleton )
        bodyAtr = ATTRIBUTE_Body_VaultSuit;
    #endif

    cr.Anim3dLayer[ ANIM3D_LAYER_RHANDLE ] = rhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_LHANDLE ] = lhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BODY ] = bodyAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_FEET ] = feetAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HANDS ] = handsAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HEAD ] = headAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_SHOULDER ] = shoulderAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_EYE     ] = eyeAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACK    ] = backAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACKPACK ] = backpackAtr;

    // Set custom values
    for( uint i = ANIM3D_LAYER_SKIN; i <= ANIM3D_LAYER_BACKPACK; i++ )
        if( cr.Stat[ ST_ANIM3D_LAYERS + i ] != 0 )
            cr.Anim3dLayer[ i ] = cr.Stat[ ST_ANIM3D_LAYERS + i ];
// #endif
}

// #ifdef PLAYERS_3D
int GetHandleValue( uint16 pid )
{
    if( pid == 0 || ( pid >= 1000 && pid <= 1100 ) )
        return 0;

    int handle = 0;
    switch( pid )
    {
    case PID_ZIP_GUN:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_9MM_MAUSER:
        handle = ATTRIBUTE_Handle_Weapon_9mmAutoloader;
        break;
    case PID_10MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_14MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_DESERT_EAGLE:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader;
        break;
    case PID_DESERT_EAGLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader_GunExtClip;
        break;
    case PID_223_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_223Autoloader;
        break;
    case PID_44_MAGNUM_REVOLVER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_44_MAGNUM_SPEEDLOADER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_NEEDLER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_PK12_GAUSS_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SCOPED_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SPRINGER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SNIPER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_NIGHT_SCOPE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_HPFA:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_LE_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_JONNY_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_INDEPENDENT:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_M72_GAUSS_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SAWED_OFF_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_COMBAT_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_CAWS:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_PANCOR_JACKHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_10MM_SMG:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_P90C:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_TOMMY_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_G11:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_G11E:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_GREASE_GUN:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_FLAMER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_IMPROVED_FLAMETHROWER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower_FlamerExtTank;
        break;
    case PID_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_15mmArtemisRailGun;
        break;
    case PID_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_AVENGER_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_VINDICATOR_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_BOZAR:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LIGHT_SUPPORT_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_M60:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_MAGNETO_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_SOLAR_SCORCHER:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_LASER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_RIFLE_EXT_CAP:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_GATLING_LASER:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_ALIEN_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_PLASMA_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_PISTOL_EXT_CART:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_TURBO_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_YK32_PULSE_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_YK42B_PULSE_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_MOLOTOV_COCKTAIL:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_FRAG_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_PLASMA_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadePlasma;
        break;
    case PID_PULSE_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeEMP;
        break;
    case PID_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_ACTIVE_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_PLANT_SPIKE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_THROWING_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_ThrowingKnife;
        break;
    case PID_ROCK:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_GOLD_NUGGET:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_URANIUM_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_REFINED_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_COMBAT_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_LIL_JESUS_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_SHIV:
        handle = ATTRIBUTE_Handle_Weapon_Shiv;
        break;
    case PID_SWITCHBLADE:
        handle = ATTRIBUTE_Handle_Weapon_Switchblade;
        break;
    case PID_WAKIZASHI_BLADE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARP_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARPENED_POLE:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_AXE:
        handle = ATTRIBUTE_Handle_Weapon_Hatchet;
        break;
    case PID_CLUB:
        handle = ATTRIBUTE_Handle_Weapon_NightStick;
        break;
    case PID_CROWBAR:
        handle = ATTRIBUTE_Handle_Weapon_Crowbar;
        break;
    case PID_WRENCH:
        handle = ATTRIBUTE_Handle_Weapon_HeavyWrench;
        break;
    case PID_SLEDGEHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_LOUISVILLE_SLUGGER:
        handle = ATTRIBUTE_Handle_Weapon_Baseballbat;
        break;
    case PID_SUPER_SLEDGE:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_SUPER_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_RIPPER:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_BRASS_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_SPIKED_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_DYNAMITE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_PLASTIC_EXPLOSIVES:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_MINE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    // Player will never have this weapons anyway
    case PID_ROBO_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_PHAZER:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_FIRE_GECKO_FLAME_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_SPECIAL_BOXER_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_GUN_TURRET_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_EYEBALL_FIST_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_EYEBALL_FIST_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_HEAVY_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_END_BOSS_KIFE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_END_BOSS_PLASMA_GUN:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_HOLY_HAND_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    // Other items
    case PID_STIMPAK:
    case PID_RADAWAY:
    case PID_SUPER_STIMPAK:
    case PID_HYPO:
    case PID_PSYCHO:
    case PID_HYPO_POISON:
        handle = ATTRIBUTE_Handle_Item_FirstAidKit;
        break;
    case PID_LOCKPICKS:
    case PID_EXP_LOCKPICK_SET:
    case PID_ELECTRONIC_LOCKPICKS:
    case PID_ELEC_LOCKPICK_MKII:
        handle = ATTRIBUTE_Handle_Item_SecurityKit;
        break;
    case PID_MULTI_TOOL:
    case PID_SUPER_TOOL_KIT:
    case PID_OIL_CAN:
        handle = ATTRIBUTE_Handle_Item_Toolkit;
        break;
    // No handle
    case PID_POWER_FIST:
    case PID_MEGA_POWER_FIST:
    case PID_BAG:
    case PID_BROWN_BAG:
    case PID_BACKPACK:
        handle = 0;
        break;
    // Generic item
    default:
        handle = 0;
        break;
    }

    return handle;
}
// #endif

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    // Example
    // Disable showing of all weapons in USE mode:
    /*if(collection==ITEMS_BARTER_OPPONENT)
       {
            for(uint i=0,j=items.length();i<j;i++)
                    if(items[i].GetType()==ITEM_TYPE_WEAPON)
                            @items[i]=null;
       }*/

    if( collection == ITEMS_INVENTORY )
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
            switch( __inventoryCollection )
            {
            case 0:
                break;
            case 1:
                if( items[ i ].GetType() != ITEM_TYPE_WEAPON )
                    @items[ i ] = null;
                break;
            case 2:
                if( items[ i ].GetType() != ITEM_TYPE_AMMO )
                    @items[ i ] = null;
                break;
            case 3:
                if( items[ i ].GetType() != ITEM_TYPE_ARMOR )
                    @items[ i ] = null;
                break;
            case 4:
                if( items[ i ].GetType() != ITEM_TYPE_DRUG )
                    @items[ i ] = null;
                break;
            case 5:
                if( items[ i ].GetType() != ITEM_TYPE_MISC )
                    @items[ i ] = null;
                break;
            case 6:
                if( items[ i ].GetType() != ITEM_TYPE_KEY )
                    @items[ i ] = null;
                break;
            default:
                break;
            }
            // if(!items[i].IsCanUseByIndefine(choo)) @items[i] = null;
        }
    }

    // ShowItemByIndefineValue(items);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	filesystem fs;
    if( param1 == 0 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
				
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
		if( !fs.isDir( "adventurers\\" ) )
			fs.makeDir("adventurers\\");
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
		if( !fs.isDir( "adv_approved\\" ) )
			fs.makeDir("adv_approved\\");
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
		if( !fs.isDir( "adv_disapproved\\" ) )
			fs.makeDir("adv_disapproved\\");
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
		if( !fs.isDir( "logs\\" ) )
			fs.makeDir("logs\\");
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}


void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    string red = "|0xFFAA0000 ",
           green = "|0xFF008800 ";

    Message( "Информационные опции:" );
    Message( ( ( ( __sinf & SINF_LOGIN ) != 0 ) ? green : red ) + "Показывать логины игроков" );
    Message( ( ( ( __sinf & SINF_CRID ) != 0 ) ? green : red ) + "Показывать Id криттеров в <<Вы видите>>" );
    Message( ( ( ( __sinf & SINF_CRID_ON_HEAD ) != 0 ) ? green : red ) + "Показывать Id криттеров над головами" );
    Message( ( ( ( __sinf & SINF_CRID_CHAT ) != 0 ) ? green : red ) + "Показывать Id криттеров в сообщениях чата" );
    Message( ( ( ( __sinf & SINF_ITEMID ) != 0 ) ? green : red ) + "Показывать Id итемов" );
    Message( ( ( ( __sinf & SINF_HEX ) != 0 ) ? green : red ) + "Показывать координаты гекса" );
    Message( ( ( ( __sinf & SINF_INSIGHT ) != 0 ) ? green : red ) + "Показывать сообщения аркады" );
    Message( ( ( ( __sinf & SINF_SPRITES ) != 0 ) ? green : red ) + "Показывать информацию о спрайтах под курсором" );
    // Message((((__sinf&SINF_GLOBAL)!=0)?green:red)+"Показывать на глобале квадратный курсор.");
    // Message((((__sinf&SINF_GRID)!=0)?green:red)+"Показывать на глобале сетку.");

    updateAllNicks();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

// indefine bullshit
/*
   void ShowItemByIndefineValue(ItemCl@[]@ items)
   {
        CritterCl @ choo = GetChosen();
        if(choo is null) return;

        for(uint16 i = 0, len = items.length(); i < len; ++i)
        {
                if(items[i] is null) continue;

                ItemCl @ item = items[i];

                //Message("pid "+item.GetProtoId()+" id "+item.Id+" val "+item.GetIndefineValue());

                uint hash = GetIndefineSpriteHash(item, choo);
                if(hash != 0)	item.SetInvPic(hash);


        }

   }

   uint GetIndefineSpriteHash(ItemCl& item, CritterCl& cr)
   {
        if(!item.IsCanUseByIndefine(cr))
        {
                uint16  stat = item.GetIndefineStat(),
                        value = item.GetIndefineValue();
                string spriteName = "art\\inven\\pump2.frm";

                if(cr.Param[stat] - (value * 0.5) >= value)
                {
                        switch(stat)
                        {
                                case SK_SMALL_GUNS : spriteName = "art\\inven\\hrifle.frm"; break;
                                case SK_MELEE_WEAPONS : spriteName = "art\\inven\\oknife.frm"; break;
                                //case SK_BARTER : spri
                                default : break;
                        }
                }
                return GetStrHash(spriteName);
        }
   return 0;
   }
 */

#include "client_zomb.fos"

#define EXPBAR_POS_X       ( expbarPosX )
#define EXPBAR_POS_Y       ( expbarPosY )
#define EXPBAR_LINE_END    ( expbarLineEnd )

Sprite expbar,
       expbar_;

uint16 expbarPosX = 0, expbarPosY = 0, expbarLineEnd = 0;

void ExpBarSetPos()
{
    GetIfaceIniPos( "ExpBar", expbarPosX, expbarPosY, expbarLineEnd );

    expbar.Load( "bar1.png", int(PT_ART_INTRFACE) );
    expbar_.Load( "bar1_e.png", int(PT_ART_INTRFACE) );
}

void DrawExpBar()
{
    int[] drawData;

    CritterCl @ choo = GetChosen();
    if( choo is null )
        return;

    uint8  level = choo.StatBase[ ST_LEVEL ];
    uint   levelExp = NUMERICAL_NUMBER( level - 1 ) * 1000;

    uint16 exp = choo.StatBase[ ST_EXPERIENCE ] - levelExp,
           toLevelExp = NUMERICAL_NUMBER( level ) * 1000 - levelExp;

    float  expMod = exp * 100 / ( toLevelExp > 100 ? toLevelExp : 100 );

    uint16 time = choo.StatBase[ ST_EXPERIENCE_MULTIPLIER_TIME ];
    uint8  allTime = ( time ) & 0xFF,
           elapsedTime = ( time >> 8 ) & 0xFF;

    float  timeMod = elapsedTime * 100 / ( allTime > 0 ? allTime : 1 );

    uint16 r0 = 0x15,
           g0 = 0x1F,
           b0 = 0x00,

           r1 = 0x67,
           g1 = 0x60,
           b1 = 0x00;
/*
        switch(choo.StatBase[ST_EXPERIENCE_MULTIPLIER])
        {
                case 2: r0 = 0x14;
                        g0 = 0x1F;
                        b0 = 0x00;

                        r1 = 0x35;
                        g1 = 0x39;
                        b1 = 0x00;
                        break;
                case 3: r0 = 0x8F;
                        g0 = 0x6F;
                        b0 = 0x0;
                        break;
                case 4: r0 = 0x0;
                        g0 = 0x0;
                        b0 = 0xC8;
                        break;
                case 5: r0 = 0xC8;
                        g0 = 0x0;
                        b0 = 0x0;
                        break;
                default:break;
        }*/

/*
        for(uint16 i = 0; i < EXPBAR_LINE_HEIGH; ++i)
        {
                //uint8 k = i;

                uint16 tempY = EXPBAR_POS_Y - ((EXPBAR_POS_Y - EXPBAR_LINE_END) * (allTime > 0 ? timeMod * 0.01 :  expMod * 0.01));

                drawData.insertLast(982+i);
                drawData.insertLast(EXPBAR_LINE_START);
                drawData.insertLast(COLOR_RGB(r,g,b));

                drawData.insertLast(982+i);
                drawData.insertLast(tempY);
                drawData.insertLast(COLOR_RGB(r,g,b));


        }
 */

    uint16 tempY = ( ( EXPBAR_POS_Y - EXPBAR_LINE_END ) * ( allTime > 0 ? timeMod * 0.01 :  expMod * 0.01 ) );

    for( uint16 i = 0; i < tempY; ++i )
    {
        i += 3;

        drawData.insertLast( EXPBAR_POS_X );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 8 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );


    }

    DrawSprite( expbar.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
    DrawSprite( expbar_.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawText( "0" + choo.StatBase[ ST_EXPERIENCE_MULTIPLIER ], EXPBAR_POS_X - 20, EXPBAR_POS_Y + 30, 70, 10, COLOR_RGB( r1, g1, b1 ), FONT_NUM, 0 );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
        return;

    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
        return;

    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
        if( not StrToInt( valuesStr[ i ], values[ i ] ) )
            return;

    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

/*
   bool IsMouseOnGrid(int x, int y)
   {
      uint16 hexX = 0, hexY = 0, entHexX = 0, entHexY = 0;

      GetChosen().GetMap().GetEntireCoords(255, 0, entHexX, entHexY);
      GetMonitorHex(x, y, hexX, hexY);

      //if(
   }*/
bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit(){

	dkp_array.insertLast(DIK_F1);
	dkp_array.insertLast(PID_SUPER_STIMPAK);

	dkp_array.insertLast(DIK_F2);
	dkp_array.insertLast(PID_STIMPAK);

	dkp_array.insertLast(DIK_F3);
	dkp_array.insertLast(PID_PSYCHO);


	if(dkp_array.length() % 2 != 0) Log("dkp_array wring size.");
		else isDKPInit = true;
}

uint16 DKPCheckDrugKey(uint8 key){

	if(!isDKPInit) DKPInit();

	for(uint8 i = 0, j = dkp_array.length(); i < j; i++){
		if(dkp_array[i] == key && i % 2 == 0) return dkp_array[i+1];
	}

return uint16(-1);
}

void DKPUnsafeRun(uint16 drugPid){

	if(GetChosen().IsBusy()){Message("choo are busy."); return;}
	if(_CritCountItem(GetChosen(), drugPid) <= 0){Message("need more drugs."); return;}
	RunServerScriptUnsafe("main@unsafe_DKP", drugPid, 0, 0, null, null);
}

void ShowPopup( int popup_id, int param1, int param2, string@ default_text, int[] @ param4 ) {
	CritterCl@ chosen = GetChosen();
	if(!valid(chosen)) return;
    ItemCl@ popup = GetItem(popup_id);
	if(!valid(popup)) Message( default_text );
	string lexems(popup.Lexems);
	if( chosen.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER )
		RunServerScriptUnsafe( "main@unsafe_ShowFullPopupInfo", popup_id, 0, 0, lexems, null );
    else
		RunServerScriptUnsafe( "main@unsafe_ShowPopup", popup_id, 0, 0, lexems, null );
}

void Dismantling( int pid, int hand, int param2, string@ param3, int[] @ param4 ) {
	if( pid == 904 ) { Message("Тут больше нечего искать."); return; }
	bool isMale = ( GetChosen().StatBase[ ST_GENDER ] == GENDER_MALE ), Success = false, Looted = false;
	int resourcePID = 1;
	string SceneryName = strlwr( GetMsgStr( TEXTMSG_ITEM, pid * 100 ) ), ResourceName = "что-то";
	int[][] Sources = { 
		{ 0 }, 				{ PID_FLINT }, 				{ PID_ROCK },
		{ PID_MULTI_TOOL }, { PID_WOOD_PLANK }, 		{ PID_FIREWOOD },
		{ PID_MULTI_TOOL }, { PID_HLAM_MEH }, 			{ PID_BANKA_MEH },
		{ 0 }, 				{ PID_FIREWOOD }, 			{ PID_WOOD_PLANK },
		{ PID_LIGHTER },	{ PID_MEAT_JERKY }, 		{ PID_RAD_MEAT },
	};
	for( uint i = 0, iEnd = Sources.length() - 2; i < iEnd; i += 3 ) {
		if( Sources[i+2].find(pid) != -1 ) {
			if( ( Sources[i][0] != 0 && Sources[i][0] != hand ) ) {
				RunServerScriptUnsafe( "main@unsafe_SayText", SAY_NETMSG, 0, 0, "Возьмите в руки инструмент (" 
										+ strlwr( GetMsgStr( TEXTMSG_ITEM, Sources[i][0] * 100 ) ) + ").", null );
				return;
			}
			resourcePID = Sources[i+1][Random(0,Sources[i+1].length()-1)];
			ResourceName = strlwr( GetMsgStr( TEXTMSG_ITEM, resourcePID * 100 ) );
			Looted = Random(0,600) <= GetChosen().SkillBase[ SK_SCIENCE ] + GetChosen().SkillBase[ SK_REPAIR ] + GetChosen().SkillBase[ SK_OUTDOORSMAN ];
			Success = true;
			break;
		}
	}
	if(Looted) Message("Вы получили " + ResourceName + ".");
	else Message("Попытка не удалась." + (Success ? "" : " [" + pid + "]") );
	//Message( "Вы тщательно обработали " + SceneryName + "," 
	//	+ ( Success ? ( " и добыли " + ResourceName + ".") : ( " но ничего не смогли добыть. [" + pid + "]" ) ) );
	if( Success ) RunServerScriptUnsafe( "main@unsafe_Dismantling", resourcePID, pid, Looted == true ? 1 : 0, null, null );
	RunServerScriptUnsafe( "main@unsafe_SayText", SAY_EMOTE_ON_HEAD, 0, 0, "обрабатывает " + SceneryName, null );
}

void Harvesting( int pid, int hand, int param2, string@ param3, int[] @ param4 ) {
	bool isMale = ( GetChosen().StatBase[ ST_GENDER ] == GENDER_MALE ), Success = false, Looted = false;
	int resourcePID = 1;
	string SceneryName = strlwr( GetMsgStr( TEXTMSG_ITEM, pid * 100 ) ), ResourceName = "что-то";
	int[][] Sources = { 
		//Камни:    Инструмент, лут, пиды
		{ PID_SLEDGEHAMMER }, { PID_ROCK, PID_ROCK, PID_ROCK, PID_MINERAL, PID_FLINT, PID_FLINT, PID_METAL_ORE }, 
			{ 2074, 2075, 2078, 2079, 2080, 2093, 2278, 2279, 2280, 2281, 2430, 2431, 3273, 3803, 3805 },
		{ 0 }, { PID_ROCK, PID_FLINT }, 
			{ 2074, 2075, 2078, 2079, 2093, 2278, 2279, 2280, 2281, 2430, 2431, 3273, 3803, 3805 },
		//Вёдра, коробки и непустые бочки:
		{ PID_MULTI_TOOL }, { PID_CRAFT_M_JUNK, PID_CRAFT_M_BARS, PID_MEAT_JERKY, PID_HLAM_MEH, PID_HLAM2_MEH, PID_BANKA_MEH, PID_SPIKE_MEH, PID_TUBE }, 
			{ 2106, 2220, 2221, 2222, 2223, 2252, 2253, 2254, 2255, 2256, 2275, 2276, 2311, 2315, 4509, 4510, 4511, 4536, 4599, 4600 },
		//Деревья:
		{ 0 }, { 0, 0, PID_FIREWOOD },
			{ 2317, 2318, 2319, 2320, 2321, 2945, 2946, 2947 },
		//Коробки:
		{ 0 }, { PID_WOOD_PLANK, PID_FIREWOOD },
			{ 2220, 2221, 2222, 2223, 2273, 2274, 2275, 2276, 2401, 2402, 2403, 4509, 4510, 4511, 4535, 2302, 4536 },
		//Разный мелкий хлам:
		{ 0 }, { PID_EMPTY_JET, PID_BOTTLE_GLASS, PID_BOTTLE_EMPTY, PID_PART_OF_ROPE, PID_HYPODERMIC_NEEDLE, PID_REAL_BOTTLE_CAPS }, 
			{ 2106, 2315, 4599, 4600 },
		//Бутылки:
		{ 0 }, { PID_BOTTLE_GLASS, PID_BOTTLE_EMPTY, PID_REAL_BOTTLE_CAPS }, 
			{ 2312, 2313 },
		//Тряпки:
		{ PID_MULTI_TOOL }, { PID_CRAFT_L_LINT, PID_CRAFT_L_RAGS },
			{ 2206, 2207, 2208, 2209, 2210, 2211, 2271, 2272, 2277 },
		{ 0 }, { 0, 0, PID_CRAFT_L_LINT, PID_CRAFT_L_LINT, PID_CRAFT_L_RAGS },
			{ 2206, 2207, 2208, 2209, 2210, 2211, 2271, 2272, 2277 },
		//Трупы:
		{ 0 }, { PID_RAD_MEAT, PID_MEAT_JERKY, PID_CRAFT_L_RAGS },
			{ 2086, 2890 },
		//Трава:
		{ 0 }, { PID_BROC_FLOWER, PID_XANDER_ROOT },
			{ 2102, 2103, 2104, 2105, 2127, 2573, 2574 },
		//Капуста и фрукты:
		{ 0 }, { PID_CABBAGE, PID_MUTATED_FRUIT, 0, 0, 0, 0 },
			{ 2366, 2367 },
		//Кукуруза:
		{ 0 }, { PID_CORN,PID_MUTATED_FRUIT, 0, 0, 0, 0 },
			{ 2963, 2964, 2965, 2966, 2967, 2968 },
		//Радцвет:
		{ 0 }, { PID_SEED_RADCVET, /*PID_SEED_MARIJUANA, */PID_BROC_FLOWER, PID_XANDER_ROOT, PID_FLOWER },
			{ 2943, 2944 },
		//Мнем железо, ага
		{ PID_SLEDGEHAMMER }, { PID_CRAFT_M_JUNK, PID_CRAFT_M_BARS, 0, PID_BANKA_MEH, 0 },
			{ 2224, 2225, 2226, 4604 },
		{ PID_MULTI_TOOL },   {  PID_CRAFT_M_JUNK, PID_CRAFT_M_BARS, 0, PID_BANKA_MEH, 0 },	
			{ 2224, 2225, 2226, 4604 },
		//Имитация фермерства
		{ 0 }, {PID_BROC_FLOWER, PID_MUTATED_FRUIT}, {16800}, //БРОК
		{ 0 }, {PID_MUTATED_FRUIT, PID_XANDER_ROOT}, {16801}, //ЗАНДЕР
		{ 0 }, {PID_MUTATED_FRUIT, PID_CABBAGE}, {16802},//Капуста
		{ 0 }, {PID_MUTATED_FRUIT, PID_CORN}, {16803} , //Кукуруза
	};
	for( uint i = 0, iEnd = Sources.length() - 2; i < iEnd; i += 3 ) {
		if(Sources[i+2].find(pid) != -1 ) {
			if( ( Sources[i][0] != 0 && Sources[i][0] != hand ) ) {
				RunServerScriptUnsafe( "main@unsafe_SayText", SAY_NETMSG, 0, 0, "Можно использовать '" 
										+ strlwr( GetMsgStr( TEXTMSG_ITEM, Sources[i][0] * 100 ) ) + "'.", null );
				continue;
			}
			resourcePID = Sources[i+1][Random(0,Sources[i+1].length()-1)];
			if( resourcePID == 0 ) { Success = true; Looted = false; break; }
			ResourceName = strlwr( GetMsgStr( TEXTMSG_ITEM, resourcePID * 100 ) );
			//RunServerScriptUnsafe( "main@unsafe_SayText", SAY_EMOTE, 0, 0, ( isMale ? "нашёл" : "нашла" ) + " " + ResourceName, null );
			Looted = Random(0,600) <= GetChosen().SkillBase[ SK_SCIENCE ] + GetChosen().SkillBase[ SK_REPAIR ] + GetChosen().SkillBase[ SK_OUTDOORSMAN ];
			Success = true;
			break;
		}
	}
	if(Looted) Message("Вы нашли " + ResourceName + ".");
	else Message("Вы ничего не нашли здесь." + (Success ? "" : " [" + pid + "]") );
	//Message( "Вы тщательно исследуете " + SceneryName + "," 
	//	+ ( Looted ? ( " и находите " + ResourceName + ".") : ( " но ничего не находите. " + (Success ? "" : "[" + pid + "]") ) ) );
	if( Success ) RunServerScriptUnsafe( "main@unsafe_Harvesting", resourcePID, Looted ? 1 : 0, 0, null, null );
	RunServerScriptUnsafe( "main@unsafe_SayText", SAY_EMOTE_ON_HEAD, 0, 0, "осматривает " + SceneryName, null );
}