// Author: cvet, heX, Тринитротолуол, Tab10id
#include "_macros.fos"
#include "stdlib_h.fos"
#include "_npc_pids.fos"

// Возвращает размер группы (живых ее участников)
// размер береться вне зависимости от того лидер это или просто партиец

import void FlushScreen( Critter& cr, bool fadeOut, uint timeMs ) from "effects";
import bool FactionInGame( Critter& player, Critter@ npc, int faction, int number ) from "factions";
import void PackageAlarm( Critter& player, int destination ) from "factions";

//Записывает в лексему @lex moodValue@ значение LVAR_critter_mood
	//В диалоге используется лишь в ветвях а не ответах:
	//2 2000 dialog@dlg_MoodValue 1 @
	//Цифра 1 означает количество обрабатываемых лексем. [требует проверки!]
void dlg_MoodValue( Critter& player, Critter@ npc, string@ lexems ) {
	if(!valid(npc)) return;
	GameVar@ moodVar = GetLocalVar( LVAR_critter_mood, npc.Id );
	if(!valid(moodVar)) return;
	if(!valid(lexems)) @lexems = "";
	lexems += "$moodValue " + moodVar.GetValue();
}

//Рандомит настроение НПЦ в указанных пределах ( min, max)
	//В диалоге используется лишь в ответах:
	//2 2010 R _script dialog@r_MoodSetRandom 2 0 100 #
	//В примере, "правая" цифра 2 означает количество аргументов, min = 0, max = 100.
void r_MoodSetRandom(Critter& player, Critter@ npc, int min, int max) {
	if(!valid(npc)) return;
	GameVar@ moodVar = GetLocalVar( LVAR_critter_mood, npc.Id );
	if(!valid(moodVar)) return;
	moodVar = CLAMP( Random(min, max), moodVar.GetMin(), moodVar.GetMax());
}

//Меняет настроение НПЦ на введёное значение:
	//В диалоге используется лишь в ответах:
	//2 2020 R _script dialog@r_MoodSet 1 5 #
	//В примере, "правая" цифра 1 означает количество аргументов, value = 5.
void r_MoodSet(Critter& player, Critter@ npc, int value) {
	if(!valid(npc)) return;
	GameVar@ moodVar = GetLocalVar( LVAR_critter_mood, npc.Id );
	if(!valid(moodVar)) return;
	moodVar = CLAMP( value, moodVar.GetMin(), moodVar.GetMax());
}

//Сдвигает настроение НПЦ на введёную дельту:
	//В диалоге используется лишь в ответах:
	//2 2030 R _script dialog@r_MoodChange 1 1 #
	//2 2040 R _script dialog@r_MoodChange 1 -1 #
void r_MoodChange(Critter& player, Critter@ npc, int delta) {
	if(!valid(npc)) return;
	GameVar@ moodVar = GetLocalVar( LVAR_critter_mood, npc.Id );
	if(!valid(moodVar)) return;
	moodVar = CLAMP( moodVar.GetValue() + delta, moodVar.GetMin(), moodVar.GetMax());
}

#define MOOD_EQUAL 0
#define MOOD_EQUAL_LESS -1
#define MOOD_LESS -2
#define MOOD_EQUAL_MORE 1
#define MOOD_MORE 2
#define MOOD_POSITIVE 101
#define MOOD_NEGATIVE -101

bool d_MoodCheck(Critter& player, Critter@ npc, int checkType, int value) {
	if(!valid(npc)) return false;
	GameVar@ moodVar = GetLocalVar( LVAR_critter_mood, npc.Id );
	if(!valid(moodVar)) return false;
	int mood = moodVar.GetValue();
	switch(checkType) {
		case(MOOD_EQUAL): 		return mood == value;
		case(MOOD_EQUAL_LESS): 	return mood <= value;
		case(MOOD_LESS): 		return mood <  value;
		case(MOOD_EQUAL_MORE): 	return mood >= value;
		case(MOOD_MORE): 		return mood >  value;
		case(MOOD_POSITIVE): 	return mood > 0;
		case(MOOD_NEGATIVE): 	return mood < 0;
		default: 				return false;
	}
	return false;//На деле, эта строка не нужна.
}


bool d_GotPet(Critter& player, Critter@ npc, int val) {
	Critter@[] pets;
	for( uint i=0, iEnd = player.GetFollowGroup(FIND_LIFE,pets); i<iEnd; i++ ) {
		if( pets[i].CrType == uint( val ) ) return true;
	}
	return false;
}

bool d_GotSlave(Critter& player, Critter@ npc, int BODY_TYPE) {
    Critter@[] pets;
    for( uint i=0, iEnd = player.GetFollowGroup(FIND_LIFE,pets); i<iEnd; i++ ) {
        if( pets[i].IsPlayer() ) continue;
        if( pets[i].Stat[ ST_BODY_TYPE ] == BODY_TYPE ) return true;
    }
    return false;
}

void r_SellPet(Critter& player, Critter@ npc, int val) {
	Critter@[] pets;
	
	for( uint i=0, iEnd = player.GetFollowGroup(FIND_LIFE,pets); i<iEnd; i++ ) {
		if( pets[i].CrType == uint( val ) ) {
			DeleteNpc(pets[i]);
			return;
		}
	}
}

void r_SellSlave(Critter& player, Critter@ npc, int BODY_TYPE) {
	Critter@[] pets;
	
	for( uint i=0, iEnd = player.GetFollowGroup(FIND_LIFE,pets); i<iEnd; i++ ) {
		if( pets[i].IsPlayer() ) continue;
		if( pets[i].Stat[ ST_BODY_TYPE ] == BODY_TYPE ) {
			DeleteNpc(pets[i]);
			return;
		}
	}
}

bool d_GotTarget(Critter& player, Critter@ npc) {
	Critter@[] groups;
	player.GetFollowGroup(FIND_LIFE,groups);
	return groups.length() > 0 ;//(player.GetFollowLeader());
}

void r_JailTarget(Critter& player, Critter@ npc) {
	Critter@[] groups;
	player.GetFollowGroup(FIND_LIFE,groups);
	if( groups.length() == 0 ) return;
	Critter@ target = @groups[0];
	if(!valid(target) || !target.IsPlayer()) return;
	Map@ map = player.GetMap();
	uint8 temp_dir = Random(0, 5);
	uint16 hexX = 390, hexY = 405;
	for(uint i=0; i<6; i++) {
		hexX = 390; hexY = 405;
		map.MoveHexByDir (hexX, hexY, (temp_dir+i)%6, 2);
		if(map.IsHexPassed(hexX, hexY)) break;
	}
	Item@[] items;
	target.GetItems(SLOT_INV,items);
	target.GetItems(SLOT_HAND1,items);
	target.GetItems(SLOT_HAND2,items);
	MoveItems(items,player);
	target.TransitToMap(map.Id, hexX, hexY, 0);
}

bool d_GotJailed(Critter& player, Critter@ npc) {
	Critter@ jailed = player.GetFollowLeader();
	if(!valid(jailed)||jailed.GetMapId()!=player.GetMapId())return false;
	if( player.CountItem(PID_BOTTLE_CAPS) < 500 ) return false;
	return true;
}

void r_FreeJailed(Critter& player, Critter@ npc) {
	Critter@ jailed = player.GetFollowLeader();
	if(!valid(jailed)||jailed.GetMapId()!=player.GetMapId())return;
	_CritDeleteItem(player,PID_BOTTLE_CAPS,500);
	Map@ map = jailed.GetMap();
	uint8 temp_dir = Random(0, 5);
	uint16 hexX = 390, hexY = 390;
	for(uint i=0; i<6; i++) {
		hexX = 390; hexY = 390;
		map.MoveHexByDir (hexX, hexY, (temp_dir+i)%6, 2);
		if(map.IsHexPassed(hexX, hexY)) break;
	}
	jailed.TransitToMap(map.Id, hexX, hexY, 0);
}
 
int DFGroupCount( Critter& player, Critter@ npc )
{
    Critter @ leader;
    if( not valid( player.GetFollowLeader() ) ) // если у игрока нет лидера
        @leader = player;                       // тогда считаем что он и есть лидер
    else
        @leader = player.GetFollowLeader();     // иначе берем лидера

    Critter@[] groups;
    groups.insertLast( @leader );
    leader.GetFollowGroup( FIND_LIFE, groups );
    return groups.length();
}

// !/ Размер группы больше >=VAL
bool d_GroupCountMore( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) >= val;
}

bool d_GroupCountLess( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) < val;
}

// !/ У всех уровень больше >=VAL
// Проверка что все игроки в группе больше или равны указанному уровню.
bool d_GroupLevelMore( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] < val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

bool d_GroupLevelLess( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] > val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

// Игрок нуждаеться в лечении?
bool d_IsToHeal( Critter& player, Critter@ npc )
{
    return player.Stat[ ST_CURRENT_HP ] < player.Stat[ ST_MAX_LIFE ];
}

// Игроку известна эта локация?
bool d_IsLocationVisible( Critter& player, Critter@ npc, int LocNum )
{
    return player.IsKnownLoc( false, uint16( LocNum ) );
}

// Игроку НЕ известна эта локация?
bool d_IsLocationNotVisible( Critter& player, Critter@ npc, int LocNum )
{
    return not player.IsKnownLoc( false, uint16( LocNum ) );
}

// Есть зависимости от наркотиков?
bool d_IsAddict( Critter& player, Critter@ npc )
{
    for( uint i = ADDICTION_BEGIN; i <= ADDICTION_END; i++ )
        if( player.Addiction[ i ] != 0 )
            return true;
    return false;
}

// У игрока нет зависимостей от наркотиков?
bool d_IsNotAddict( Critter& player, Critter@ npc )
{
    return not d_IsAddict( player, npc );
}

// Игрок в группе? (лидер тоже считаеться)
bool d_GroupPresent( Critter& player, Critter@ npc )
{
    return DFGroupCount( player, npc ) > 1;
}

// Игрок НЕ в группе? (лидер тоже считаеться)
bool d_NotGroupPresent( Critter& player, Critter@ npc )
{
    return not d_GroupPresent( player, npc );
}

/** проверка на таймаут
   используйте функцию r_TimeoutSet для инициализации
   если таймаут кончился (или еще и не начинался)
   то функция вернет истинну (разрешит ответ)
   иначе вернет ложь (ответ будет скрыт)
 */
bool d_TimeoutCheck( Critter& player, Critter@ npc, int timeoutNumber )
{
    // GameVar@ x = GetGlobalVar(GVAR_inf_clinic_money);
    // Log("Money: " + x.GetValue());
    // GameVar@ y = GetGlobalVar(GVAR_inf_clinic_medicine);
    // Log("Medicine: " + y.GetValue());
    int variable = 0;
    // Log("TO_Number"+timeoutNumber);
    switch( timeoutNumber )
    {
    case 0:
        variable = LVAR_timeout;
        break;
    case 1:
        variable = LVAR_timeout1;
        break;
    case 2:
        variable = LVAR_timeout2;
        break;
    case 3:
        variable = LVAR_timeout3;
        break;
    case 4:
        variable = LVAR_timeout4;
        break;
    case 5:
        variable = LVAR_timeout5;
        break;
    case 6:
        variable = LVAR_timeout6;
        break;
    case 7:
        variable = LVAR_timeout7;
        break;
    case 8:
        variable = LVAR_timeout8;
        break;
    }
    GameVar@ t = GetLocalVar( variable, npc.Id );
    // Log("Timeout check demand, timeoutNumber = " +timeoutNumber+ ", timeoutVariable = "+variable+", timeout = "+uint(t.GetValue()));
    if( not valid( t ) )
        return true;       // таймаут еще и не начался
    if( __FullSecond >= uint( t.GetValue() ) )
        return true;       // таймаут истек
    else
        return false;      // таймаут еще жив
}

/**
        инверсия d_TimeoutCheck
 */
bool d_NotTimeoutCheck( Critter& player, Critter@ npc, int timeoutNumber )
{
    return not d_TimeoutCheck( player, npc, timeoutNumber );
}


// Проверка уникальной переменной - таймаута игрок-нпц
// Время прошло, или таймаут не назначался
bool d_canGive( Critter& player, Critter @ npc, int itemPID, int min ) 
{
    if( int( _CritCountItem( player, itemPID ) ) < min ) return false;
	if( !valid( npc ) ) return false;
	if( npc.Merc[ MERC_MASTER_ID ] < 50 ) return false;
    return true;
}

bool d_failGive( Critter& player, Critter @ npc, int itemPID, int min ) 
{
	return !d_canGive(player,npc,itemPID,min);
}

void r_genProps( Critter& player, Critter @ npc )
{
	if( !valid( npc ) ) return;
	npc.MercBase[ MERC_MASTER_ID ] = Random(1,100);
	//npc.Say( SAY_NORM, "" + npc.MercBase[ MERC_MASTER_ID ] );
}


void r_tryGive( Critter& player, Critter @ npc, int itemPID, int min )
{
	if( Random(1,100) < 50 ) {
		npc.Say( SAY_NORM, "Так, погодь секунду.." );
		return;
	}
    if( !valid( npc ) ) return;
	npc.Say( SAY_NORM, "Ага, давай сюда.." );
	Item@ item = player.GetItem( itemPID, -1 );
	if( @item !is null )
		_SubItem( item, uint( min ) );
}

// Проверка уникальной переменной - лояльность игрок-нпц
// Автор: Frank Kost
void r_showVar( Critter& player, Critter @ npc )
{
    GameVar@ friendshipandmagic = ::GetUnicumVar( UVAR_friendshipandmagic, player.Id, npc.Id );
    player.Say( SAY_NETMSG, "Ваша лояльность: " + friendshipandmagic.GetValue() );
}

// Проверка уникальной переменной - таймаута игрок-нпц
// Время прошло, или таймаут не назначался
bool d_TimeoutOk( Critter& player, Critter @ npc )
{
    if( !valid( npc ) )
        return false;
    GameVar @ to = GetUnicumVar( UVAR_uniq_timeout, player.Id, npc.Id );
    if( !valid( to ) )
        return false;
    uint time = to.GetValue();
    if( time == 0 )
        return true;
    return ( time < __FullSecond );
}

// Таймаут не закончился
bool d_NotTimeoutOk( Critter& player, Critter @ npc )
{
    return !d_TimeoutOk( player, npc );
}

bool d_CheckMonth( Critter& playe, Critter @npc, int monthFrom, int monthTo )
{
    return ( __Month <= monthTo && __Month >= monthFrom );
}

// Установка таймаута. value - время в минутах, через которое таймаут пройдет
void r_SetUniqTO( Critter& player, Critter @ npc, int value )
{
    if( !valid( npc ) )
        return;
    GameVar @ to = GetUnicumVar( UVAR_uniq_timeout, player.Id, npc.Id );
    if( !valid( to ) )
        return;
    to = value * 60 + __FullSecond;
}

// Отложенная всплывающая строка над нпц
void r_SayMessageDelayed( Critter& player, Critter @ npc, int strNum, int delaySeconds, int sayType )
{
    if( !valid( npc ) )
        return;
    uint[] values = { npc.Id, uint( sayType ), uint( strNum ) };
    CreateTimeEvent( __FullSecond + delaySeconds, "e_SayMessage", values, false );
}

uint e_SayMessage( uint[] @ values )
{
    if( values.length() < 3 )
        return 0;
    Critter @ cr = GetCritter( values[ 0 ] );
    if( !valid( cr ) )
        return 0;
    int did = cr.Stat[ ST_DIALOG_ID ];
    if( did == 0 )
        return 0;
    cr.SayMsg( values[ 1 ], TEXTMSG_DLG, DLGSTR( did, values[ 2 ] ) );
    return 0;
}

// Шпионаж
void dlg_TrySpy( Critter& player, Critter@ banker, string@ playerName )
{
    if( !valid( banker ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;

    uint     BankerDialog = banker.Stat[ ST_DIALOG_ID ];
    uint     DlgStr = 100;
    string   lexems = "$Victim " + playerName;

    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }

    if( player.Id == cr.Id )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 9 ) );
        return;
    }

    // Пол.
    if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 11 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 12 ) + "@";
    }

    // Репликации.
    if( cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] <= 2 )
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 13 ) + "@";
    }
    else if( cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] > 2 && cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] < 10 )
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 14 ) + "@";
    }
    else
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 15 ) + "@";
    }

    // Год рождения.
    lexems += "$Born " + ( __Year - cr.Stat[ ST_AGE ] );

    if( player.Skill[ SK_SPEECH ] >= 40 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ), lexems );
    }

    // Уровень.
    if( player.Skill[ SK_SPEECH ] >= 50 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        lexems += "$Level " + cr.Stat[ ST_LEVEL ];
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
    }

    // Карма.
    if( player.Skill[ SK_SPEECH ] >= 60 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        int[] Values = { -2147483647, -1000, -750, -500, -250, 250,     500,    750,    1000 };
        int[] Descs =   { 6125,                         6122,   6119, 6116, 6113, 6110, 6107, 6104, 6101 };
        int CurKarma = 0;
        for( uint i = 0; i < Values.length(); i++ )
        {
            if( int(cr.Stat[ ST_KARMA ]) >= Values[ i ] )
            {
                CurKarma = Descs[ i ];
            }
            else
            {
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_GAME, CurKarma );
    }

    // Статы.
    if( player.Skill[ SK_SPEECH ] >= 70 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        // Сила.
        if( cr.StatBase[ ST_STRENGTH ] < 4 )
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 16 ) + "@";
        }
        else if( cr.StatBase[ ST_STRENGTH ] >= 4 && cr.StatBase[ ST_STRENGTH ] < 7 )
        {
            lexems += "$Strength" + "";
        }
        else if( cr.StatBase[ ST_STRENGTH ] >= 7 && cr.StatBase[ ST_STRENGTH ] <= 8 )
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 17 ) + "@";
        }
        else
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 18 ) + "@";
        }
        // Восприятие.
        if( cr.StatBase[ ST_PERCEPTION ] < 4 )
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 19 ) + "@";
        }
        else if( cr.StatBase[ ST_PERCEPTION ] >= 4 && cr.StatBase[ ST_PERCEPTION ] < 7 )
        {
            lexems += "$Perception" + "";
        }
        else if( cr.StatBase[ ST_PERCEPTION ] >= 7 && cr.StatBase[ ST_PERCEPTION ] <= 8 )
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 20 ) + "@";
        }
        else
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 21 ) + "@";
        }
        // Выносливость.
        if( cr.StatBase[ ST_ENDURANCE ] < 4 )
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 22 ) + "@";
        }
        else if( cr.StatBase[ ST_ENDURANCE ] >= 4 && cr.StatBase[ ST_ENDURANCE ] < 7 )
        {
            lexems += "$Endurance" + "";
        }
        else if( cr.StatBase[ ST_ENDURANCE ] >= 7 && cr.StatBase[ ST_ENDURANCE ] <= 8 )
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 23 ) + "@";
        }
        else
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 24 ) + "@";
        }
        // Обаяние.
        if( cr.StatBase[ ST_CHARISMA ] < 4 )
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 25 ) + "@";
        }
        else if( cr.StatBase[ ST_CHARISMA ] >= 4 && cr.StatBase[ ST_CHARISMA ] < 7 )
        {
            lexems += "$Charisma" + "";
        }
        else if( cr.StatBase[ ST_CHARISMA ] >= 7 && cr.StatBase[ ST_CHARISMA ] <= 8 )
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 26 ) + "@";
        }
        else
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 27 ) + "@";
        }
        // Интеллект.
        if( cr.StatBase[ ST_INTELLECT ] < 4 )
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 28 ) + "@";
        }
        else if( cr.StatBase[ ST_INTELLECT ] >= 4 && cr.StatBase[ ST_INTELLECT ] < 7 )
        {
            lexems += "$Intellect" + "";
        }
        else if( cr.StatBase[ ST_INTELLECT ] >= 7 && cr.StatBase[ ST_INTELLECT ] <= 8 )
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 29 ) + "@";
        }
        else
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 30 ) + "@";
        }
        // Ловкость.
        if( cr.StatBase[ ST_AGILITY ] < 4 )
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 31 ) + "@";
        }
        else if( cr.StatBase[ ST_AGILITY ] >= 4 && cr.StatBase[ ST_AGILITY ] < 7 )
        {
            lexems += "$Agility" + "";
        }
        else if( cr.StatBase[ ST_AGILITY ] >= 7 && cr.StatBase[ ST_AGILITY ] <= 8 )
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 32 ) + "@";
        }
        else
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 33 ) + "@";
        }
        // Удача.
        if( cr.StatBase[ ST_LUCK ] < 4 )
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 34 ) + "@";
        }
        else if( cr.StatBase[ ST_LUCK ] >= 4 && cr.StatBase[ ST_LUCK ] < 7 )
        {
            lexems += "$Luck" + "";
        }
        else if( cr.StatBase[ ST_LUCK ] >= 7 && cr.StatBase[ ST_LUCK ] <= 8 )
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 35 ) + "@";
        }
        else
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 36 ) + "@";
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
    }

    // Тагнутые боевые навыки.
    if( player.Skill[ SK_SPEECH ] >= 80 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_MELEE_WEAPONS, SK_THROWING };
        uint[] TagSkills = { cr.TagSkill[ TAG_SKILL1 ], cr.TagSkill[ TAG_SKILL2 ], cr.TagSkill[ TAG_SKILL3 ], cr.TagSkill[ TAG_SKILL4 ] };

        for( uint i = 0; i < CombatSkills.length(); i++ )
        {
            for( uint t = 0; t < TagSkills.length(); t++ )
            {
                if( CombatSkills[ i ] == TagSkills[ t ] )
                {
                    if( cr.Skill[ TagSkills[ t ] ] < 100 )
                    {
                        lexems = "$CmbtSkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 60 + Random( 0, 1 ) ) + "@";
                        switch( TagSkills[ t ] )
                        {
                        case SK_SMALL_GUNS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@";
                            break;
                        case SK_BIG_GUNS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@";
                            break;
                        case SK_ENERGY_WEAPONS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@";
                            break;
                        case SK_UNARMED:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@";
                            break;
                        case SK_MELEE_WEAPONS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 45 ) + "@";
                            break;
                        case SK_THROWING:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@";
                            break;
                        default:
                            break;
                        }
                        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 6 ), lexems );
                    }
                }
            }
        }

    }

    // Тагнутые небоевые навыки.
    if( player.Skill[ SK_SPEECH ] >= 85 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };
        uint[] TagSkills = { cr.TagSkill[ TAG_SKILL1 ], cr.TagSkill[ TAG_SKILL2 ], cr.TagSkill[ TAG_SKILL3 ], cr.TagSkill[ TAG_SKILL4 ] };
        for( uint i = 0; i < Skills.length(); i++ )
        {
            for( uint t = 0; t < TagSkills.length(); t++ )
            {
                if( Skills[ i ] == TagSkills[ t ] )
                {
                    if( cr.Skill[ TagSkills[ t ] ] < 100 )
                    {
                        lexems = "$SkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 62 + Random( 0, 2 ) ) + "@";
                        switch( TagSkills[ t ] )
                        {
                        case SK_FIRST_AID:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 65 ) + "@";
                            break;
                        case SK_DOCTOR:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 66 ) + "@";
                            break;
                        case SK_SNEAK:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 67 ) + "@";
                            break;
                        case SK_LOCKPICK:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 68 ) + "@";
                            break;
                        case SK_STEAL:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 69 ) + "@";
                            break;
                        case SK_TRAPS:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 70 ) + "@";
                            break;
                        case SK_SCIENCE:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 71 ) + "@";
                            break;
                        case SK_REPAIR:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 72 ) + "@";
                            break;
                        case SK_SPEECH:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 73 ) + "@";
                            break;
                        case SK_BARTER:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 74 ) + "@";
                            break;
                        case SK_GAMBLING:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 75 ) + "@";
                            break;
                        case SK_OUTDOORSMAN:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 76 ) + "@";
                            break;
                        default:
                            break;
                        }
                        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 7 ), lexems );
                    }
                }
            }
        }

    }

    // Прокачаный боевой навык.
    if( player.Skill[ SK_SPEECH ] >= 90 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        lexems = "";
        int CurSkill = 0;
        int MaxSkill = 0;
        uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_MELEE_WEAPONS, SK_THROWING };

        for( uint i = 0; i < CombatSkills.length(); i++ )
        {
            if( CurSkill < cr.Skill[ CombatSkills[ i ] ] )
            {
                CurSkill = cr.Skill[ CombatSkills[ i ] ];
                MaxSkill = CombatSkills[ i ];
            }
        }
        if( CurSkill < 90 )
        {
            lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 37 ) + "@";
            lexems += "$CombatSkillMax";
        }
        else
        {
            if( CurSkill >= 90 && CurSkill < 150 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 38 ) + "@";
            if( CurSkill >= 150 && CurSkill < 200 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 39 ) + "@";
            if( CurSkill >= 200 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 40 ) + "@";
            switch( MaxSkill )
            {
            case SK_SMALL_GUNS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@";
                break;
            case SK_BIG_GUNS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@";
                break;
            case SK_ENERGY_WEAPONS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@";
                break;
            case SK_UNARMED:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@";
                break;
            case SK_MELEE_WEAPONS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 45 ) + "@";
                break;
            case SK_THROWING:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@";
                break;
            default:
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 ), lexems );

    }

    // Прокачаный небоевой навык.
    if( player.Skill[ SK_SPEECH ] >= 100 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        lexems = "";
        int CurSkill = 0;
        int MaxSkill = 0;
        uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };

        for( uint i = 0; i < Skills.length(); i++ )
        {
            if( CurSkill < cr.Skill[ Skills[ i ] ] )
            {
                CurSkill = cr.Skill[ Skills[ i ] ];
                MaxSkill = Skills[ i ];
            }
        }
        if( CurSkill <= 90 )
        {
            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 47 ) + "@";
        }
        else
        {
            switch( MaxSkill )
            {
            case SK_FIRST_AID:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 48 ) + "@";
                break;
            case SK_DOCTOR:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 49 ) + "@";
                break;
            case SK_SNEAK:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 50 ) + "@";
                break;
            case SK_LOCKPICK:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 51 ) + "@";
                break;
            case SK_STEAL:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 52 ) + "@";
                break;
            case SK_TRAPS:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 53 ) + "@";
                break;
            case SK_SCIENCE:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 54 ) + "@";
                break;
            case SK_REPAIR:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 55 ) + "@";
                break;
            case SK_SPEECH:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 56 ) + "@";
                break;
            case SK_BARTER:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 57 ) + "@";
                break;
            case SK_GAMBLING:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 58 ) + "@";
                break;
            case SK_OUTDOORSMAN:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 59 ) + "@";
                break;
            default:
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 5 ), lexems );

    }

    // Количество денег на счету.
    if( player.Skill[ SK_SPEECH ] >= 110 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        lexems += "$ReplMoney " + cr.Stat[ ST_REPLICATION_MONEY ] + "$ReplCount " + cr.Stat[ ST_REPLICATION_COUNT ];
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 8 ), lexems );
    }
}

void dlg_ForSearching( Critter& player, Critter@ barman, string@ playerName )
{
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 11 ), lexems );
    return;
}

void dlg_TrySearching( Critter& player, Critter@ barman, string@ playerName )
{

    #define LOC_NAME    # (mapId)                       ( ( mapId + 100 ) * 1000 ) // поиск названия локации в файле FOGM.msg
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    // Игрок спрашивает о самом себе.
    if( player.Id == cr.Id )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ) );
        return;
    }
    // Криттер на глобале.
    Map@ map = cr.GetMap();
    if( !valid( map ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
    // Локация, где находится криттер. Диапазоны PID: до 150 и 210-235. Города и репликации.
    if( cr.GetMap().GetLocation().GetProtoId() < 50 || cr.GetMap().GetLocation().GetProtoId() >= 200 )
    {
        lexems += "$Place @msg GM " + LOC_NAME( cr.GetMap().GetLocation().GetProtoId() ) + "@";
        // Криттер находится в той же локации, что и игрок.
        if( barman.GetMap().GetLocation().Id == cr.GetMap().GetLocation().Id )
        {
            player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
            return;
        }
        // Криттер найден, лексемы сформированы - даем информацию.
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 + Random( 0, 2 ) ), lexems );
    }
    else
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
}

import void ChangeStatus( Critter& cr, uint16 status, uint8 value, bool set ) from "critter_status";        // pm added

void r_ToHeal( Critter& player, Critter@ npc )
{
	ChangeStatus( player, CR_STATUS_BLOOD_TOXIC, 0, false );
	ChangeStatus( player, CR_STATUS_BULLET_OVER, 0, false );
	ChangeStatus( player, CR_STATUS_BLEED, 0, false );
	ChangeStatus( player, CR_STATUS_HEAVY_DMG, 0, false );
    HealCritter( player );
}

void r_ShowLocation( Critter& player, Critter@ npc, int locNum )
{
    // player.SetKnownLoc( false, uint16( locNum ) );
}

void r_FadeOut( Critter& player, Critter@ npc, int time )
{
    if( time == 0 )
        time = 2000;
    FlushScreen( player, false, time );
}

void r_TransitToGlobal( Critter& player, Critter@ npc )
{
    player.TransitToGlobal( false );
}

void r_TransitToLocation( Critter& player, Critter@ npc, int locPid, int mapIndex )
{
    TransitToLoc( player, locPid, mapIndex, 0 );
}

void r_InfoMessage( Critter& player, Critter@ npc, int strNum )
{
    InfoMessage( player, npc, strNum );
}

void r_TimeoutSet( Critter& player, Critter@ npc, int timeoutNumber, int gameHours )
{
    // temp
    int variable = 0;
    switch( timeoutNumber )
    {
    case 0:
        variable = LVAR_timeout;
    case 1:
        variable = LVAR_timeout1;
    case 2:
        variable = LVAR_timeout2;
    case 3:
        variable = LVAR_timeout3;
    case 4:
        variable = LVAR_timeout4;
    case 5:
        variable = LVAR_timeout5;
    case 6:
        variable = LVAR_timeout6;
    case 7:
        variable = LVAR_timeout7;
    case 8:
        variable = LVAR_timeout8;
    default:
    }
    Log( "r_Timeoutset: " + variable + " timeout" );
    // temp
    TimeoutSet( npc, timeoutNumber, gameHours );
    Log( "r_timeoutset: timeoutNumber = " + timeoutNumber + " gameHours = " + gameHours );
}

void r_DoorOpen( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, true );
}

void r_DoorClose( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, false );
}

// Даем игроку голодиск
void r_GiveHolodisk( Critter& player, Critter@ npc, int holodiskNum )
{
    Item@ holo = player.AddItem( PID_HOLODISK, 1 );
    holo.HolodiskNumber = holodiskNum;
    holo.Update();
}

bool d_DuplKey( Critter& player, Critter@ npc )
{
    Item@ key = player.GetItem( 0, SLOT_HAND1 );
    if( !valid( key ) || key.GetType() != ITEM_TYPE_KEY )
        return false;
    return true;
}

bool d_isOwner( Critter& player, Critter@ npc )
{
    return uint( npc.Stat[ ST_FOLLOW_CRIT ] ) == player.Id;
}

void r_isOwner( Critter& player, Critter@ npc )
{
	player.ShowContainer( npc, null, TRANSFER_FAR_CRIT );
}

import void KeyUseScreen( Critter& player, uint answerI, string& answerS ) from "item";

void r_DuplKey( Critter& player, Critter @ npc )
{
    Item @ key = player.GetItem( 0, SLOT_HAND1 );
    if( !valid( key ) || key.GetType() != ITEM_TYPE_KEY )
        return;
    Item @ newKey = player.AddItem( PID_BLANK_KEY, 1 );
    newKey.LockerId = key.LockerId;
    newKey.SetLexems( "$KeyLex" + "some key" );
    player.StatBase[ ST_VAR0 ] = newKey.Id;
    player.ShowScreen( SCREEN_SAY, 0, "item@KeyUseScreen" );
    newKey.Update();
}

void give_dosimetr( Critter& player, Critter @ npc )
{
    Item@ dosimetr = player.AddItem( PID_DOSIMETR, 1 );
    dosimetr.Val1 = Random( 20, 300 );
    dosimetr.Val2 = Random( 20, 550 );

    dosimetr.SetLexems( "указанны координаты " + dosimetr.Val1 / 10 + " и " + dosimetr.Val2 / 10 );
}

void get_cow( Critter& player, Critter@ npc )
{
    Critter@[] brahmins;
    Map @ map = player.GetMap();
    Item@ flute = player.GetItem( PID_FLUTE, 0 );
    if( ( map.GetCritters( NPC_PID_Brahmin, FIND_LIFE_AND_KO | FIND_ONLY_NPC, brahmins ) > 0 ) && map.Id == uint( flute.Val1 ) )
    {
        for( uint i = 0, ii = brahmins.length(); i < ii; i++ )
        {
            uint   cuffs_state = brahmins[ i ].Stat[ ST_HANDCUFFS ];
            uint16 master = ( cuffs_state ) & 0xFFFF;
            if( player.Id == master )
            {
                if( brahmins[ i ].Stat[ ST_VAR5 ] >= 5 )
                {
                    player.AddItem( PID_BOTTLE_CAPS, 100 );
                    DeleteNpc( brahmins[ i ] );
                    // GetUnicumVar(UVAR_loyality, player.Id, npc.Id)+=1;  поправить увеличение лояльности
                }
                else
                    DeleteNpc( brahmins[ i ] );
            }
        }
    }
}

void give_Package( Critter& player, Critter @ npc, int destination )
{
    if( _CritCountItem( player, PID_PACKAGE ) != 0 )
    {
        npc.Say( SAY_NORM, "да ты уже с грузом" );
        return;
    }
    Item@  pack = player.AddItem( PID_PACKAGE, 1 );
    pack.Val1 = destination;
    string dest = "";
    switch( destination )
    {
    case 1:
        dest = "Отнести на склад Модока";
        npc.Say( SAY_NORM, "отнесите это Джо, его магазин недалеко от главных ворот" );
        break;
    case 2:
        dest = "Отнести на ферму";
        npc.Say( SAY_NORM, "отнесите это Филу, на ферму, сейчас он в отъезде, но может быть вы дождетесь его когда-нибудь" );
        break;
    case 3:
        dest = "Отнести мутанту на свалку";
        npc.Say( SAY_NORM, "отнесите это Туроку, это мутант на свалке, обычно в палатке сидит" );
        break;
    case 4:
        dest = "Отнести в Форт Саттер";
        npc.Say( SAY_NORM, "отнесите это Биллу, он в форте, обычно на нижинх этажах, скорее всего с генераторами возится" );
        break;
    }
    pack.SetLexems( "" + dest );
    if( FactionInGame( player, npc, 6, 2 ) )
        pack.Val2 = 1;
    pack.Val3 = player.Id;
    PackageAlarm( player, destination );
    //player.ModeBase[ MODE_NO_WALK ] = 1;
    //player.ModeBase[ MODE_NO_RUN ] = 1;
}

void give_Package_chek( Critter& player, Critter @ npc, int destination )
{
    Item@ pack = player.GetItem( PID_PACKAGE, 0 );
    if( pack.Val1 == destination )
    {
        Item@ chek = player.AddItem( PID_PACKAGE_CHEK, 1 );
        chek.Val1 = pack.Val1;
        chek.Val2 = pack.Val2;
        chek.Val3 = pack.Val3;
        DeleteItem( pack );
        npc.Say( SAY_NORM, "спасибо, держите расписку о получении" );
    }
    else
        npc.Say( SAY_NORM, "это не та посылка" );
}

void get_Package_chek( Critter& player, Critter @ npc, int late )
{
    Item@ chek = player.GetItem( PID_PACKAGE_CHEK, 0 );
	if( @chek is null ) return;
	
    int destination = chek.Val1,
		exp = 0, payout = 0;
    if( uint( chek.Val3 ) != player.Id )
        late = 1;
    switch( destination )
    {
    case 1:
        exp = 20;
        payout = 20;
        if( chek.Val2 != 0 )
            break;
    case 2:
        exp = 50;
        payout = 50;
        break;
    case 3:
        exp = 80;
        payout = 80;
        break;
    case 4:
        exp = 150;
        payout = 100;
        break;
    }
    if( chek.Val2 != 0 && destination >= 3 && late == 0 )
    {
        exp *= 10;
        payout *= 10;
    }
    if( late != 0 )
    {
        npc.Say( SAY_NORM, "долго слишком, бери оплату" );
        exp /= 4;
        payout /= 4;
    }
    else
        npc.Say( SAY_NORM, "бери оплату" );
    if( uint( chek.Val3 ) == player.Id )
        player.StatBase[ ST_EXPERIENCE ] += exp;
    player.AddItem( PID_BOTTLE_CAPS, payout );
    DeleteItem( chek );
}

void getCure( Critter& player, Critter @ npc )
{
    Item @ hypo = player.AddItem( PID_HYPO_BLOOD, 1 );
    GameVar@ strain = GetGlobalVar( GVAR_desease_strain );
    hypo.Val1 = 0;
    hypo.Val2 = 0;
    hypo.Val3 = strain.GetValue();
    hypo.SetLexems( "$HypoLex" + " вакцина номер " + hypo.Val3 );
    hypo.Update();
}

void giveCure( Critter& player, Critter @ npc )
{
    Item@    hypo = player.GetItem( PID_HYPO_BLOOD, 0 );
    GameVar@ strain = GetGlobalVar( GVAR_desease_strain );
    if( ( hypo.Val3 > strain.GetValue() ) && hypo.Val2 >= 50 )
        strain.opAddAssign( hypo.Val3 );
    npc.Say( SAY_NORM, "я должен сделать несколько тестов" );
    DeleteItem( hypo );
}

void r_RadioLeroy2 ( Critter& player, Critter@ npc, int p0, int p1, int p2 ) 
{
RadioMessage ( 0 , "[Голос Лероя] Желающий в город у ворот" ) ;
}

void r_RadioLeroy1 ( Critter& player, Critter@ npc, int p0, int p1, int p2 ) 
{
RadioMessage ( 0 , "[Голос Лероя] Новое лицо у ворот" ) ;
}