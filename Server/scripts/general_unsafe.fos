#include "_macros.fos"
#include "_colors.fos"

#include "popups.fos"

import void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo ) from "main";
import bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param ) from "main";
import void CombatAttack( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY ) from "combat";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target, bool run ) from "npc_planes";
import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import void Actions( Critter& cr, uint8 actionType, uint16 pickType ) from "context_callback";

void unsafe_AutoEmote( Critter& cr, int hasPID, int p1, int p2, string@ text, int[] @ p4 ) { 
	if( hasPID == 0 || _CritCountItem( cr, hasPID ) > 0 )
		cr.Say( SAY_EMOTE, text ); 
}

void unsafe_setKarma( Critter& cr, int value, int p1, int p2, string@ text, int[] @ p4 ) { cr.ParamBase[ST_KARMA] = value; }

import void SpawnKindPart( Map& map, string& kindName, uint16 hexX, uint16 hexY, uint16 count ) from "world";
import bool isCellStatic( Critter& cr, Map @map ) from "world";
import int[] CellAreaInfo( Critter@ cr, Map @map ) from "world";

void unsafe_make_trap( Critter& cr, int p0, int p1, int p2, string@ info, int[] @ p4 ) { 
	if(cr.GetAccess() >= ACCESS_MODER) TrapMenu(cr); 
	else cr.Say(SAY_NETMSG, "Фича находится в разработке. Подождите ещё немного.");
}

#define TRAP_DIST_MIN 3
#define TRAP_DIST_MAX 12

#define TrapSet Val0
#define TrapDist Val1
#define TrapParent Val2
#define TrapType Val3
#define TrapPrice Val4
#define TrapFoodPID Val5
#define TrapTarget Val6
#define TrapQuality Val7
#define TrapOwner Val8
#define LastSpawn Val9

#define TRAP_NONE 0
#define TRAP_POLE 1
#define TRAP_CLAM 2
#define TRAP_CAGE 3
#define TRAP_ROPE 4

Item@ getClosestTrap(Critter& cr, bool ParentOnly) {
	Item@[] items;
	Item@ trap = null;
	
	int minDist = 999;
	for( uint i = 0, iEnd = cr.GetMap().GetItems( PID_POPUP, items ); i < iEnd; i++ )
	{
		int dist = GetDistantion( cr.HexX, cr.HexY, items[i].HexX, items[i].HexY );
		if( items[i].TrapType != TRAP_NONE && dist <= TRAP_DIST_MAX && dist < minDist) {
			if(ParentOnly && items[i].TrapParent != 0) continue;
			@trap = items[i];
			minDist = dist;
		}
	}
	return trap;
}

int countChildTraps(Critter& cr, Item@ trap) {
	if(!valid(trap)) return 0;
	
	Item@[] items;	
	int count = 0;
	for( uint i = 0, iEnd = cr.GetMap().GetItems( PID_POPUP, items ); i < iEnd; i++ )
		if( items[i].TrapType != TRAP_NONE && uint( items[i].TrapParent ) == trap.Id )
			count++;
	return count;
}

void TrapMenu(Critter& cr) {
	Map@ map = cr.GetMap();
	if(!valid(map)) { cr.Say(SAY_NETMSG, "На глобале нельзя."); return; }

	cr.Say( SAY_NETMSG, "Вы внимательно изучаете обстановку." );
	cr.Say( SAY_EMOTE, "осматривается" );
	cr.Wait(2000);
	
	if( isCellStatic( cr, map ) ) {
		cr.Say( SAY_NETMSG, "Ловушки можно ставить лишь вдали от обжитых мест." );
		return;
	}
	AskTrapAction(cr);
}

void AskTrapAction(Critter& cr) {
	string[] action = { "местоположение", "ближ. ловушку", "вбить кол", "капкан", "клетку", "сеть", "приманку", "слом. ловушку" };
	const uint countaction = action.length();
	cr.ShowScreen( SCREEN_DIALOGBOX, countaction, "answer_TrapAction" ); 
	cr.Say( SAY_DIALOGBOX_TEXT, "Выберите, что вы хотите установить:");
	for( uint i = 0; i < countaction; i++ )
		cr.Say( SAY_DIALOGBOX_BUTTON( i ), action[i] );
}

int[] CheckAreaMaps(Critter @cr, Map@ map) {
	string[] names = { "Непригодно", "Пустошь", "Лес", "Руины", "Горы", "Река", "Рельсы", "Дорога", "Мост", "Перекрёсток" };
	int[] result = CellAreaInfo(cr,map);
	if(valid(cr)) {
		string info = "Для охоты вокруг вас:";
		for( uint i = 0, iEnd = result.length(); i < iEnd; i++ )
			info += ( result[i] > 0 ? ( "\n" + names[i] + ": " + result[i] + ";" ) : "" );
		cr.Say( SAY_NETMSG, info );
	}
	return result;
}

string[] TrapTypeName = { "", "кол", "капкан", "клетка", "сеть" };

string[] TargetType = { "травоядные", "падальщики", "хищники", "всеядные", "болотники", "путники", "бандиты", "мутанты" };

void ClosestTrapInfo(Critter &cr, Item@ closest) {
	int dist = GetDistantion( cr.HexX, cr.HexY, closest.HexX, closest.HexY );
	cr.Say( SAY_NETMSG, "Ближайшая ловушка установлена " + ( dist == 0 ? "под вами" : "в " + dist + " шагах от вас" ) + "." + 
						" Это " + TrapTypeName[closest.TrapType] + ", " + ( closest.TrapParent == 0 ? "центральная" : "вспомогательная" ) + " ловушка в группе." +
						" Её 'рейтинг приманки' равен " + closest.TrapPrice + " баллам" + ( closest.TrapTarget > 0 ? ", целевая группа - " + TargetType[closest.TrapTarget-1] : "" ) + "." + 
						( cr.GetAccess() >= ACCESS_MODER ? (" [" + closest.TrapFoodPID + "]") : "" ) );
}

void answer_TrapAction( Critter& cr, uint answerI, string& answerS ) {
	if( cr.Timeout[ TO_SK_REPAIR ] > 0 ) {
		if ( cr.GetAccess() >= ACCESS_MODER ) {
			cr.Say( SAY_NETMSG, "Вы бы устали, не будь вы ГМом." );
		} else {
			cr.Say( SAY_NETMSG, "Дайте рукам отдохнуть." );
			return;
		}
	}
	
	Item@ parent = getClosestTrap(cr,true);
	Item@ closest = getClosestTrap(cr,false);

	bool TooClose = 
		( valid(closest) && GetDistantion( cr.HexX, cr.HexY, closest.HexX, closest.HexY ) < TRAP_DIST_MIN ) ||
		( valid(parent) && GetDistantion( cr.HexX, cr.HexY, parent.HexX, parent.HexY ) < TRAP_DIST_MIN );

	bool isNew = !valid(parent); //Новая группа.
	bool isBusy = valid(closest) && closest.TrapType > TRAP_POLE; //Уже привязано что-то.
	bool isRoping = answerI > 2 && answerI < 6; //Привязываем к колу ловушку.
	bool isPoling = answerI == 2; //Вбиваем кол.
	bool isDestroy = answerI == 7; //Убираем ловушку.
	bool isChecking = answerI == 1; //Осматриваем ближайшую ловушку.

	if( isChecking ) {
		if( isNew ) { cr.Say( SAY_NETMSG, "Вы не обнаружили никаких ловушек поблизости."); return; }
		//if( !TooClose ) { cr.Say( SAY_NETMSG, "Подойдите ближе к ловушке, что бы осмотреть её."); return; }
	}
	if( isDestroy && !TooClose ) { cr.Say( SAY_NETMSG, "Встаньте ближе к ловушке, что бы её демонтировать."); return; }
	if( isPoling ) {
		if( TooClose ) { cr.Say( SAY_NETMSG, "Вы не можете вбивать колья ближе чем на 3 шага друг от друга."); return; }
		if( !isNew && uint( parent.TrapDist ) < GetDistantion( cr.HexX, cr.HexY, parent.HexX, parent.HexY ) ) {
			cr.Say( SAY_NETMSG, "Эта ловушка должна быть установлена ближе к 'центральной', чей радиус охвата " + parent.TrapDist + " шагов." + 
			" Либо просто поставьте её дальше, чем в " + TRAP_DIST_MAX + " шагах, что бы она стала 'центральной' для другой группы."); return; }
	}
	
	if( isRoping ) {
		if( !valid(closest) || !TooClose ) { cr.Say( SAY_NETMSG, "Встаньте ближе к вбитому колу, что бы привязать к нему ловушку."); return; }
		if( isBusy ) { cr.Say( SAY_NETMSG, "Ближайшый к вам кол занят. К нему уже привязали " + TrapTypeName[closest.TrapType] + "."); return; }
	}
	
	Item@ trap = null, tool = _CritGetItemHand( cr );
	Map@ map = cr.GetMap();
	
	switch(answerI) {
		case(0): CheckAreaMaps(cr,map); break;
		case(1): if(!isNew) ClosestTrapInfo(cr,closest);	break;
		
		case(2): 
			if( _CritCountItem( cr, PID_SHARPENED_POLE ) > 0 && valid(tool) && tool.GetProtoId() == PID_SLEDGEHAMMER ) {
				cr.DeleteItem( PID_SHARPENED_POLE, 1 );
				cr.Action( ACTION_USE_WEAPON, 0, tool );
				cr.GetMap().SetText( cr.HexX, cr.HexY, COLOR_GRAY, "стук" );
				cr.Say( SAY_NETMSG, "Теперь здесь можно установить ещё одну ловушку: капкан, клетку или сеть.");
				cr.Say( SAY_EMOTE, "вбивает кол в землю" );
				cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 15 - cr.Stat[ ST_STRENGTH ] );
		
				@trap = map.AddItem( cr.HexX, cr.HexY, PID_POPUP, 1 );
				changePopup( trap, "Из земли торчит колышек." );
				
				trap.TrapSet = 1;
				trap.TrapDist = TRAP_DIST_MIN;
				trap.TrapType = TRAP_POLE;
				if(!isNew && parent.TrapDist < TRAP_DIST_MAX) { 
					parent.TrapDist += TRAP_DIST_MIN;
					trap.TrapParent = parent.Id;
				}
				else
					trap.TrapParent = 0;
			} else {
				cr.Say( SAY_NETMSG, "Вам нужен заострённый кол, и молоток в руках.");
			}
		break;
		
		case(3): 
			if( _CritCountItem( cr, PID_CRAFT_M_BARS ) > 0 && _CritCountItem( cr, PID_PART_OF_ROPE ) > 0 ) {
				cr.Animate( 0, ANIM2_PICKUP, null, true, true );
				cr.DeleteItem( PID_CRAFT_M_BARS, 1 );
				cr.DeleteItem( PID_PART_OF_ROPE, 1 );
				cr.GetMap().SetText( cr.HexX, cr.HexY, COLOR_GRAY, "скрип" );
				cr.Say( SAY_NETMSG, "Вы привязали капкан к вбитому в землю колу.");
				cr.Say( SAY_EMOTE, "устанавливает капкан на дичь" );
				cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 25 - cr.Stat[ ST_STRENGTH ] - cr.Stat[ ST_INTELLECT ] );
				closest.TrapType = TRAP_CLAM;
				closest.TrapOwner = cr.Id;
				changePopup( closest, "Здесь поставлен капкан на дичь." );
				uint[] values = { map.Id, cr.Id, closest.Id, 0 /*счётчик таймера*/, 0 /*накопленная "вкусность"*/ };
				CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_spawnTrap", values, false );
			} else {
				cr.Say( SAY_NETMSG, "Вам нужны железные детали и 'кусок' верёвки.");
			}
		break;
		
		case(4): 
			if( _CritCountItem( cr, PID_CRAFT_M_JUNK ) > 0 && _CritCountItem( cr, PID_PART_OF_ROPE ) > 0 ) {
				cr.Animate( 0, ANIM2_PICKUP, null, true, true );
				cr.DeleteItem( PID_CRAFT_M_BARS, 1 );
				cr.DeleteItem( PID_PART_OF_ROPE, 1 );
				cr.GetMap().SetText( cr.HexX, cr.HexY, COLOR_GRAY, "шорох" );
				cr.Say( SAY_NETMSG, "Вы привязали клетку к вбитому в землю колу.");
				cr.Say( SAY_EMOTE, "устанавливает клетку для дичи" );
				cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 25 - cr.Stat[ ST_STRENGTH ] - cr.Stat[ ST_INTELLECT ] );
				closest.TrapType = TRAP_CAGE;
				closest.TrapOwner = cr.Id;
				changePopup( closest, "Здесь поставлена клетка на дичь." );
				uint[] values = { map.Id, cr.Id, closest.Id, 0 /*счётчик таймера*/, 0 /*накопленная "вкусность"*/ };
				CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_spawnTrap", values, false );
			} else {
				cr.Say( SAY_NETMSG, "Вам нужен хотя бы какой-то 'мусор' и 'кусок' верёвки.");
			}
		break;
		
		case(5): 
			if( _CritCountItem( cr, PID_ROPE ) > 0 ) {
				cr.Animate( 0, ANIM2_PICKUP, null, true, true );
				cr.DeleteItem( PID_ROPE, 1 );
				cr.Say( SAY_NETMSG, "Вы привязали конец верёвки к вбитому в землю колу.");
				cr.Say( SAY_EMOTE, "готовит сеть для дичи" );
				cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 25 - cr.Stat[ ST_STRENGTH ] - cr.Stat[ ST_INTELLECT ] );
				closest.TrapType = TRAP_ROPE;
				closest.TrapOwner = cr.Id;
				changePopup( closest, "Здесь приготовлены сети для дичи." );
				uint[] values = { map.Id, cr.Id, closest.Id, 0 /*счётчик таймера*/, 0 /*накопленная "вкусность"*/ };
				CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_spawnTrap", values, false );
			} else {
				cr.Say( SAY_NETMSG, "Вам нужна верёвка для этого.");
			}
		break;
		case(6): 
			cr.StatBase[ ST_LAST_CONT_ID ] = closest.Id;
			AskTrapActionFeed(cr); 
		break;
		case(7): DestroyTrap(cr,closest); break;
		default: AskTrapAction(cr); break;
	}
}

void DestroyTrap( Critter& cr, Item@ trap ) {
	if(!valid(trap)) { cr.Say( SAY_NETMSG, "Что-то пошло не так.." ); return; }
	if(trap.TrapParent == 0 && countChildTraps(cr,trap) > 0 ) { cr.Say( SAY_NETMSG, "Это центральная ловушка, сначала демонтируйте окружающие." ); return; }
	if(trap.TrapParent != 0) {
		Item@ parent = cr.GetMap().GetItem(trap.TrapParent);
		if(valid(parent)) parent.TrapDist -= TRAP_DIST_MIN;
	}
	cr.Say( SAY_NETMSG, "Вы сломали одноразовую ловушку и забрали приманку.");
	cr.Say( SAY_EMOTE, "убирает ловушку" );
	cr.Animate( 0, ANIM2_PICKUP, null, true, true );
	cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 15 - cr.Stat[ ST_STRENGTH ] );
	DeleteItem(trap);
	cr.AddItem( trap.TrapFoodPID, 1 );
}

string[][] kindNames = { 
	//Травоядные:
	{ "4Plants", "10Silvergeckos", "11Goldengeckos", "5Brahmins" },
	//Падальщики:
	{ "1Rats", "8Pigrats",  "14Bigscorps", "15Blackscorps"  },
	//Хищники
	{ "6Dogs", "7Wolfes", "9Molerats", "12Firegeckos", "16Deathclaws" },
	//Всеядные:
	{ "3Ants", "2Mantis", "13Smallscorps", "23Cannibals" },
	//Болотники:
	{ "17Swamplurkers" },
	//Дикари:
	{ "22Primitives", "23Rippers", "28Strangers" },
	//Бандиты:
	{ "24Gangs", "25Raiders", "26Slavers", "27Caravans", "31Robots" },
	//Мутанты:
	{ "18Aliens", "19Motheraliens", "20Floaters", "21Centaurs", "29Ghouls", "30Supermutants"  }
};

string[][] kindSounds = {
	{ "шелест", "крик гекко", "громкий крик гекко", "мычание" },
	{ "писк", "хрюкание", "громкое щёлканье", "частое щёлканье" },
	{ "лай", "вой", "рёв гризли", "визг огнегекко", "рёв смертокогтя" },
	{ "", "стрекотание", "щёлканье", "крики каннибалов" },
	{ "рёв болотника" },
	{ "крики дикарей", "матюги", "крики людей" },
	{ "бандитский ор", "многоэтажные маты", "стон боли", " ", "железный стук" },
	{ "визг", "громкий визг", "шелест", "рёв кентавра", "крики гулей", "ор супермутантов" }
};

int[][] kindPrices = {
	//Травоядные:
	{ 1, 5, 9, 13 },
	//Падальщики:
	{ 2, 6, 9, 12 },
	//Хищники:
	{ 3, 5, 8, 11, 14 },
	//Всеядные:
	{ 1, 2, 3, 8 },
	//Болотники:
	{ 10 },
	//Дикари:
	{ 8, 14, 18 },
	//Бандиты:
	{ 12, 16, 20, 24, 30 },
	//Мутанты:
	{ 10, 15, 20, 25, 30, 35 }
};

int[][] kindAreaChances = { 
// { "Непригодно", "Пустошь", "Лес", "Руины", "Горы", "Река", "Рельсы", "Дорога", "Мост", "Перекрёсток" }
	//Травоядные:
	{ 0, 33, 100, 50, 20, 60, 25, 20, 50, 20 },
	//Падальщики:
	{ 0, 100, 100, 100, 100, 100, 100, 100, 100, 100 },
	//Хищники:
	{ 0, 20, 100, 100, 50, 50, 25, 33, 45, 35 },
	//Всеядные:
	{ 0, 100, 100, 100, 100, 100, 100, 100, 100, 100 },
	//Болотники:
	{ 0, 0, 10, 0, 0, 100, 0, 0, 100, 0 },
	//Дикари:
	{ 0, 75, 100, 50, 20, 33, 25, 10, 10, 10 },
	//Бандиты:
	{ 0, 50, 20, 100, 20, 33, 50, 100, 100, 100 },
	//Мутанты:
	{ 0, 100, 100, 100, 100, 100, 100, 100, 100, 100 }
};

void AskTrapActionFeed( Critter& cr ) {
	const uint targettypecount = TargetType.length();
	cr.ShowScreen( SCREEN_DIALOGBOX, targettypecount, "answer_TrapActionFeed" ); 
	cr.Say( SAY_DIALOGBOX_TEXT, "Выберите, на кого будет расчитана приманка:");
	for( uint i = 0; i < targettypecount; i++ )
		cr.Say( SAY_DIALOGBOX_BUTTON( i ), TargetType[i] );
	cr.StatBase[ ST_LAST_DOOR_ID ] = targettypecount;
}

string[][] TrapFoodNames = {
	{ "Брок", "Ксандер", "Цветок", "сем. радцвет", "сем. капусты", "сем. кукурузы", "сем. марихуаны", "грибы", "мутофрукт", "капуста", "кукуруза" },
	{ "Рад. Мясо", "Кус. Мяса", "Крыса", "Скорп. Хвост", "Желуд. Гризли" },
	{ "Жар. Крыса", "Жар. Мясо", "Жар. Гекко", "Сырое Гекко", "Сырое Мясо", "Игуана", "Шашлык", "Марин. Желудок"},
	{ "Дерьмо", "Перегной", "Верёвка(волокна)", "Панц. Мантиса", "Кусок кожи", "Шкура Гекко", "Золотой Гекко", "Шкура Брамина", "Огнегекко"},
	{ "Водоросли", "Мелкая Рыбка", "Жар. Рыба", "Малая Рыба", "Средн. Рыба", "Больш. Рыба", "Огромн. Рыба", "Панц. Болотника"},
	{ "Стекляшка", "Пластик", "Порошок", "Вода пласт.", "Вода стекл.", "Нюка", "Пиво", "Водка", "Пойло", "Сумка", "Рюкзак" },
	{ "Пуст. Джет", "Пуст. Шприц", "Стимпак", "Джет" },
	{ "Рад-пиво", "Рад-ром", "Фонящая батар.", "Железа мутанта"}
};
int[][][] TrapFoodTypes = {
	{  //Травоядные:
		{ PID_BROC_FLOWER, 1 }, 
		{ PID_XANDER_ROOT, 1 }, 
		{ PID_FLOWER, 2 }, 
		{ PID_SEED_RADCVET, 2 },
		{ PID_SEED_CABBAGE, 3 },
		{ PID_SEED_CORN, 3 },
		{ PID_SEED_MARIJUANA, 3 },
		{ PID_MUSH_GREEN, 4 }, 
		{ PID_MUTATED_FRUIT, 5 }, 
		{ PID_CABBAGE, 12 }, 
		{ PID_CORN, 12 },  
		{ PID_SALAD, 12 }
	},
	{ //Падальщики:
		{ PID_RAD_MEAT, 1 }, 
		{ PID_MEAT_JERKY, 2},
		{ PID_RAT_MEAT, 3 },
		{ PID_SCORPION_TAIL, 3 },
		{ PID_MOLERAT_STOMATCH, 4 }
	},
	{ //Хищники:
		{ PID_COOKED_RAT_MEAT, 1 },
		{ PID_COOKED_MEAT, 2 },
		{ PID_COOKED_GECKO_MEAT, 2 },
		{ PID_GECKO_MEAT, 3 },
		{ PID_MEAT, 3 },
		{ PID_IGUANA_ON_A_STICK, 6 },
		{ PID_MEAT_ON_A_STICK, 6 },
		{ PID_COOKED_MOLERAT_STOMATCH, 10 }
	},
	{ //Всеядные:
		{ PID_SHIT_BIG, 1 },
		{ PID_SHIT_SMALL, 1 },
		{ PID_ROPE, 1 },
		{ PID_MANTIS_SHELL, 2 },
		{ PID_CRAFT_L_HIDE, 2 },
		{ PID_GECKO_PELT, 3 },
		{ PID_GOLDEN_GECKO_PELT, 6 },
		{ PID_BRAHMIN_SKIN, 9 },
		{ PID_FIRE_GECKO_PELT, 12 }
	},
	{ //Болотники:
		{ PID_ALGAE, 1 },
		{ PID_FISH_SMALLEST, 1 },
		{ PID_COOKED_FISH, 2 },
		{ PID_FISH_SMALL, 2 },
		{ PID_FISH, 4 },
		{ PID_FISH_BIG, 6 },
		{ PID_FISH_BIGGEST, 10 },
		{ PID_MIRELUK_SHELL, 10 }
	},
	{ //Дикари:
		{ PID_BOTTLE_GLASS, 1 },
		{ PID_BOTTLE_EMPTY, 1 },
		{ PID_HEALING_POWDER, 2 },
		{ PID_BOTTLE_FULL, 2 },
		{ PID_GLASS_BOTTLE_FULL, 2 },
		{ PID_NUKA_COLA, 3 },
		{ PID_BEER, 3 }, 
		{ PID_BOOZE, 3 },
		{ PID_ROT_GUT, 4 },
		{ PID_BAG, 10 },
		{ PID_BACKPACK, 15 }
	},
	{ //Бандиты:
		{ PID_EMPTY_JET, 1 },
		{ PID_HYPODERMIC_NEEDLE, 1 },
		{ PID_STIMPAK, 20 },
		{ PID_JET, 25 }
	},
	{ //Мутанты:
		{ PID_GAMMA_GULP_BEER, 5 },
		{ PID_ROENTGEN_RUM, 5 },
		{ PID_CHEMICALS, 8 },
		{ PID_CUENCELL_LOW, 10 },
		{ PID_MUTATED_GLAND, 20 }
	}
};
void answer_TrapActionFeed( Critter& cr, uint answerI, string& answerS ) {
	if(answerI >= TrapFoodTypes.length() ) { AskTrapActionFeed(cr); return; }
	cr.StatBase[ ST_LAST_DOOR_ID ] = answerI;
	cr.ShowScreen( SCREEN_DIALOGBOX, TrapFoodNames[answerI].length(), "answer_TrapActionFeedCategory" ); 
	cr.Say( SAY_DIALOGBOX_TEXT, "Выберите, что вы хотите использовать в качестве приманки, справа указана её эффективность:");
	for( uint i = 0, iEnd = TrapFoodNames[answerI].length(); i < iEnd; i++ )
		cr.Say( SAY_DIALOGBOX_BUTTON( i ), TrapFoodNames[answerI][i] + ": " + TrapFoodTypes[answerI][i][1] );
}

void answer_TrapActionFeedCategory( Critter& cr, uint answerI, string& answerS ) {
	uint category = cr.Stat[ ST_LAST_DOOR_ID ] + 1;
	if(category == 0 || category >= TrapFoodTypes.length() ) { AskTrapActionFeed(cr); return; }
	category--;
	if( _CritCountItem( cr, TrapFoodTypes[category][answerI][0] ) > 0 ) {
		Item@ trap = cr.GetMap().GetItem( cr.Stat[ ST_LAST_CONT_ID ] );
		if(!valid(trap)) { cr.Say( SAY_NETMSG, "Что-то пошло не так - ловушка пропала." ); return; }
		trap.TrapPrice = TrapFoodTypes[category][answerI][1];
		trap.TrapFoodPID = TrapFoodTypes[category][answerI][0];
		trap.TrapTarget = category + 1;
		cr.DeleteItem( TrapFoodTypes[category][answerI][0], 1 );
		cr.Say( SAY_NETMSG, "Ловушка полностью готова. Отойдите подальше, что бы не отпугивать дичь!");
		cr.Say( SAY_EMOTE, "кладёт приманку в ловушку" );
		cr.Animate( 0, ANIM2_PICKUP, null, true, true );
		cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 25 - cr.Stat[ ST_STRENGTH ] - cr.Stat[ ST_INTELLECT ] );
	} else {
		cr.Say( SAY_NETMSG, "У вас нет приманки '" + TrapFoodNames[category][answerI] + "'.");
	}
}

bool isPlayersAroundTrap(Map@ map, Item@ trap) {
	Critter@[] crs;
    map.GetCrittersHex( trap.HexX, trap.HexY, trap.TrapDist * 2, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, crs );
	return crs.length() > 0;
}

int convertType( int from, int to, int value ) {
	int[][] proportions = {
		//Примания травоядных, имеем шансы приманить остальных:
		{ 100, 20, 33, 25,  5, 10, 5, 5 },
		//Примания падальщиков, имеем шансы приманить остальных:
		{ 33, 100, 50, 33, 25, 10, 5, 5 },
		//Примания хищников, имеем шансы приманить остальных:
		{ 10, 75, 100, 50, 10, 15, 5, 10 },
		//Примания всеядных, имеем шансы приманить остальных:
		{ 25, 25, 25, 100, 10, 20, 10, 10 },
		//Примания болотников, имеем шансы приманить остальных:
		{ 15, 60, 40, 80, 100, 30, 10, 25 },
		//Примания путников, имеем шансы приманить остальных:
		{ 5, 5, 5, 10, 5, 100, 50, 25 },
		//Примания бандитов, имеем шансы приманить остальных:
		{ 5, 5, 5, 10, 5, 80, 100, 40 },
		//Примания мутантов, имеем шансы приманить остальных:
		{ 5, 5, 5, 10, 5, 20, 40, 100 }
	};
	if(from < 0 || to < 0 ) Log("AHA! " + from + " " + to);
	return proportions[from][to] * value / 100;
}
# define OFF_e_spawnTrap
uint e_spawnTrap( uint[] @ values ) {
# ifdef OFF_e_spawnTrap
	return 0; //Заглушка, пока ловушки не доделаем.
# endif
# ifndef OFF_e_spawnTrap
	//Где-то здесь генерится null pointer access. Нет времени на дебаг.
	if( !valid(values) || values.length() < 5 ) return 0;
	Map@ map = GetMap(values[0]);
	if(!valid(map)) return 0; //Локация была удалена.
	Critter@ trapper = GetCritter(values[1]);
	Item@ trap = map.GetItem(values[2]);
	if(!valid(trap)) return 0; //Ловушка была убрана.
	if(!isPlayersAroundTrap(map,trap) && ( trap.TrapTarget > 0) ) {
		Item@ parent = ( trap.TrapParent == 0 ? trap : map.GetItem( trap.TrapParent ) );
		if(valid(parent) && parent.TrapParent != 0) parent.TrapParent = 0;
		trap.TrapQuality += trap.TrapPrice * ( trap.TrapType == TRAP_ROPE ? 2 : 1 );
		parent.TrapQuality += convertType( CLAMP(trap.TrapTarget-1,0,trap.TrapTarget), CLAMP(parent.TrapTarget-1,0,parent.TrapTarget), trap.TrapQuality) / ( trap.TrapType == TRAP_CAGE ? 1 : 2 );
		values[4] += trap.TrapQuality;
		trap.TrapQuality = 0;
		int[] area = CheckAreaMaps(null,map);
		int[] chances = { 0, 0, 0, 0, 0, 0, 0, 0 }; //{ "травоядные", "падальщики", "хищники", "всеядные", "болотники", "путники", "бандиты", "мутанты" }
		int skill = ( valid(trapper) ? trapper.ParamBase[SK_OUTDOORSMAN] : 100 ) / 10 * ( trap.TrapType == TRAP_CLAM ? 2 : 1 );
		int scored = Random( 0, skill );
		int id = Random(0,7);
		string debugInfo = "v0 " + values[0] + " v1 " + values[1] + " v2 " + values[2] + " v3 " + values[3] + " v4 " + values[4] + " %% parent " + parent.Id + " & trap " + trap.Id;
		/*
		for( int i = 0; i < chances.length(); i++ ) {
			for( int n = 1; n < area.length(); n++ )
				chances[i] += kindAreaChances[i][n] * area[n] / 10;
			int chch = Random( 0, chances[i] );
			if( scored * convertType( CLAMP(trap.TrapTarget-1,0,trap.TrapTarget), i, values[4]) + chch >= 100 && ( id == -1 || chances[id] < chch ) ) 
				id = i;
			//debugInfo += " || #" + i + " " + chances[i] + " scored [" + scored + "] * convert( " + trap.TrapTarget + ", " + i + ", " + values[4] + ") [" + convertType( trap.TrapTarget-1, i, values[4]) + "] + chances(" + i + ") [" + chances[i] + " -> " + chch + "]";
			chances[i] = chch;
		}
		*/
		string subInfo = "{id " + id + "} " + debugInfo;
		if( id >= 0 ) {
			//int lastID = trap.LastSpawn / 10;
			//if( trap.LastSpawn != 0 && chances[lastID] * 3 >= chances[id] ) id = lastID;
			//else trap.LastSpawn = id * 10 + ( trap.LastSpawn % 10 ); 
			int drop = Random( 0, values[4] );
			int k = Random(0, kindPrices[id].length()-1);
			/*
			for( k = 0; k < kindPrices[id].length(); k++ )
				if( drop < kindPrices[id][k] ) break;
			if( k >= kindPrices[id].length() ) k = kindPrices[id].length() - 1;
			subInfo += " || drop " + drop + " & k " + k + " & prices " + kindPrices[id][k];
			*/			
			int rrkp = Random( 0, kindPrices[id][k] );
			
			if( Random( 0, drop ) >= rrkp ) {
				//int lastK = trap.LastSpawn % 10;
				//if( lastK != 0 && Random( 0, kindPrices[id][lastK] ) * 3 >= rrkp ) k = lastK;
				//else trap.LastSpawn = id * 10 + k;
				SpawnKindPart( map, kindNames[id][k], trap.HexX, trap.HexY, Random(0,1) + Random(0,1) );
				map.SetText( trap.HexX, trap.HexY, COLOR_GRAY, kindSounds[id][k] );
				int resValues = values[4];
				values[4] = 0;//CLAMP( resValues - kindPrices[id][k], 0, resValues );
				trap.TrapPrice--;
				subInfo += " $$ price left " + trap.TrapPrice;	
				if( trap.TrapPrice <= 0 )  { DeleteItem(trap); Log("(DEL) " + subInfo); return 0; } //Ловушка своё отработала, её "съели".
			}
		} else map.SetText( trap.HexX + Random(-1,1), trap.HexY + Random(-1,1), COLOR_GRAY, "шорох" );
		Log("(OK!) " + subInfo);
	}
	values[3] += ( trap.TrapType == TRAP_ROPE ? 2 : 1 );
	if(values[3] > 360) { DeleteItem(trap); return 0; } //Ловушка своё отработала, один час.
	return REAL_SECOND(10);
# endif // OFF_e_spawnTrap
}

//Наш ивент:
uint e_spawnKind( uint[] @ values ) {
	//Проверяем, корректно-ли заданы входные параметры, с которыми был вызван ивент:
    if( !valid(values) || values.length() < 6 ) return 0;
	//Находим карту:
    Map@ map = GetMap( values[0] );
    if( !valid(map) ) return 0;
	//Смотрим наши рабочие координаты:
	int x = values[1];
	int y = values[2];
	//Спауним на приманку мобов:
	int type = values[3]; //Запоминаем наш выбранный тип:
	int skill = values[4]; //Смотрим наш скилл охотника:
	int iteration = values[5]; //Смотрим наш номер итерации:
	map.SetText( x+1, y+1, COLOR_GRAY, "["+(skill - iteration * ( type + 2 ))+"]" );
	map.SetText( x-1, y-1, COLOR_GRAY, "["+(type * 10 + iteration * 5)+"]" );
	if( Random( 0, 100 ) < skill - iteration * ( type + 2 ) ) { //Если ещё "клюёт":
		if( Random( 0, skill ) > type * 10 + iteration * 5 ) { //Если клюнуло в этот раз:
			//SpawnKindPart( map, kinds[type][0], x, y, Random( 1, 2 ) ); //Что бы вставить его "строку-имя" в скрипт сюда.. 
			//map.SetText( x, y, COLOR_GRAY, ":"+kindNames[type][2]+":" ); //И отобразить соответствующий звук тут.
		}
	} else { //Иначе сворачиваем шарманку:
		Item@ holder = map.GetItem(	x, y, 909 /*это номер прототипа popup, который изображал ловушку*/ );
		if(valid(holder)) DeleteItem(holder);
		return 0;
	}
	values[5]++;//Увеличиваем итерацию.
	return REAL_SECOND( 30 );
}

void unsafe_contmenu_callback( Critter& player, int id, int screenId, int actionId, string@ command, int[] @ myArr )
{
    // fastpanel
    /*if(screenId != 0)
       {
            switch(screenId)
            {
              case SCREEN_SKILLBOX :
            }
       }*/

    // myArr[0] = 123;
    // player.Say(SAY_NETMSG, "unsafe done");
    player.StatBase[ ST_LAST_CRIT_ID ] = myArr[ ARRAY_ID_INDEX ];
    player.StatBase[ ST_OBJECT_TYPE ] = myArr[ ARRAY_OBJ_INDEX ];
    player.StatBase[ ST_ITEM_HEXX ] = myArr[ ARRAY_ITEM_HEXX ];
    player.StatBase[ ST_ITEM_HEXY ] = myArr[ ARRAY_ITEM_HEXY ];
    player.StatBase[ ST_ITEM_PID ] = myArr[ ARRAY_ITEM_PID ];


    switch( myArr[ ARRAY_SCREEN_INDEX ] )
    {
    case SCREEN_BAG:
        player.ShowScreen( myArr[ ARRAY_SCREEN_INDEX ], id, "context_callback@ScreenBag" );
        break;
    case SCREEN_SKILLBOX:
        player.ShowScreen( myArr[ ARRAY_SCREEN_INDEX ], id, "context_callback@ScreenSkillbox" );
        break;
    case ACTION_PICK_ITEM:
        Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
        break;
    case ACTION_PICK_CRITTER:
        Actions( player, myArr[ ARRAY_SCREEN_INDEX ], myArr[ ARRAY_PICK_TYPE ] );
        break;
    case ACTION_DIR:
        Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
        break;
    case ACTION_TALK:
        Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
        break;
    case ACTION_FAST:
        Actions( player, myArr[ ARRAY_SCREEN_INDEX ], myArr[ ARRAY_SKILL_INDEX ] );
        break;
    default:
        break;
    }

}

#define BT_BRAHMIN         ( 15 )
#define BT_DOG             ( 16 )
#define BT_RAT_GRIZLY      ( 19 )
#define BT_SCORP           ( 22 )
#define BT_FLOATER         ( 23 )
#define BT_RAT             ( 24 )
#define BT_CENTAUR         ( 25 )
#define BT_CLAW            ( 51 )
#define BT_MANTIS          ( 52 )
#define BT_RAT_PIG         ( 55 )
#define BT_SCORP_SMALL     ( 59 )
#define BT_CLAW_SMALL      ( 60 )
#define BT_GECKO_SILVER    ( 67 )
#define BT_GECKO_GOLD      ( 68 )
#define BT_RAT_KING        ( 76 )
#define BT_ALIEN           ( 80 )
#define BT_GECKO_FIRE      ( 81 )
#define BT_ALIEN_QUEEN     ( 86 )
#define BT_GIGANT_ANT      ( 97 )
#define BT_CLAW_KING       ( 100 )

void unsafe_set_arcade_stat( Critter& cr, int locX, int locY, int type, string@ message, int[] @ p4 ) // if p1 > 0 | skill == exp to player
{
    string animIndex = "";
    // cr.Say(SAY_NETMSG, ""+type);
    switch( type )
    {
    case BT_RAT:
        cr.ParamBase[ ST_STRENGTH ] = 2;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 2;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 4;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 0;
        cr.ParamBase[ ST_ACTION_POINTS ] = 5;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 40;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 3;
        cr.ParamBase[ ST_HEALING_RATE ] = 20;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 1;

        cr.ParamBase[ SK_UNARMED ] = 100;
        cr.ParamBase[ SK_SNEAK ] = 200;

        animIndex = "masrat";
        break;

    case BT_MANTIS:
        cr.ParamBase[ ST_STRENGTH ] = 2;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 2;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 4;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 0;
        cr.ParamBase[ ST_ACTION_POINTS ] = 4;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 40;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 5;
        cr.ParamBase[ ST_HEALING_RATE ] = 10;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 1;

        cr.ParamBase[ SK_UNARMED ] = 150;
        cr.ParamBase[ SK_SNEAK ] = 150;

        animIndex = "mamant";
        break;

    case BT_GIGANT_ANT:
        cr.ParamBase[ ST_STRENGTH ] = 3;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 3;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 5;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 20;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 7;
        cr.ParamBase[ ST_HEALING_RATE ] = 10;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 170;
        cr.ParamBase[ SK_SNEAK ] = 130;

        animIndex = "maantt";
        break;

    case BT_RAT_PIG:
        cr.ParamBase[ ST_STRENGTH ] = 4;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 4;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 5;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 35;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 10;
        cr.ParamBase[ ST_HEALING_RATE ] = 6;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 180;
        cr.ParamBase[ SK_SNEAK ] = 110;

        animIndex = "mamurt";
        break;

    case BT_GECKO_SILVER:
        cr.ParamBase[ ST_STRENGTH ] = 4;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 4;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 5;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 35;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 20;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 16;
        cr.ParamBase[ ST_HEALING_RATE ] = 4;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 150;
        cr.ParamBase[ SK_SNEAK ] = 70;

        animIndex = "magko2";
        break;

    case BT_DOG:
        cr.ParamBase[ ST_STRENGTH ] = 5;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 5;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 5;
        cr.ParamBase[ ST_LUCK ] = 1;
        cr.ParamBase[ ST_MAX_LIFE ] = 35;
        cr.ParamBase[ ST_ACTION_POINTS ] = 7;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 25;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 7;
        cr.ParamBase[ ST_HEALING_RATE ] = 6;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 180;
        cr.ParamBase[ SK_SNEAK ] = 110;

        animIndex = "maddog";
        break;

    case BT_GECKO_GOLD:
        cr.ParamBase[ ST_STRENGTH ] = 5;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 5;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 40;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 25;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 16;
        cr.ParamBase[ ST_HEALING_RATE ] = 5;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 180;
        cr.ParamBase[ SK_SNEAK ] = 80;

        animIndex = "magcko";
        break;

    case BT_BRAHMIN:
        cr.ParamBase[ ST_STRENGTH ] = 5;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 5;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 70;
        cr.ParamBase[ ST_ACTION_POINTS ] = 12;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 4;
        cr.ParamBase[ ST_HEALING_RATE ] = 7;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 200;
        cr.ParamBase[ SK_SNEAK ] = 40;

        animIndex = "mabrom";
        break;

    case BT_RAT_GRIZLY:
        cr.ParamBase[ ST_STRENGTH ] = 6;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 6;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 60;
        cr.ParamBase[ ST_ACTION_POINTS ] = 7;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 25;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 16;
        cr.ParamBase[ ST_HEALING_RATE ] = 5;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 180;
        cr.ParamBase[ SK_SNEAK ] = 40;

        animIndex = "mamrat";
        break;

    case BT_RAT_KING:
        cr.ParamBase[ ST_STRENGTH ] = 6;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 6;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 80;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 16;
        cr.ParamBase[ ST_HEALING_RATE ] = 5;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 200;
        cr.ParamBase[ SK_SNEAK ] = 40;

        animIndex = "mabran";
        break;

    case BT_SCORP_SMALL:
        cr.ParamBase[ ST_STRENGTH ] = 6;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 6;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 80;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 12;
        cr.ParamBase[ ST_HEALING_RATE ] = 5;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 200;
        cr.ParamBase[ SK_SNEAK ] = 140;

        animIndex = "mascp2";
        break;

    case BT_SCORP:
        cr.ParamBase[ ST_STRENGTH ] = 7;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 7;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 2;
        cr.ParamBase[ ST_MAX_LIFE ] = 100;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 16;
        cr.ParamBase[ ST_HEALING_RATE ] = 4;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 210;
        cr.ParamBase[ SK_SNEAK ] = 80;

        animIndex = "mascrp";
        break;

    case BT_CLAW_SMALL:
        cr.ParamBase[ ST_STRENGTH ] = 7;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 7;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 6;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 80;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 25;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 10;
        cr.ParamBase[ ST_HEALING_RATE ] = 4;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 210;
        cr.ParamBase[ SK_SNEAK ] = 140;

        animIndex = "maclw2";
        break;

    case BT_ALIEN:
        cr.ParamBase[ ST_STRENGTH ] = 7;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 7;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 120;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 15;
        cr.ParamBase[ ST_HEALING_RATE ] = 4;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 240;
        cr.ParamBase[ SK_SNEAK ] = 80;

        animIndex = "malien";
        break;

    case BT_CENTAUR:
        cr.ParamBase[ ST_STRENGTH ] = 8;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 8;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 4;
        cr.ParamBase[ ST_MAX_LIFE ] = 150;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 15;
        cr.ParamBase[ ST_HEALING_RATE ] = 3;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 240;
        cr.ParamBase[ SK_SNEAK ] = 40;

        animIndex = "mathng";
        break;

    case BT_CLAW:
        cr.ParamBase[ ST_STRENGTH ] = 8;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 8;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 4;
        cr.ParamBase[ ST_MAX_LIFE ] = 170;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 25;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 13;
        cr.ParamBase[ ST_HEALING_RATE ] = 3;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 240;
        cr.ParamBase[ SK_SNEAK ] = 80;

        animIndex = "maclaw";
        break;

    case BT_FLOATER:
        cr.ParamBase[ ST_STRENGTH ] = 8;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 8;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 220;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 20;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 15;
        cr.ParamBase[ ST_HEALING_RATE ] = 2;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 3;

        cr.ParamBase[ SK_UNARMED ] = 250;
        cr.ParamBase[ SK_SNEAK ] = 100;

        animIndex = "masphn";
        break;

    case BT_ALIEN_QUEEN:
        cr.ParamBase[ ST_STRENGTH ] = 9;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 9;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 200;
        cr.ParamBase[ ST_ACTION_POINTS ] = 8;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 30;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 25;
        cr.ParamBase[ ST_HEALING_RATE ] = 1;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 5;

        cr.ParamBase[ SK_UNARMED ] = 260;
        cr.ParamBase[ SK_SNEAK ] = 120;

        animIndex = "maquen";
        break;

    case BT_CLAW_KING:
        cr.ParamBase[ ST_STRENGTH ] = 9;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 9;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 250;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 20;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 15;
        cr.ParamBase[ ST_HEALING_RATE ] = 1;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 5;

        cr.ParamBase[ SK_UNARMED ] = 240;
        cr.ParamBase[ SK_SNEAK ] = 80;

        animIndex = "madeth";
        break;

    case BT_GECKO_FIRE:
        cr.ParamBase[ ST_STRENGTH ] = 9;
        cr.ParamBase[ ST_PERCEPTION ] = 6;
        cr.ParamBase[ ST_ENDURANCE ] = 9;
        cr.ParamBase[ ST_CHARISMA ] = 1;
        cr.ParamBase[ ST_INTELLECT ] = 1;
        cr.ParamBase[ ST_AGILITY ] = 7;
        cr.ParamBase[ ST_LUCK ] = 3;
        cr.ParamBase[ ST_MAX_LIFE ] = 150;
        cr.ParamBase[ ST_ACTION_POINTS ] = 6;
        cr.ParamBase[ ST_ARMOR_CLASS ] = 15;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = 10;
        cr.ParamBase[ ST_HEALING_RATE ] = 4;
        cr.ParamBase[ ST_CRITICAL_CHANCE ] = 1;

        cr.ParamBase[ SK_UNARMED ] = 240;
        cr.ParamBase[ SK_SNEAK ] = 100;

        animIndex = "mafire";
    default:
        animIndex = "hmjmps";
        break;
    }

    cr.ParamBase[ ST_CURRENT_HP ] = cr.ParamBase[ ST_MAX_LIFE ] * 0.1;
    cr.ParamBase[ PE_AWARENESS ] = 0;
    skin( cr, type );

    cr.RunClientScript( "client_screen_additional@SendAnimIndex", locX, locY, type, animIndex, null );
}

import uint  GetCellMap( uint16 x, uint16 y ) from "world";
import uint GenerateWasteland( Critter& cr, uint8 x, uint8 y ) from "mapgen_wasteland";

void unsafe_set_arcade_start( Critter& cr, int x, int y, int p2, string@ message, int[] @ p4 )
{
    int mapId = GetCellMap( x, y );

    if( mapId == -1 )
    {
        mapId = GenerateWasteland( cr, x * 0.1, y * 0.1 );
    }

    Map@ map = GetMap( mapId );
    if( @map == null )
        return;

    cr.TransitToMap( map.Id, 0 );

    cr.StatBase[ ST_ARCADE_DEAD ] = 0;
    cr.StatBase[ ST_CRSTATUS ] = 0;
}

// teaching

#include "_ltp.fos"

# define IDLE_TEACH_TIME	60 * __TimeMultiplier
#define TEACHER_BASE_WAIT    ( 60000 )
#define STR_SKILLS           ( 10200 )

string[] skillNames = { "Легкое оружие", "Тяжелое оружие", "Энергооружие", "Рукопашная", "Xолодное оружие", "Метательное оружие", "Санитар", "Доктор", "Скрытность", "Взлом замков", "Воровство", "Ловушки", "Наука", "Ремонт", "Красноречие", "Торговля", "Азартные игры", "Скиталец" };

bool ltp_teach_inited = false;


void unsafe_teach( Critter& cr, int skill, int p1, int p2, string@ message, int[] @ p4 ) // if p1 > 0 | skill == exp to player
{
    if( cr.Param[ QST_GAMEMODE ] != GAME_ADVENTURE )
    {
        cr.Say( SAY_NETMSG, "Запрещено не квентовым персонажам." );
        return;
    }
    if( p1 > 0 )                                     // added exp to critter
    {
        //int studyExp = cr.Stat[ ST_STUDY_EXP ]; // = (cr.StatBase[ST_STUDY_EXP] > 100 ? cr.StatBase[ST_STUDY_EXP] : 100);
        if( skill > cr.Stat[ ST_STUDY_EXP ] || skill <= 0 )
        {
            cr.Say( SAY_NETMSG, "Недостаточно опыта." );
            return;
        }
        Critter@ target = GetCritter( p2 );
        if( @target is null )
            return;
        if( cr.Id == target.Id )
        {
            cr.Say( SAY_NETMSG, "Нельзя дать опыт самому себе." );
            return;
        }
        if( target.IsNpc() )
        {
            cr.Say( SAY_NETMSG, "Нельзя дать опыт не игровому персонажу." );
            return;
        }
		target.StatBase[ST_EXPERIENCE] += skill;
		/*
		if( target.StatBase[ ST_EXPERIENCE_MULTIPLIER ] >= 0)
			target.StatBase[ST_EXPERIENCE] += skill * ( 1 + target.StatBase[ ST_EXPERIENCE_MULTIPLIER ] );
		else
			target.StatBase[ST_EXPERIENCE] += skill / ( 1 - target.StatBase[ ST_EXPERIENCE_MULTIPLIER ] );
		*/
        cr.StatBase[ ST_STUDY_EXP ] = CLAMP( cr.StatBase[ ST_STUDY_EXP ] - skill, 0, 10000 );

        cr.Say( SAY_NETMSG, "Вы наградили юзернеим " + skill + " очками опыта" );
        return;

    }

    if( cr.Skill[ skill ] < 120 )
    {
        cr.Say( SAY_NETMSG, "Вашего навыка недостаточно для обучения." );
        return;
    }

    /*
	if( !ltp_teach_inited )
        ltp_teach_init();
	*/

    bool validSKill = false;
    /*for( uint8 i = 0; i < 4; i++ )
    {
        if( cr.Param[ 226 + i ] == skill )
        {
            validSKill = true;
        }
    }*/

    if( validSKill ) {
		if( cr.GetTimeEvents( CTE_TEACH, null, null, null ) > 0 ) 
		{
			cr.EraseTimeEvents(CTE_TEACH);
			cr.Say( SAY_NETMSG, "Вы прервали обучение." );
			return;
		}
		else 
		{
			cr.AddTimeEvent( "cte_Teach", 60 * __TimeMultiplier, CTE_TEACH, skill ); //Тикает каждую минуту.
		}
	}
    else
        cr.Say( SAY_NETMSG, "Обучение навыкам только по отыгрышу." );
}

void ltp_teach_init()
{
    LTPREG( LTP_TEACH, process_teach )
    ltp_teach_inited = true;
}

uint cte_Teach( Critter& cr, int identifier, uint& rate )
{
	int p1,p2,p0 = rate;
	return process_teach(cr, p0, p1, p2);
}

uint process_teach( Critter@ cr, int& param0, int& param1, int& param2 )
{
    //LTPROCESSD( LTP_TEACH )
    GameVar@ wearinessMaster = GetLocalVar( LVAR_weariness, cr.Id );
	int maxWeariness = ( cr.ParamBase[ ST_ENDURANCE ] + cr.ParamBase[ ST_STRENGTH ] ) * 100 * (1 + cr.TraitBase[ TRAIT_SKILLED ]); //100*(STR+END) [x2 for skilled]
    if( wearinessMaster.GetValue() < maxWeariness )
        wearinessMaster.opAddAssign( 100 - cr.ParamBase[ ST_CHARISMA ] * 5 - cr.ParamBase[ ST_INTELLECT ] * 5 + Random( 0, 25 ) );//(100 - 5*CHA - 5*INT + RND*25)
    else
    {
        cr.Say( SAY_NETMSG, "Вы слишком устали, что бы учить." );
        return 0;
    }
	cr.Say( SAY_NETMSG, "Вы поделились своими знаниями." );

    Critter@[] crs;
    cr.GetMap().GetCrittersHex( cr.HexX, cr.HexY, 7, FIND_LIFE, crs );

    uint8 length = crs.length();
    if( length <= 0 )
        return 0;
    uint16 skillTeacher = cr.Skill[ param0 ];
	uint16 realTeachingSkill, TeachingEfficiency;
    for( uint8 i = 0; i < length; i++ )
    {
        if( cr.Id != crs[ i ].Id )
        {
			uint16 skillStude = crs[ i ].Skill[ param0 ];
			if( skillStude < 100 ) TeachingEfficiency = 6;
			//Правка 02.10.18 от overc0de для PRETOR:
			if( skillStude > 100 ) {
				crs[ i ].Say( SAY_NETMSG, "Вы не узнали ничего нового." );
				continue;
			}
			//Устарело после этой правки:
			else if( skillStude < 200 ) TeachingEfficiency = 4;
			else if( skillStude < 300 ) TeachingEfficiency = 3;
			realTeachingSkill = cr.Skill[ SK_SPEECH ] * TeachingEfficiency / 2;
			if( skillTeacher > realTeachingSkill ) skillTeacher = realTeachingSkill;

            if( skillTeacher >= skillStude )
            {
                GameVar@ wearinessSlave = GetLocalVar( LVAR_weariness, crs[i].Id );
				int maxWearinessSlave = ( crs[i].ParamBase[ ST_ENDURANCE ] + crs[i].ParamBase[ ST_STRENGTH ] ) * 100 * (1 + crs[i].TraitBase[ TRAIT_SKILLED ]); //100*(STR+END) [x2 for skilled]
                if( wearinessSlave.GetValue() < maxWearinessSlave )
                {
					uint16 skillDifference = skillTeacher - skillStude;
                    uint16 skillBase = skillDifference > 0 ? skillDifference : 1;
                    if( skillBase > 0 )
                    {
						wearinessSlave.opAddAssign( 100 - cr.ParamBase[ ST_PERCEPTION ] * 5 - cr.ParamBase[ ST_INTELLECT ] * 5 + Random( 0, 25 ) );//(100 - 5*PER - 5*INT + RND*25)
                        int maxSkillGain = CLAMP( crs[ i ].Stat[ ST_INTELLECT ] / ( 3 - cr.TraitBase[ TRAIT_SKILLED ] ), 1, 6 );//INT/3 [/2 for skilled]
                        crs[ i ].SkillBase[ param0 ] += CLAMP( skillBase, 1, maxSkillGain );
                        crs[ i ].Say( SAY_NETMSG, "Вы научились лучше обращаться с навыком " + skillNames[ param0 - 200 ] + "." );
                    }
                    else
                    {
                        crs[ i ].Say( SAY_NETMSG, "Вы ничему не научились." );
                    }
                }
                else
                {
                    crs[ i ].Say( SAY_NETMSG, "Вы слишком устали." );
                }
            }
            else
            {
                crs[ i ].Say( SAY_NETMSG, "Этому учителю нечему учить вас." );
            }
        }
    }

    return 0; //60 * __TimeMultiplier; //Тикает каждую минуту.
}

// teaching end

void unsafe_fastpanel_say( Critter& player, int p0, int p1, int p2, string@ message, int[] @ p4 )
{
    if( message.length() > 0 )
    {
        uint8 sayType = 0;
        switch( p0 )
        {
        case 1:
            sayType = SAY_NORM;
            break;
        // case 2 : sayType = SAY_SOCIAL; break;
        case 2:
            sayType = SAY_SHOUT;
            break;
        case 3:
            sayType = SAY_EMOTE;
            break;
        case 4:
            sayType = SAY_WHISP;
            break;
        default:
            sayType = SAY_NETMSG;
            break;
        }

        if( sayType >= SAY_NORM && sayType <= SAY_RADIO )
        {
            for( uint i = 0, len = message.length(); i < len; i++ )
            {
                uint8 chr = message[ i ];
                if( chr < 32 || ( chr > 34 && chr < 42 ) || ( chr > 42 && chr < 44 ) || chr == 47 || ( chr > 57 && chr < 63 ) || chr == 64 || ( chr > 90 && chr < 97 ) || ( chr > 122 && chr < 192 && chr != 168 && chr != 184 ) )
                {
                    player.Say( SAY_NETMSG, "В сообщениии есть запрещенные символы." );
                    return;
                }
            }
        }

        player.Say( sayType, "" + message );
    }
}

void SendFastPanelInfo( Critter& cr, bool type )
{
    file   f;
    string word = "", word2 = "";
    uint   pos = 0;
    // cr.Say(SAY_NETMSG, "start sendin");
    if( f.open( PATH_TO_FASTPANEL_FOLDER + cr.Id, "r" ) == 0 )
    {
        // cr.Say(SAY_NETMSG, "file open successful");
        f.setPos( 0 );
        while( !f.isEndOfFile() )      // || count > length))
        {
            pos = f.getPos();
            f.readLine( word );
            word2 += word;

//				cr.Say(SAY_NETMSG, word);
//				cr.Say(SAY_NETMSG, word);
        }
        f.close();
    }
    // if(word2 != "")	cr.RunClientScript("client_screen_fastpanel@LoadPanel", 0, 0, 0, word2, null); else cr.Say(SAY_NETMSG, "error with sending fastpanel info");
    if( !type )
    {
        if( pos != 0 )
            cr.RunClientScript( "client_screen_fastpanel@GetServerFileSize", pos, 0, 0, "", null );
    }
    else
    {
        if( word2 != "" )
            cr.RunClientScript( "client_screen_fastpanel@LoadPanel", 0, 0, 0, word2, null );
        else
            cr.Say( SAY_NETMSG, "error with sending fastpanel info" );
    }
}

void unsafe_fastpanel_save( Critter& player, int p0, int p1, int p2, string@ info, int[] @ p4 )
{
    file f;
    if( f.open( PATH_TO_FASTPANEL_FOLDER + player.Id, "w" ) == 0 )
    {
        // f.setPos(0);
        f.writeString( info );
    }
    f.close();
}

void unsafe_send_fastpanel( Critter& cr, int p0, int p1, int p2, string@ info, int[] @ p4 )
{
    file   f;
    string word = "", word2 = "";
    uint   pos = 0;
    // cr.Say(SAY_NETMSG, "start sendin");
    if( f.open( PATH_TO_FASTPANEL_FOLDER + cr.Id, "r" ) == 0 )
    {
        // cr.Say(SAY_NETMSG, "file open successful");
        f.setPos( 0 );
        while( !f.isEndOfFile() )      // || count > length))
        {
            pos = f.getPos();
            f.readLine( word );
            word2 += word;

//				cr.Say(SAY_NETMSG, word);
//				cr.Say(SAY_NETMSG, word);
        }
        f.close();
    }
    // if(word2 != "")	cr.RunClientScript("client_screen_fastpanel@LoadPanel", 0, 0, 0, word2, null); else cr.Say(SAY_NETMSG, "error with sending fastpanel info");
    if( p0 == 0 )
    {
        if( pos != 0 )
            cr.RunClientScript( "client_screen_fastpanel@GetServerFileSize", pos, 0, 0, "", null );
    }
    else
    {
        if( word2 != "" )
            cr.RunClientScript( "client_screen_fastpanel@LoadPanel", 0, 0, 0, word2, null );
        //else
        //    cr.Say( SAY_NETMSG, "error with sending fastpanel info" );
    }
    // SendFastPanelInfo(player, true);
}

void unsafe_openCodeDoor( Critter& player, int itemId, int code, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = GetItem( itemId );
    if( @item == null )
    {
        return;
    }
    if( ( player.HexX < item.HexX + 2 || player.HexX > item.HexX - 2 ) && ( player.HexY < item.HexY + 2 || player.HexY > item.HexY - 2 ) )
    {
        if( param2 != 0 ) {
			uint max = pow( 10, item.Val1-1 );
			if( code > 65535 )
				player.Say( SAY_NETMSG, "Код не может быть больше 65535!" );
            if( code < max )
            {
                item.Val4 = code;
                player.Say( SAY_NETMSG, "Вы установили новый код : " + code );
				player.RunClientScript( "client_screen_codedoor@HideScreen", 0, 0, 0, "", null );
                return;
            }
            else
            {
                player.Say( SAY_NETMSG, "Не допустимый код" );
                return;
            }
		}
        if( item.Val4 == code )
        {
            if( _LockerIsClose( item ) )
            {
                item.LockerOpen();
                player.RunClientScript( "client_screen_codedoor@HideScreen", 0, 0, 0, "", null );
            }

        }
        else
            player.Say( SAY_NETMSG, "Не верный код" );
    }
    else
        player.Say( SAY_NETMSG, "Слишком далеко" );
}

import void LoadClientHistoryBase( Critter& cr, bool all ) from "history_menu";
import void SaveCritterHistory( Critter& cr, string saveText ) from "history_menu";
import void LoadCritterHistory( Critter& cr ) from "history_menu";

void unsafe_history_load( Critter& player, int loadType, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( player.GetAccess() < 2 )
    {
        player.Say( SAY_NETMSG, "hey dude. don't try to hack this. just gohome." );
        Log( "hack detected player " + player.Id + " name " + GetPlayerName( player.Id ) + " try crack history menu" );
        return;
    }
    Critter@ cr = GetCritter( param1 );
    switch( loadType )
    {
    case 0:
        LoadClientHistoryBase( player, false );
        break;
    case 1:
        LoadClientHistoryBase( player, true );
        break;
    case 2:
        LoadCritterHistory( @cr != null ? cr : player );
        break;
    }
}

void unsafe_history_save( Critter& player, int param0, int param1, int param2, string@ saveText, int[] @ param4 )
{
    if( saveText == "" )
    {
        player.Say( SAY_NETMSG, "Oops! Same error here!" );
        return;
    }
    SaveCritterHistory( player, saveText );
}

void unsafe_hotkey_command( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{

    string type = "", command = "";
    string@[]@ cmd = split( param3, "*" );
	if( @cmd !is null )
    {
        command = cmd[ 0 ];
        type = cmd.length() > 1 ? cmd[ 1 ] : "";
    }
    if( type == "TEXT" )
    {
        if( __FullSecond < uint( player.Timeout[ TO_SAY ] ) )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, 12601 );
            return;
        }
        player.TimeoutBase[ TO_SAY ] = SAY_TIMEOUT;
        if( command.length() > 64 )
            command = substring( command, 0, 64 );
        string@[] @ words = split( command, "_" );
        string text = join( words, " " );
        player.Say( /*(param4[0]>3)?SAY_RADIO:*/ ( param4[ 0 ] * 2 + 1 ), text ); // Param4[0]: 0 - norm, 1 - shout, 2 - emote, 3 - whisp
    }
    else
    {
        if( command == "RELOAD" )
        {
            Item@[] weapon;
            player.GetItems( SLOT_HAND1, weapon );
            if( not valid( weapon[ 0 ] ) )
                return;
            Item@ ammo = player.GetItem( weapon[ 0 ].AmmoPid, SLOT_INV );

            if( valid( ammo ) && weapon[ 0 ].AmmoCount < weapon[ 0 ].Proto.Weapon_MaxAmmoCount && player.Stat[ ST_CURRENT_AP ] >= 2 )
            {
                critter_reload_weapon( player, weapon[ 0 ], ammo );
                player.Action( ACTION_RELOAD_WEAPON, 0, weapon[ 0 ] );
                player.ParamBase[ ST_CURRENT_AP ] -= 200;
            }
            else if( not valid( ammo ) && weapon[ 0 ].AmmoCount > 0 && player.Stat[ ST_CURRENT_AP ] >= 2 )
            {
                critter_reload_weapon( player, weapon[ 0 ], null );
                player.Action( ACTION_RELOAD_WEAPON, 0, weapon[ 0 ] );
                player.ParamBase[ ST_CURRENT_AP ] -= 200;
            }
        }

        else if( command == "USE_SELF" )
        {
            Item@ use_item = player.GetItem( param4[ 0 ], -1 );
            if( valid( use_item ) && player.Stat[ ST_CURRENT_AP ] >= 2 )
            {
                critter_use_item( player, use_item, null, null, null, 0 );
                player.Action( ACTION_USE_ITEM, 0, use_item );
                player.ParamBase[ ST_CURRENT_AP ] -= 200;
            }
        }

        else
            Log( "Chiter detected: " + GetPlayerName( player.Id ) );
    }
}

void unsafe_hex_attack( Critter& player, int hexX, int hexY, int param2, string@ command, int[] @ param4 )
{

    Map@ map = player.GetMap();

    if( map is null )
        return;

    Item@[] realweapons;
    player.GetItems( SLOT_HAND1, realweapons );
    if( realweapons.length() == 0 || ( @realweapons.first() is null ) )
        return;
    Item@ realweapon = @realweapons.first();

    uint8 			mode = realweapon.Mode;
    ProtoItem@ 	weapon = GetProtoItem( realweapon.GetProtoId() ),
    // 				weapon = player.GetSlotProto(SLOT_HAND1, mode);
					ammo = null;


    uint16 toHx = hexX, toHy = hexY;
    int    dist = GetDistantion( player.HexX,  player.HexY, hexX, hexY );
    map.GetHexCoord( player.HexX,  player.HexY, toHx, toHy,  0.0f, dist );
    if( ( uint16( hexX ) != toHx ) || ( uint16( hexY ) != toHy ) )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 104 );
        return;
    }

    bool isFlareGun = ( realweapon.AmmoPid == PID_FLARE_GUN_AMMO ) && ( mode == 1 ); // pm added flare gun
    bool isRocket = ( realweapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realweapon.AmmoPid == PID_ROCKET_AP ) || ( realweapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realweapon.AmmoPid == PID_GRENADELAUNCHER_AMMO );
    if( _WeaponSkill( weapon, mode ) != SK_THROWING && !isRocket && !isFlareGun ) return;
 
    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( _WeaponSkill( weapon, mode ) == SK_THROWING )
	{
		int val0 = player.Stat[ ST_STRENGTH ] + 2 * player.Perk[ PE_HEAVE_HO ];
		val0 = 3 * MIN( 10, val0 );
        wpnMaxDist = MIN( wpnMaxDist, val0 );
	}	
    if( dist > wpnMaxDist )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 102 );
        return;
    }


    if( player.Stat[ ST_CURRENT_AP ] < int( _WeaponApCost( weapon, mode ) ) )
        return;

    if( weapon.Weapon_MaxAmmoCount > 0 )
    {
        if( realweapon.AmmoCount == 0 )
            return;
        else
            @ammo = GetProtoItem( realweapon.AmmoPid );
    }


    Critter@ target = map.GetCritter( uint16( hexX ), uint16( hexY ) );

    player.ParamBase[ ST_CURRENT_AP ] -= _WeaponApCost( weapon, mode ) * 100;
    // HIT_LOCATION_UNCALLED
    CombatAttack( player, target, weapon, mode, ammo, uint16( hexX ), uint16( hexY ) );
}

int[] zomb_skins = { 33, 36, 37, 39, 40, 41, 43, 48, 57, 61, 62, 63, 64 };


void zomb( Critter& player, int on, int param1, int param2 )
{
    if( on == 0 )
    {
        __Zombies = false;
        player.Say( SAY_NETMSG, "Зомби-мод отключен." );
    }
    else
    {
        __Zombies = true;
        player.Say( SAY_NETMSG, "Зомби-мод включен." );
    }
}

import void skin( Critter& cr, int crType ) from "skins";

void unsafe_zombie( Critter& player, int hexX, int hexY, int param2, string@ lex, int[] @ param4 )
{
    if( !__Zombies )
    {
        player.Say( SAY_NETMSG, "Зомби-мод отключен." );
        return;
    }

    Map@ map = player.GetMap();
    Map@ modoc = GetMapByPid( MAP_MODOC_Center, 0 );
    if( modoc is null )
        return;

    if( player.Param[ ST_BODY_TYPE ] == BT_ZOMBIE )
    {
        if( player.IsDead() )
        {
            Item@[] items;
            if( player.GetItems( 0, items ) > 0 )
                DeleteItems( items );

            player.ParamBase[ DAMAGE_EYE ] = 0;
            player.ParamBase[ DAMAGE_RIGHT_ARM ] = 0;
            player.ParamBase[ DAMAGE_LEFT_ARM ] = 0;
            player.ParamBase[ DAMAGE_RIGHT_LEG ] = 0;
            player.ParamBase[ DAMAGE_LEFT_LEG ] = 0;
            player.ToLife();
            player.ParamBase[ ST_CURRENT_HP ] = player.Param[ ST_MAX_LIFE ];
            player.ParamBase[ TO_REPLICATION ] = -1;
            player.ParamBase[ TO_DEAD ] = __FullSecond + REAL_SECOND( Random( 30, 60 ) );
            player.ParamBase[ ST_WALK_TIME ] = Random( 200, 800 );
            player.TransitToMap( modoc.Id, 0 );
            uint zsl = zomb_skins.length();
            if( zsl > 0 )
                skin( player, zomb_skins[ Random( 0, zsl - 1 ) ] );
        }

    }
    else if( map is null or map.GetProtoId() != 51 )
    {
        return;
    }
    else
    {
        player.ParamBase[ ST_BODY_TYPE ] = BT_ZOMBIE;

        uint zsl = zomb_skins.length();
        if( zsl > 0 )
            skin( player, zomb_skins[ Random( 0, zsl - 1 ) ] );

        player.ParamBase[ ST_MAX_LIFE ] += 100;
        player.ParamBase[ ST_CURRENT_HP ] += 100;
        player.ParamBase[ MODE_NO_RUN ] = 1;
        player.ParamBase[ ST_WALK_TIME ] = Random( 200, 800 );
        player.ParamBase[ TO_DEAD ] = __FullSecond + REAL_MINUTE( 2 );
        player.ParamBase[ ST_REPLICATION_TIME ] = -1;
        player.TransitToMap( modoc.Id, 0 );
    }
}


void unsafe_stopMob( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
    for( uint i = param0 * 10, ii = 10 + param0 * 10; i < ii; i++ )
    {
        Critter@ controlled = GetCritter( vals[ i ] );
        if( valid( controlled ) && uint( controlled.Param[ MERC_MASTER_ID ] ) != player.Id )
        {
            player.Say( SAY_NETMSG, "Нет доступа." );
            return;
        }
        if( valid( controlled ) && controlled.IsNpc() )
        {
            controlled.ErasePlane( -1, true );
            controlled.ClearEnemyStack();
            controlled.EraseTimeEvents( 9 );
            controlled.SetDir( GetDirection( controlled.HexX, controlled.HexY, param1, param2 ) );
        }
    }
}

void unsafe_moveMob( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
    for( uint i = param0 * 10, ii = 10 + param0 * 10; i < ii; i++ )
    {
        Critter@ controlled = GetCritter( vals[ i ] );
        if( valid( controlled ) && uint( controlled.Param[ MERC_MASTER_ID ] ) != player.Id )
        {
            player.Say( SAY_NETMSG, "Нет доступа." );
            return;
        }
        if( valid( controlled ) && controlled.IsNpc() )
        {
            controlled.ErasePlane( -1, true );
            AddWalkPlane( controlled, 1, param1 + Random( -i, i ), param2 + Random( -i, i ), GetDirection( controlled.HexX, controlled.HexY, param1, param2 ), ( @param3 !is null ), 0 );
            if( param0 == 0 )
                controlled.ClearEnemyStack();
        }
    }
}

void unsafe_attackMob( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
    Critter@ target = GetCritter( param0 );
    for( uint i = param2 * 10, ii = 10 + param2 * 10; i < ii; i++ )
    {
        Critter@ controlled = GetCritter( vals[ i ] );
        if( valid( controlled ) && uint( controlled.Param[ MERC_MASTER_ID ] ) != player.Id )
        {
            player.Say( SAY_NETMSG, "Нет доступа." );
            return;
        }
        if( valid( controlled ) && valid( target ) && controlled.IsNpc() )
        {
            controlled.ErasePlane( -1, true );
            AddAttackPlane( controlled, 0, target, __RunOnCombat );
            controlled.AddEnemyInStack( target.Id );
        }
    }
}

import uint follow( Critter& cr, int master, uint& rate ) from "raiders";

void unsafe_BreakControl( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
	if(player.GetAccess() < ACCESS_MODER ) return;
	Critter@ target = GetCritter( param0 );
	if(valid(target)&&!target.IsPlayer())
		target.ModeBase[ MODE_NO_HOME ] = 0;
}

void unsafe_chaseMob( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
    Critter@ target = GetCritter( param0 );
    for( uint i = param2 * 10, ii = 10 + param2 * 10; i < ii; i++ )
    {
        Critter@ controlled = GetCritter( vals[ i ] );
        if( valid( controlled ) && uint( controlled.Param[ MERC_MASTER_ID ] ) != player.Id )
        {
            player.Say( SAY_NETMSG, "Нет доступа." );
            return;
        }
        if( valid( controlled ) && valid( target ) && controlled.IsNpc() )
        {
            controlled.ErasePlane( -1, true );
            controlled.ModeBase[ MODE_NO_HOME ] = 1;
            controlled.StatBase[ ST_KILLER_PERSON ] = target.Id;
            controlled.AddTimeEvent( "follow", 30, 9 );
        }
    }
}

import void say( Critter& player, int param0, int param1, int param2 ) from "gm";

void unsafe_say( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ controlled = GetCritter( param0 );
    if( param1 != 1 && param1 != 5 && controlled.IsPlayer() )
    {
        player.Say( SAY_NETMSG, "Нет доступа." );
        return;
    }
    if( valid( controlled ) && uint( controlled.Param[ MERC_MASTER_ID ] ) != player.Id )
    {
        player.Say( SAY_NETMSG, "Нет доступа." );
        return;
    }
    say( player, param0, param1, 0 );
}

void unsafe_sleep( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( !valid( player ) )
        return;
	
	if( player.GetTimeEvents( CTE_WARNING, null, null, null ) != 0 ) //Должен лежать.
	{
		if( player.IsDead() )
			player.Say( SAY_NETMSG, "Вас уже уложили как следует, можете не рыпаться." );
		if( !player.IsKnockout() )
			player.Say( SAY_NETMSG, "Вы и так твердо стоите на ногах." );
		player.StatBase[ ST_CURRENT_AP ] = 0;
		player.EraseTimeEvents( CTE_WARNING );
		return;
	}
    if( player.GetTimeEvents( CTE_WARNING, null, null, null ) == 0 ) //Должен стоять.
    {
		if( player.IsDead() ) {
			player.Say( SAY_NETMSG, "Вас уже уложили как следует, можете не рыпаться." );
			return;
		}
		if( player.IsKnockout() ) {
			player.Say( SAY_NETMSG, "Вы и так лежите на земле, сначала встаньте на ноги." );
			return;
		}
        player.StatBase[ ST_CURRENT_AP ] = -100000;
        player.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( param0 == 0 ) ), 5, player.HexX, player.HexY );
        player.Say( SAY_NETMSG, "Вы легли на " + ( param0 == 0 ? "спину" : "живот" ) + ".");
        player.AddTimeEvent( "cte_sleep", 0, CTE_WARNING, 0 );
        return;
    }
}

uint cte_sleep( Critter& player, int identifier, uint& rate )
{
	if( player.IsDead() ) {
		player.Say( SAY_NETMSG, "Вас уложили как следует." );
		player.StatBase[ ST_CURRENT_AP ] = 0;
		return 0;
	}
	if( !player.IsKnockout() ) {
		player.Say( SAY_NETMSG, "Вы встали на ноги." );
		player.StatBase[ ST_CURRENT_AP ] = 0;
		return 0;
	}
    if( player.StatBase[ ST_CURRENT_AP ] >= -50000 )
        player.StatBase[ ST_CURRENT_AP ] = -100000;
    return 100;
}

import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";

import void DragAndDrop( Critter& cr, Critter@ target ) from "handcuffs";

void unsafe_itemthrow( Critter& player, int _x, int _y, int param2, string@ param3, int[] @ param4 )
{
    if( player.IsDead() || player.IsKnockout() || player.Timeout[ TO_SK_STEAL ] > 0 ) return;

	Map@ map = player.GetMap();
	if(!valid(map))return;

	Item@ trowable = player.GetItem( 0, SLOT_HAND1 );
	if(!valid(trowable))return;

	int amount = trowable.GetCount();

	int maxDist = 6;
	float alpha = 10;
	uint16 x0 = _x, y0 = _y;
	
	int dist = GetDistantion( player.HexX, player.HexY, x0, y0 );
	map.GetHexCoordWall( player.HexX, player.HexY, x0, y0, alpha, dist );
	//Режем до стен, что бы не бросали сквозь непростреливаемые области.
	uint16 x = x0, y = y0;
	
	if( dist > maxDist * 2 ) 
	{
		x = player.HexX;
		y = player.HexY;
		player.Say(SAY_NETMSG, "Замахнувшись, вы усомнились что сможете попасть в цель и просто подбросили передмет в руке.");
	}
	
	bool tooFar = dist > maxDist;
	if( tooFar ) dist = maxDist;
	bool isFar = dist > 3;
	//Сила броска, измеряется в граммах:
	float force = 
		player.Stat[ST_STRENGTH] * player.ParamBase[ ST_ENDURANCE ] * 100 + 
		( player.ParamBase[SK_UNARMED] + player.ParamBase[SK_MELEE_WEAPONS] + player.ParamBase[SK_OUTDOORSMAN] ) * 10 +
		player.ParamBase[SK_THROWING] * 30;
	//Меткость, измеряется в граммах, ага, знаю. В них самых:
	float accuracy = 
		player.Stat[ST_AGILITY] * player.Stat[ST_PERCEPTION] * 100 + 
		( player.ParamBase[SK_SMALL_GUNS] + player.ParamBase[SK_BIG_GUNS] + player.ParamBase[SK_ENERGY_WEAPONS] ) * 10 +
		player.ParamBase[SK_THROWING] * 30;
	
	Item@[][] hands; hands.resize(2);
	uint[] count = { ( player.GetItems( SLOT_HAND1, hands[0]) ), ( player.GetItems( SLOT_HAND2, hands[1] ) ) };
	bool[] freeHand = { ( count[0] > 0 ), ( count[1] > 0 ) };

	//Навык ловки объекта:
	float catching = 
		( ( freeHand[0] ? 1 : 0 ) + ( freeHand[1] ? 0.5 : 0 ) ) *
		( player.Stat[ST_STRENGTH] * player.ParamBase[ ST_ENDURANCE ] * 100 + 
		player.Stat[ST_AGILITY] * player.Stat[ST_PERCEPTION] * 100 + 
		( player.ParamBase[SK_UNARMED] + player.ParamBase[SK_MELEE_WEAPONS] + player.ParamBase[SK_OUTDOORSMAN] ) * 10 +
		( player.ParamBase[SK_SMALL_GUNS] + player.ParamBase[SK_BIG_GUNS] + player.ParamBase[SK_ENERGY_WEAPONS] ) * 10 +
		player.ParamBase[SK_THROWING] * 30 );
	
	//Сложность броска == суммарному весу объекта. Сопротивлением воздуха и плотностью бросаемых объектов можно пренебречь.
	float difficulty = trowable.Proto.Weight * amount * ( ( dist + 1 ) * 3 / maxDist );
	
	//player.Say(SAY_NETMSG, "r" + (dist + 1) + " m" + amount + " w" + trowable.Proto.Weight + " d" + difficulty + " c" + catching + " a" + accuracy + " f"+ force );

	int dir = GetDirection( player.HexX, player.HexY, x, y );

	bool tooWeak = Random( 0, difficulty ) > Random( 0, force); //Недолёт.
	bool badAim = Random( 0, difficulty ) > Random( 0, accuracy); //Упало рядом.
	float CatchRoll = Random( 0, catching );
	bool badCatch = CatchRoll < Random( 0, difficulty ) * 0.5; //Пролетело мимо
	
	//Тут длинная часть кода, определяющая то, куда упадёт предмет.
	if( dist > 0 ) {
		//x = player.HexX;
		//y = player.HexY;
		if(isFar) {
			if(tooWeak)
				map.MoveHexByDir( x, y, (dir+3)%6, Random( 1, dist * 0.5 ) );
			if(tooFar)
				map.MoveHexByDir( x, y, dir, Random(1,3) );
			if(badAim)
				map.MoveHexByDir( x, y, Random(0,6), 1 );
			if(!tooWeak && !badAim && badCatch && Random(0,1) == 0 )
				map.MoveHexByDir( x, y, dir, Random(1,2) );
		}
		if(!map.IsHexPassed( x, y ) && !valid(map.GetCritter(x,y) ) ) {
			int rDist = dist;
			uint16 x1 = x, y1 = y;
			while( !map.IsHexPassed( x1, y1 ) && rDist > 0 && !valid(map.GetCritter(x,y) ) ) {
				map.GetHexCoord( x, y, x1, y1, 30.0f, rDist );
				rDist--;
			}
			x = x1; y = y1;
		}
		if(!map.IsHexPassed( x, y ) && !valid(map.GetCritter(x,y))) {
			x = player.HexX;
			y = player.HexY;
			player.Say(SAY_NETMSG, "Замахнувшись, вы усомнились что сможете попасть в цель и просто подбросили в руке.");
		}
	}
	//Основная часть кода - определение итогового режима броска.
	Critter@ target = map.GetCritter(x,y);
	bool hasTarget = valid(target);
	bool isJoggling = hasTarget && target.Id == player.Id;
	bool isMissed = tooWeak && badAim; 
	bool isCatched = hasTarget && !isMissed && !badCatch && ( CatchRoll > Random( 0, difficulty ) ); 
	
	if(!isJoggling) player.SetDir( dir );
	_CritAnimateThrow( player );
	player.Wait(500);
	
	//player.Say(SAY_NETMSG, ( isCatched ? "catch " : "" ) + ( isFar ? "far " : "" ) + ( tooWeak ? "weak " : "" ) + ( badAim ? "!aim " : "" ) + ( badCatch ? "!catch " : "" ) + ( hasTarget ? "target " : "" ) + ( isJoggling ? "joggle " : "" ) );
	
	player.Say(SAY_EMOTE, ( isJoggling ? "подбрасывает в руке" : ( isFar ? "бросает" : ( hasTarget ? "передаёт" : "кладёт" ) ) ) );
	if(isCatched) {
		if(!isJoggling) {
			target.Say(SAY_EMOTE, ( isFar ? "ловит" : "берёт" ) );
			MoveItem( trowable, amount, target );
		}
	} else {
		if( hasTarget ) target.Say(SAY_EMOTE, ( isFar ? "не вышло поймать" : "роняет" ) );
		MoveItem( trowable, amount, map, x, y );
	}

	player.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 4 );
}

//START OF POPUPS
import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

void unsafe_selfLex( Critter& player, int, int, int, string@ text, int[]@ ) {
    if( !valid(text) || text == "" ) {
		player.SetLexems( null );
        //ShowInputBoxScreen( player, "item@unsafe_RpNamerUseScreen#Ваше описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
	} else {
		 player.SetLexems( text );
	}
}

void unsafe_silent( Critter& player, int, int, int, string@, int[]@ ) {
	if( player.ParamBase[ CR_SILENT_MODE ] == 0 ) {
        player.Say( SAY_NETMSG, "Вспомогательные сообщения отключены. Наслаждайтесь тишиной в чате.");
		player.ParamBase[ CR_SILENT_MODE ] = 1;
	} else {
        player.Say( SAY_NETMSG, "Вспомогательные сообщения включены. Теперь вы точно узнаете, когда у вас зачешется пятка.");
		player.ParamBase[ CR_SILENT_MODE ] = 0;
	}
}

void unsafe_checkAFK( Critter& player, int, int, int, string@ text, int[]@ ) {
	if( player.GetTimeEvents( CTE_AFK, null, null, null ) > 0 ) 
		player.EraseTimeEvents(CTE_AFK);
}
	
void unsafe_afk( Critter& player, int, int, int, string@ text, int[]@ ) {
	if( player.GetTimeEvents( CTE_AFK, null, null, null ) > 0 ) 
		player.EraseTimeEvents(CTE_AFK);
	Map@ map = player.GetMap();
	if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя" ); return; }
	Item@ holder = map.GetItem( player.HexX, player.HexY, PID_POPUP );
	if(!valid(holder)) @holder = map.AddItem( player.HexX, player.HexY, PID_POPUP, 1 );
	if(!valid(holder)) return;
	holder.SetEvent( ITEM_EVENT_WALK, "_removeInfo" );
	SETFLAG( holder.Flags, ITEM_TRAP );
	SETFLAG( holder.Flags, ITEM_HIDDEN );
	
	holder.Val0 = player.Id;
	holder.Val1 = 1;
	
	holder.SetLexems( null );
	if( !valid(text) || text == "" ) holder.SetLexems( "|0x5D6D7E Zzz.." );
	else holder.SetLexems( text );

	holder.Update();
	
	uint[] values = { player.Id, holder.Id };
	CreateTimeEvent( __FullSecond + REAL_SECOND(5), "e_AFK", values, false );
	player.AddTimeEvent( "cte_AFK", REAL_SECOND(5), CTE_AFK, 0 );
	player.Say( SAY_NETMSG, "Вы зафиксировали своё состояние. Сдвиньтесь или напишите текст что бы сбросить его." );
}

void _removeInfo( Item& holder, Critter& player, bool entered, uint8 dir ) {
	DeleteItem(holder);
}

uint cte_AFK( Critter& cr, int identifier, uint& rate )
{
	return REAL_SECOND(5);
}

uint e_AFK( uint[] @ values ) {
	if( values.length() < 2 ) return 0;
	Critter@ cr = GetCritter( values[0] );
	if(!valid(cr)) return 0;
	if( cr.GetTimeEvents( CTE_AFK, null, null, null ) == 0 ) 
		return 0;
	Item@ item = GetItem( values[1] );
	if(!valid(item)) return 0;
	UNSETFLAG( item.Flags, ITEM_HIDDEN );
	cr.RunClientScript( "client_main@ShowPopup", item.Id, 0, 0, "Всё оказалось немного сложней, чем вы думали..", null );
	SETFLAG( item.Flags, ITEM_HIDDEN );
	return REAL_SECOND(5);
}

void unsafe_newPopup( Critter& player, int, int, int, string@ text, int[]@) {
    if( !valid(text) || text == "" ) {
		player.Say( SAY_NETMSG, "Опишите детали, характерные для этого места." );
		ShowInputBoxScreen( player, "general_unsafe@unsafe_PopupDescInput#Описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
	} else {
		PopupDescInput( player, 0, text );
	}
}

void unsafe_PopupDescInput( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	PopupDescInput( player, 0, param3 );
}

void PopupDescInput( Critter& player, uint answerI, string& answerS ) {
    if( !valid(player) ) return;
    if( answerS.length() > 1 ) {
        if( changePopup( player, answerS ) ) {
            player.Say( SAY_NETMSG, "Вы заметили некоторые особенности этого места." );
        } else {
            player.Say( SAY_NETMSG, "У вас ничего не вышло." );
        }
    } else {
        if( delPopup( player ) ) {
            player.Say( SAY_NETMSG, "Вы убрали всё, что могло привлечь внимание." );
        } else {
            player.Say( SAY_NETMSG, "У вас не вышло замести следы." );
        }
    }
}//END OF POPUPS